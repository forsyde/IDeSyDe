// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/scheduling/jobshop_scheduling.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
namespace operations_research {
namespace scheduling {
namespace jssp {
class AssignedJob;
struct AssignedJobDefaultTypeInternal;
extern AssignedJobDefaultTypeInternal _AssignedJob_default_instance_;
class AssignedTask;
struct AssignedTaskDefaultTypeInternal;
extern AssignedTaskDefaultTypeInternal _AssignedTask_default_instance_;
class Job;
struct JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class JobPrecedence;
struct JobPrecedenceDefaultTypeInternal;
extern JobPrecedenceDefaultTypeInternal _JobPrecedence_default_instance_;
class JsspInputProblem;
struct JsspInputProblemDefaultTypeInternal;
extern JsspInputProblemDefaultTypeInternal _JsspInputProblem_default_instance_;
class JsspOutputSolution;
struct JsspOutputSolutionDefaultTypeInternal;
extern JsspOutputSolutionDefaultTypeInternal _JsspOutputSolution_default_instance_;
class Machine;
struct MachineDefaultTypeInternal;
extern MachineDefaultTypeInternal _Machine_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TransitionTimeMatrix;
struct TransitionTimeMatrixDefaultTypeInternal;
extern TransitionTimeMatrixDefaultTypeInternal _TransitionTimeMatrix_default_instance_;
}  // namespace jssp
}  // namespace scheduling
}  // namespace operations_research
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace operations_research {
namespace scheduling {
namespace jssp {

// ===================================================================


// -------------------------------------------------------------------

class TransitionTimeMatrix final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.TransitionTimeMatrix) */ {
 public:
  inline TransitionTimeMatrix() : TransitionTimeMatrix(nullptr) {}
  ~TransitionTimeMatrix() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitionTimeMatrix(::google::protobuf::internal::ConstantInitialized);

  inline TransitionTimeMatrix(const TransitionTimeMatrix& from)
      : TransitionTimeMatrix(nullptr, from) {}
  TransitionTimeMatrix(TransitionTimeMatrix&& from) noexcept
    : TransitionTimeMatrix() {
    *this = ::std::move(from);
  }

  inline TransitionTimeMatrix& operator=(const TransitionTimeMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitionTimeMatrix& operator=(TransitionTimeMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransitionTimeMatrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitionTimeMatrix* internal_default_instance() {
    return reinterpret_cast<const TransitionTimeMatrix*>(
               &_TransitionTimeMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TransitionTimeMatrix& a, TransitionTimeMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitionTimeMatrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitionTimeMatrix* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitionTimeMatrix* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitionTimeMatrix>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransitionTimeMatrix& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TransitionTimeMatrix& from) {
    TransitionTimeMatrix::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransitionTimeMatrix* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.TransitionTimeMatrix";
  }
  protected:
  explicit TransitionTimeMatrix(::google::protobuf::Arena* arena);
  TransitionTimeMatrix(::google::protobuf::Arena* arena, const TransitionTimeMatrix& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransitionTimeFieldNumber = 1,
  };
  // repeated int64 transition_time = 1;
  int transition_time_size() const;
  private:
  int _internal_transition_time_size() const;

  public:
  void clear_transition_time() ;
  ::int64_t transition_time(int index) const;
  void set_transition_time(int index, ::int64_t value);
  void add_transition_time(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& transition_time() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_transition_time();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_transition_time() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_transition_time();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.TransitionTimeMatrix)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int64_t> transition_time_;
    mutable ::google::protobuf::internal::CachedSize _transition_time_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};// -------------------------------------------------------------------

class Task final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Task(::google::protobuf::internal::ConstantInitialized);

  inline Task(const Task& from)
      : Task(nullptr, from) {}
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Task* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.Task";
  }
  protected:
  explicit Task(::google::protobuf::Arena* arena);
  Task(::google::protobuf::Arena* arena, const Task& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachineFieldNumber = 1,
    kDurationFieldNumber = 2,
    kCostFieldNumber = 3,
  };
  // repeated int32 machine = 1;
  int machine_size() const;
  private:
  int _internal_machine_size() const;

  public:
  void clear_machine() ;
  ::int32_t machine(int index) const;
  void set_machine(int index, ::int32_t value);
  void add_machine(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& machine() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_machine();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_machine() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_machine();

  public:
  // repeated int64 duration = 2;
  int duration_size() const;
  private:
  int _internal_duration_size() const;

  public:
  void clear_duration() ;
  ::int64_t duration(int index) const;
  void set_duration(int index, ::int64_t value);
  void add_duration(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& duration() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_duration();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_duration() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_duration();

  public:
  // repeated int64 cost = 3;
  int cost_size() const;
  private:
  int _internal_cost_size() const;

  public:
  void clear_cost() ;
  ::int64_t cost(int index) const;
  void set_cost(int index, ::int64_t value);
  void add_cost(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& cost() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_cost();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_cost() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_cost();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.Task)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int32_t> machine_;
    mutable ::google::protobuf::internal::CachedSize _machine_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> duration_;
    mutable ::google::protobuf::internal::CachedSize _duration_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> cost_;
    mutable ::google::protobuf::internal::CachedSize _cost_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};// -------------------------------------------------------------------

class JobPrecedence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.JobPrecedence) */ {
 public:
  inline JobPrecedence() : JobPrecedence(nullptr) {}
  ~JobPrecedence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JobPrecedence(::google::protobuf::internal::ConstantInitialized);

  inline JobPrecedence(const JobPrecedence& from)
      : JobPrecedence(nullptr, from) {}
  JobPrecedence(JobPrecedence&& from) noexcept
    : JobPrecedence() {
    *this = ::std::move(from);
  }

  inline JobPrecedence& operator=(const JobPrecedence& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobPrecedence& operator=(JobPrecedence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobPrecedence& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobPrecedence* internal_default_instance() {
    return reinterpret_cast<const JobPrecedence*>(
               &_JobPrecedence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JobPrecedence& a, JobPrecedence& b) {
    a.Swap(&b);
  }
  inline void Swap(JobPrecedence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobPrecedence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobPrecedence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobPrecedence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JobPrecedence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JobPrecedence& from) {
    JobPrecedence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JobPrecedence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.JobPrecedence";
  }
  protected:
  explicit JobPrecedence(::google::protobuf::Arena* arena);
  JobPrecedence(::google::protobuf::Arena* arena, const JobPrecedence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstJobIndexFieldNumber = 1,
    kSecondJobIndexFieldNumber = 2,
    kMinDelayFieldNumber = 3,
  };
  // int32 first_job_index = 1;
  void clear_first_job_index() ;
  ::int32_t first_job_index() const;
  void set_first_job_index(::int32_t value);

  private:
  ::int32_t _internal_first_job_index() const;
  void _internal_set_first_job_index(::int32_t value);

  public:
  // int32 second_job_index = 2;
  void clear_second_job_index() ;
  ::int32_t second_job_index() const;
  void set_second_job_index(::int32_t value);

  private:
  ::int32_t _internal_second_job_index() const;
  void _internal_set_second_job_index(::int32_t value);

  public:
  // int64 min_delay = 3;
  void clear_min_delay() ;
  ::int64_t min_delay() const;
  void set_min_delay(::int64_t value);

  private:
  ::int64_t _internal_min_delay() const;
  void _internal_set_min_delay(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.JobPrecedence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t first_job_index_;
    ::int32_t second_job_index_;
    ::int64_t min_delay_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};// -------------------------------------------------------------------

class AssignedTask final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.AssignedTask) */ {
 public:
  inline AssignedTask() : AssignedTask(nullptr) {}
  ~AssignedTask() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AssignedTask(::google::protobuf::internal::ConstantInitialized);

  inline AssignedTask(const AssignedTask& from)
      : AssignedTask(nullptr, from) {}
  AssignedTask(AssignedTask&& from) noexcept
    : AssignedTask() {
    *this = ::std::move(from);
  }

  inline AssignedTask& operator=(const AssignedTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignedTask& operator=(AssignedTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignedTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignedTask* internal_default_instance() {
    return reinterpret_cast<const AssignedTask*>(
               &_AssignedTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AssignedTask& a, AssignedTask& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignedTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignedTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignedTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssignedTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssignedTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AssignedTask& from) {
    AssignedTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssignedTask* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.AssignedTask";
  }
  protected:
  explicit AssignedTask(::google::protobuf::Arena* arena);
  AssignedTask(::google::protobuf::Arena* arena, const AssignedTask& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 2,
    kAlternativeIndexFieldNumber = 1,
  };
  // int64 start_time = 2;
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // int32 alternative_index = 1;
  void clear_alternative_index() ;
  ::int32_t alternative_index() const;
  void set_alternative_index(::int32_t value);

  private:
  ::int32_t _internal_alternative_index() const;
  void _internal_set_alternative_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.AssignedTask)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t start_time_;
    ::int32_t alternative_index_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};// -------------------------------------------------------------------

class Machine final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.Machine) */ {
 public:
  inline Machine() : Machine(nullptr) {}
  ~Machine() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Machine(::google::protobuf::internal::ConstantInitialized);

  inline Machine(const Machine& from)
      : Machine(nullptr, from) {}
  Machine(Machine&& from) noexcept
    : Machine() {
    *this = ::std::move(from);
  }

  inline Machine& operator=(const Machine& from) {
    CopyFrom(from);
    return *this;
  }
  inline Machine& operator=(Machine&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Machine& default_instance() {
    return *internal_default_instance();
  }
  static inline const Machine* internal_default_instance() {
    return reinterpret_cast<const Machine*>(
               &_Machine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Machine& a, Machine& b) {
    a.Swap(&b);
  }
  inline void Swap(Machine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Machine* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Machine* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Machine>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Machine& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Machine& from) {
    Machine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Machine* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.Machine";
  }
  protected:
  explicit Machine(::google::protobuf::Arena* arena);
  Machine(::google::protobuf::Arena* arena, const Machine& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 16,
    kTransitionTimeMatrixFieldNumber = 1,
  };
  // string name = 16;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .operations_research.scheduling.jssp.TransitionTimeMatrix transition_time_matrix = 1;
  bool has_transition_time_matrix() const;
  void clear_transition_time_matrix() ;
  const ::operations_research::scheduling::jssp::TransitionTimeMatrix& transition_time_matrix() const;
  PROTOBUF_NODISCARD ::operations_research::scheduling::jssp::TransitionTimeMatrix* release_transition_time_matrix();
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* mutable_transition_time_matrix();
  void set_allocated_transition_time_matrix(::operations_research::scheduling::jssp::TransitionTimeMatrix* value);
  void unsafe_arena_set_allocated_transition_time_matrix(::operations_research::scheduling::jssp::TransitionTimeMatrix* value);
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* unsafe_arena_release_transition_time_matrix();

  private:
  const ::operations_research::scheduling::jssp::TransitionTimeMatrix& _internal_transition_time_matrix() const;
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* _internal_mutable_transition_time_matrix();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.Machine)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::operations_research::scheduling::jssp::TransitionTimeMatrix* transition_time_matrix_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};// -------------------------------------------------------------------

class Job final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Job(::google::protobuf::internal::ConstantInitialized);

  inline Job(const Job& from)
      : Job(nullptr, from) {}
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }
  inline void Swap(Job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Job& from) {
    Job::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Job* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.Job";
  }
  protected:
  explicit Job(::google::protobuf::Arena* arena);
  Job(::google::protobuf::Arena* arena, const Job& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 1,
    kNameFieldNumber = 16,
    kEarliestStartFieldNumber = 2,
    kLatestEndFieldNumber = 7,
    kEarlyDueDateFieldNumber = 3,
    kLateDueDateFieldNumber = 4,
    kEarlinessCostPerTimeUnitFieldNumber = 5,
    kLatenessCostPerTimeUnitFieldNumber = 6,
  };
  // repeated .operations_research.scheduling.jssp.Task tasks = 1;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  ::operations_research::scheduling::jssp::Task* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Task >*
      mutable_tasks();
  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Task>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Task>* _internal_mutable_tasks();
  public:
  const ::operations_research::scheduling::jssp::Task& tasks(int index) const;
  ::operations_research::scheduling::jssp::Task* add_tasks();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Task >&
      tasks() const;
  // string name = 16;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .google.protobuf.Int64Value earliest_start = 2;
  bool has_earliest_start() const;
  void clear_earliest_start() ;
  const ::google::protobuf::Int64Value& earliest_start() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_earliest_start();
  ::google::protobuf::Int64Value* mutable_earliest_start();
  void set_allocated_earliest_start(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_earliest_start(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_earliest_start();

  private:
  const ::google::protobuf::Int64Value& _internal_earliest_start() const;
  ::google::protobuf::Int64Value* _internal_mutable_earliest_start();

  public:
  // .google.protobuf.Int64Value latest_end = 7;
  bool has_latest_end() const;
  void clear_latest_end() ;
  const ::google::protobuf::Int64Value& latest_end() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_latest_end();
  ::google::protobuf::Int64Value* mutable_latest_end();
  void set_allocated_latest_end(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_latest_end(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_latest_end();

  private:
  const ::google::protobuf::Int64Value& _internal_latest_end() const;
  ::google::protobuf::Int64Value* _internal_mutable_latest_end();

  public:
  // int64 early_due_date = 3;
  void clear_early_due_date() ;
  ::int64_t early_due_date() const;
  void set_early_due_date(::int64_t value);

  private:
  ::int64_t _internal_early_due_date() const;
  void _internal_set_early_due_date(::int64_t value);

  public:
  // int64 late_due_date = 4;
  void clear_late_due_date() ;
  ::int64_t late_due_date() const;
  void set_late_due_date(::int64_t value);

  private:
  ::int64_t _internal_late_due_date() const;
  void _internal_set_late_due_date(::int64_t value);

  public:
  // int64 earliness_cost_per_time_unit = 5;
  void clear_earliness_cost_per_time_unit() ;
  ::int64_t earliness_cost_per_time_unit() const;
  void set_earliness_cost_per_time_unit(::int64_t value);

  private:
  ::int64_t _internal_earliness_cost_per_time_unit() const;
  void _internal_set_earliness_cost_per_time_unit(::int64_t value);

  public:
  // int64 lateness_cost_per_time_unit = 6;
  void clear_lateness_cost_per_time_unit() ;
  ::int64_t lateness_cost_per_time_unit() const;
  void set_lateness_cost_per_time_unit(::int64_t value);

  private:
  ::int64_t _internal_lateness_cost_per_time_unit() const;
  void _internal_set_lateness_cost_per_time_unit(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.Job)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Task > tasks_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::Int64Value* earliest_start_;
    ::google::protobuf::Int64Value* latest_end_;
    ::int64_t early_due_date_;
    ::int64_t late_due_date_;
    ::int64_t earliness_cost_per_time_unit_;
    ::int64_t lateness_cost_per_time_unit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};// -------------------------------------------------------------------

class AssignedJob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.AssignedJob) */ {
 public:
  inline AssignedJob() : AssignedJob(nullptr) {}
  ~AssignedJob() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AssignedJob(::google::protobuf::internal::ConstantInitialized);

  inline AssignedJob(const AssignedJob& from)
      : AssignedJob(nullptr, from) {}
  AssignedJob(AssignedJob&& from) noexcept
    : AssignedJob() {
    *this = ::std::move(from);
  }

  inline AssignedJob& operator=(const AssignedJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignedJob& operator=(AssignedJob&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssignedJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssignedJob* internal_default_instance() {
    return reinterpret_cast<const AssignedJob*>(
               &_AssignedJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AssignedJob& a, AssignedJob& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignedJob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignedJob* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssignedJob* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssignedJob>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssignedJob& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AssignedJob& from) {
    AssignedJob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssignedJob* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.AssignedJob";
  }
  protected:
  explicit AssignedJob(::google::protobuf::Arena* arena);
  AssignedJob(::google::protobuf::Arena* arena, const AssignedJob& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 1,
    kDueDateCostFieldNumber = 2,
    kSumOfTaskCostsFieldNumber = 3,
  };
  // repeated .operations_research.scheduling.jssp.AssignedTask tasks = 1;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;

  public:
  void clear_tasks() ;
  ::operations_research::scheduling::jssp::AssignedTask* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedTask >*
      mutable_tasks();
  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedTask>& _internal_tasks() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedTask>* _internal_mutable_tasks();
  public:
  const ::operations_research::scheduling::jssp::AssignedTask& tasks(int index) const;
  ::operations_research::scheduling::jssp::AssignedTask* add_tasks();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedTask >&
      tasks() const;
  // int64 due_date_cost = 2;
  void clear_due_date_cost() ;
  ::int64_t due_date_cost() const;
  void set_due_date_cost(::int64_t value);

  private:
  ::int64_t _internal_due_date_cost() const;
  void _internal_set_due_date_cost(::int64_t value);

  public:
  // int64 sum_of_task_costs = 3;
  void clear_sum_of_task_costs() ;
  ::int64_t sum_of_task_costs() const;
  void set_sum_of_task_costs(::int64_t value);

  private:
  ::int64_t _internal_sum_of_task_costs() const;
  void _internal_set_sum_of_task_costs(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.AssignedJob)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedTask > tasks_;
    ::int64_t due_date_cost_;
    ::int64_t sum_of_task_costs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};// -------------------------------------------------------------------

class JsspOutputSolution final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.JsspOutputSolution) */ {
 public:
  inline JsspOutputSolution() : JsspOutputSolution(nullptr) {}
  ~JsspOutputSolution() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JsspOutputSolution(::google::protobuf::internal::ConstantInitialized);

  inline JsspOutputSolution(const JsspOutputSolution& from)
      : JsspOutputSolution(nullptr, from) {}
  JsspOutputSolution(JsspOutputSolution&& from) noexcept
    : JsspOutputSolution() {
    *this = ::std::move(from);
  }

  inline JsspOutputSolution& operator=(const JsspOutputSolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline JsspOutputSolution& operator=(JsspOutputSolution&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JsspOutputSolution& default_instance() {
    return *internal_default_instance();
  }
  static inline const JsspOutputSolution* internal_default_instance() {
    return reinterpret_cast<const JsspOutputSolution*>(
               &_JsspOutputSolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(JsspOutputSolution& a, JsspOutputSolution& b) {
    a.Swap(&b);
  }
  inline void Swap(JsspOutputSolution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JsspOutputSolution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JsspOutputSolution* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JsspOutputSolution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JsspOutputSolution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JsspOutputSolution& from) {
    JsspOutputSolution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JsspOutputSolution* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.JsspOutputSolution";
  }
  protected:
  explicit JsspOutputSolution(::google::protobuf::Arena* arena);
  JsspOutputSolution(::google::protobuf::Arena* arena, const JsspOutputSolution& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobsFieldNumber = 1,
    kMakespanCostFieldNumber = 2,
    kTotalCostFieldNumber = 3,
  };
  // repeated .operations_research.scheduling.jssp.AssignedJob jobs = 1;
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;

  public:
  void clear_jobs() ;
  ::operations_research::scheduling::jssp::AssignedJob* mutable_jobs(int index);
  ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedJob >*
      mutable_jobs();
  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedJob>& _internal_jobs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedJob>* _internal_mutable_jobs();
  public:
  const ::operations_research::scheduling::jssp::AssignedJob& jobs(int index) const;
  ::operations_research::scheduling::jssp::AssignedJob* add_jobs();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedJob >&
      jobs() const;
  // int64 makespan_cost = 2;
  void clear_makespan_cost() ;
  ::int64_t makespan_cost() const;
  void set_makespan_cost(::int64_t value);

  private:
  ::int64_t _internal_makespan_cost() const;
  void _internal_set_makespan_cost(::int64_t value);

  public:
  // int64 total_cost = 3;
  void clear_total_cost() ;
  ::int64_t total_cost() const;
  void set_total_cost(::int64_t value);

  private:
  ::int64_t _internal_total_cost() const;
  void _internal_set_total_cost(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.JsspOutputSolution)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::AssignedJob > jobs_;
    ::int64_t makespan_cost_;
    ::int64_t total_cost_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};// -------------------------------------------------------------------

class JsspInputProblem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.scheduling.jssp.JsspInputProblem) */ {
 public:
  inline JsspInputProblem() : JsspInputProblem(nullptr) {}
  ~JsspInputProblem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JsspInputProblem(::google::protobuf::internal::ConstantInitialized);

  inline JsspInputProblem(const JsspInputProblem& from)
      : JsspInputProblem(nullptr, from) {}
  JsspInputProblem(JsspInputProblem&& from) noexcept
    : JsspInputProblem() {
    *this = ::std::move(from);
  }

  inline JsspInputProblem& operator=(const JsspInputProblem& from) {
    CopyFrom(from);
    return *this;
  }
  inline JsspInputProblem& operator=(JsspInputProblem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JsspInputProblem& default_instance() {
    return *internal_default_instance();
  }
  static inline const JsspInputProblem* internal_default_instance() {
    return reinterpret_cast<const JsspInputProblem*>(
               &_JsspInputProblem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(JsspInputProblem& a, JsspInputProblem& b) {
    a.Swap(&b);
  }
  inline void Swap(JsspInputProblem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JsspInputProblem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JsspInputProblem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JsspInputProblem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JsspInputProblem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JsspInputProblem& from) {
    JsspInputProblem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JsspInputProblem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.scheduling.jssp.JsspInputProblem";
  }
  protected:
  explicit JsspInputProblem(::google::protobuf::Arena* arena);
  JsspInputProblem(::google::protobuf::Arena* arena, const JsspInputProblem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobsFieldNumber = 1,
    kMachinesFieldNumber = 2,
    kPrecedencesFieldNumber = 3,
    kNameFieldNumber = 16,
    kScalingFactorFieldNumber = 5,
    kMakespanCostPerTimeUnitFieldNumber = 4,
    kSeedFieldNumber = 24,
  };
  // repeated .operations_research.scheduling.jssp.Job jobs = 1;
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;

  public:
  void clear_jobs() ;
  ::operations_research::scheduling::jssp::Job* mutable_jobs(int index);
  ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Job >*
      mutable_jobs();
  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Job>& _internal_jobs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Job>* _internal_mutable_jobs();
  public:
  const ::operations_research::scheduling::jssp::Job& jobs(int index) const;
  ::operations_research::scheduling::jssp::Job* add_jobs();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Job >&
      jobs() const;
  // repeated .operations_research.scheduling.jssp.Machine machines = 2;
  int machines_size() const;
  private:
  int _internal_machines_size() const;

  public:
  void clear_machines() ;
  ::operations_research::scheduling::jssp::Machine* mutable_machines(int index);
  ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Machine >*
      mutable_machines();
  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Machine>& _internal_machines() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Machine>* _internal_mutable_machines();
  public:
  const ::operations_research::scheduling::jssp::Machine& machines(int index) const;
  ::operations_research::scheduling::jssp::Machine* add_machines();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Machine >&
      machines() const;
  // repeated .operations_research.scheduling.jssp.JobPrecedence precedences = 3;
  int precedences_size() const;
  private:
  int _internal_precedences_size() const;

  public:
  void clear_precedences() ;
  ::operations_research::scheduling::jssp::JobPrecedence* mutable_precedences(int index);
  ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::JobPrecedence >*
      mutable_precedences();
  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::JobPrecedence>& _internal_precedences() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::JobPrecedence>* _internal_mutable_precedences();
  public:
  const ::operations_research::scheduling::jssp::JobPrecedence& precedences(int index) const;
  ::operations_research::scheduling::jssp::JobPrecedence* add_precedences();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::JobPrecedence >&
      precedences() const;
  // string name = 16;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .google.protobuf.DoubleValue scaling_factor = 5;
  bool has_scaling_factor() const;
  void clear_scaling_factor() ;
  const ::google::protobuf::DoubleValue& scaling_factor() const;
  PROTOBUF_NODISCARD ::google::protobuf::DoubleValue* release_scaling_factor();
  ::google::protobuf::DoubleValue* mutable_scaling_factor();
  void set_allocated_scaling_factor(::google::protobuf::DoubleValue* value);
  void unsafe_arena_set_allocated_scaling_factor(::google::protobuf::DoubleValue* value);
  ::google::protobuf::DoubleValue* unsafe_arena_release_scaling_factor();

  private:
  const ::google::protobuf::DoubleValue& _internal_scaling_factor() const;
  ::google::protobuf::DoubleValue* _internal_mutable_scaling_factor();

  public:
  // int64 makespan_cost_per_time_unit = 4;
  void clear_makespan_cost_per_time_unit() ;
  ::int64_t makespan_cost_per_time_unit() const;
  void set_makespan_cost_per_time_unit(::int64_t value);

  private:
  ::int64_t _internal_makespan_cost_per_time_unit() const;
  void _internal_set_makespan_cost_per_time_unit(::int64_t value);

  public:
  // int32 seed = 24;
  void clear_seed() ;
  ::int32_t seed() const;
  void set_seed(::int32_t value);

  private:
  ::int32_t _internal_seed() const;
  void _internal_set_seed(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.scheduling.jssp.JsspInputProblem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 4,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Job > jobs_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::Machine > machines_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::scheduling::jssp::JobPrecedence > precedences_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::DoubleValue* scaling_factor_;
    ::int64_t makespan_cost_per_time_unit_;
    ::int32_t seed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Task

// repeated int32 machine = 1;
inline int Task::_internal_machine_size() const {
  return _internal_machine().size();
}
inline int Task::machine_size() const {
  return _internal_machine_size();
}
inline void Task::clear_machine() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.machine_.Clear();
}
inline ::int32_t Task::machine(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Task.machine)
  return _internal_machine().Get(index);
}
inline void Task::set_machine(int index, ::int32_t value) {
  _internal_mutable_machine()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Task.machine)
}
inline void Task::add_machine(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_machine()->Add(value);
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.Task.machine)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Task::machine() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.Task.machine)
  return _internal_machine();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Task::mutable_machine()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.Task.machine)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_machine();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Task::_internal_machine()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.machine_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Task::_internal_mutable_machine() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.machine_;
}

// repeated int64 duration = 2;
inline int Task::_internal_duration_size() const {
  return _internal_duration().size();
}
inline int Task::duration_size() const {
  return _internal_duration_size();
}
inline void Task::clear_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_.Clear();
}
inline ::int64_t Task::duration(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Task.duration)
  return _internal_duration().Get(index);
}
inline void Task::set_duration(int index, ::int64_t value) {
  _internal_mutable_duration()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Task.duration)
}
inline void Task::add_duration(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_duration()->Add(value);
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.Task.duration)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Task::duration() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.Task.duration)
  return _internal_duration();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Task::mutable_duration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.Task.duration)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_duration();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Task::_internal_duration()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Task::_internal_mutable_duration() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.duration_;
}

// repeated int64 cost = 3;
inline int Task::_internal_cost_size() const {
  return _internal_cost().size();
}
inline int Task::cost_size() const {
  return _internal_cost_size();
}
inline void Task::clear_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cost_.Clear();
}
inline ::int64_t Task::cost(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Task.cost)
  return _internal_cost().Get(index);
}
inline void Task::set_cost(int index, ::int64_t value) {
  _internal_mutable_cost()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Task.cost)
}
inline void Task::add_cost(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cost()->Add(value);
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.Task.cost)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Task::cost() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.Task.cost)
  return _internal_cost();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Task::mutable_cost()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.Task.cost)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cost();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Task::_internal_cost()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Task::_internal_mutable_cost() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cost_;
}

// -------------------------------------------------------------------

// Job

// repeated .operations_research.scheduling.jssp.Task tasks = 1;
inline int Job::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int Job::tasks_size() const {
  return _internal_tasks_size();
}
inline void Job::clear_tasks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tasks_.Clear();
}
inline ::operations_research::scheduling::jssp::Task* Job::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Job.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Task>* Job::mutable_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.Job.tasks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasks();
}
inline const ::operations_research::scheduling::jssp::Task& Job::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.tasks)
  return _internal_tasks().Get(index);
}
inline ::operations_research::scheduling::jssp::Task* Job::add_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::operations_research::scheduling::jssp::Task* _add = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.Job.tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Task>& Job::tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.Job.tasks)
  return _internal_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Task>&
Job::_internal_tasks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Task>*
Job::_internal_mutable_tasks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasks_;
}

// .google.protobuf.Int64Value earliest_start = 2;
inline bool Job::has_earliest_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.earliest_start_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& Job::_internal_earliest_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.earliest_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& Job::earliest_start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.earliest_start)
  return _internal_earliest_start();
}
inline void Job::unsafe_arena_set_allocated_earliest_start(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.earliest_start_);
  }
  _impl_.earliest_start_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.scheduling.jssp.Job.earliest_start)
}
inline ::google::protobuf::Int64Value* Job::release_earliest_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.earliest_start_;
  _impl_.earliest_start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* Job::unsafe_arena_release_earliest_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Job.earliest_start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.earliest_start_;
  _impl_.earliest_start_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* Job::_internal_mutable_earliest_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.earliest_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.earliest_start_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.earliest_start_;
}
inline ::google::protobuf::Int64Value* Job::mutable_earliest_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_earliest_start();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Job.earliest_start)
  return _msg;
}
inline void Job::set_allocated_earliest_start(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.earliest_start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.earliest_start_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Job.earliest_start)
}

// int64 early_due_date = 3;
inline void Job::clear_early_due_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.early_due_date_ = ::int64_t{0};
}
inline ::int64_t Job::early_due_date() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.early_due_date)
  return _internal_early_due_date();
}
inline void Job::set_early_due_date(::int64_t value) {
  _internal_set_early_due_date(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.early_due_date)
}
inline ::int64_t Job::_internal_early_due_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.early_due_date_;
}
inline void Job::_internal_set_early_due_date(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.early_due_date_ = value;
}

// int64 late_due_date = 4;
inline void Job::clear_late_due_date() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.late_due_date_ = ::int64_t{0};
}
inline ::int64_t Job::late_due_date() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.late_due_date)
  return _internal_late_due_date();
}
inline void Job::set_late_due_date(::int64_t value) {
  _internal_set_late_due_date(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.late_due_date)
}
inline ::int64_t Job::_internal_late_due_date() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.late_due_date_;
}
inline void Job::_internal_set_late_due_date(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.late_due_date_ = value;
}

// int64 earliness_cost_per_time_unit = 5;
inline void Job::clear_earliness_cost_per_time_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.earliness_cost_per_time_unit_ = ::int64_t{0};
}
inline ::int64_t Job::earliness_cost_per_time_unit() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.earliness_cost_per_time_unit)
  return _internal_earliness_cost_per_time_unit();
}
inline void Job::set_earliness_cost_per_time_unit(::int64_t value) {
  _internal_set_earliness_cost_per_time_unit(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.earliness_cost_per_time_unit)
}
inline ::int64_t Job::_internal_earliness_cost_per_time_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.earliness_cost_per_time_unit_;
}
inline void Job::_internal_set_earliness_cost_per_time_unit(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.earliness_cost_per_time_unit_ = value;
}

// int64 lateness_cost_per_time_unit = 6;
inline void Job::clear_lateness_cost_per_time_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lateness_cost_per_time_unit_ = ::int64_t{0};
}
inline ::int64_t Job::lateness_cost_per_time_unit() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.lateness_cost_per_time_unit)
  return _internal_lateness_cost_per_time_unit();
}
inline void Job::set_lateness_cost_per_time_unit(::int64_t value) {
  _internal_set_lateness_cost_per_time_unit(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.lateness_cost_per_time_unit)
}
inline ::int64_t Job::_internal_lateness_cost_per_time_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lateness_cost_per_time_unit_;
}
inline void Job::_internal_set_lateness_cost_per_time_unit(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lateness_cost_per_time_unit_ = value;
}

// .google.protobuf.Int64Value latest_end = 7;
inline bool Job::has_latest_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latest_end_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& Job::_internal_latest_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.latest_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& Job::latest_end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.latest_end)
  return _internal_latest_end();
}
inline void Job::unsafe_arena_set_allocated_latest_end(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latest_end_);
  }
  _impl_.latest_end_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.scheduling.jssp.Job.latest_end)
}
inline ::google::protobuf::Int64Value* Job::release_latest_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.latest_end_;
  _impl_.latest_end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* Job::unsafe_arena_release_latest_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Job.latest_end)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.latest_end_;
  _impl_.latest_end_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* Job::_internal_mutable_latest_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.latest_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.latest_end_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.latest_end_;
}
inline ::google::protobuf::Int64Value* Job::mutable_latest_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_latest_end();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Job.latest_end)
  return _msg;
}
inline void Job::set_allocated_latest_end(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latest_end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.latest_end_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Job.latest_end)
}

// string name = 16;
inline void Job::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Job::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Job.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Job::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Job.name)
}
inline std::string* Job::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Job.name)
  return _s;
}
inline const std::string& Job::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Job::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Job::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Job::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Job.name)
  return _impl_.name_.Release();
}
inline void Job::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Job.name)
}

// -------------------------------------------------------------------

// TransitionTimeMatrix

// repeated int64 transition_time = 1;
inline int TransitionTimeMatrix::_internal_transition_time_size() const {
  return _internal_transition_time().size();
}
inline int TransitionTimeMatrix::transition_time_size() const {
  return _internal_transition_time_size();
}
inline void TransitionTimeMatrix::clear_transition_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transition_time_.Clear();
}
inline ::int64_t TransitionTimeMatrix::transition_time(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
  return _internal_transition_time().Get(index);
}
inline void TransitionTimeMatrix::set_transition_time(int index, ::int64_t value) {
  _internal_mutable_transition_time()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
}
inline void TransitionTimeMatrix::add_transition_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_transition_time()->Add(value);
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TransitionTimeMatrix::transition_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
  return _internal_transition_time();
}
inline ::google::protobuf::RepeatedField<::int64_t>* TransitionTimeMatrix::mutable_transition_time()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.TransitionTimeMatrix.transition_time)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transition_time();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TransitionTimeMatrix::_internal_transition_time()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transition_time_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* TransitionTimeMatrix::_internal_mutable_transition_time() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transition_time_;
}

// -------------------------------------------------------------------

// Machine

// .operations_research.scheduling.jssp.TransitionTimeMatrix transition_time_matrix = 1;
inline bool Machine::has_transition_time_matrix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transition_time_matrix_ != nullptr);
  return value;
}
inline void Machine::clear_transition_time_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transition_time_matrix_ != nullptr) _impl_.transition_time_matrix_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::operations_research::scheduling::jssp::TransitionTimeMatrix& Machine::_internal_transition_time_matrix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::operations_research::scheduling::jssp::TransitionTimeMatrix* p = _impl_.transition_time_matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::scheduling::jssp::TransitionTimeMatrix&>(::operations_research::scheduling::jssp::_TransitionTimeMatrix_default_instance_);
}
inline const ::operations_research::scheduling::jssp::TransitionTimeMatrix& Machine::transition_time_matrix() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Machine.transition_time_matrix)
  return _internal_transition_time_matrix();
}
inline void Machine::unsafe_arena_set_allocated_transition_time_matrix(::operations_research::scheduling::jssp::TransitionTimeMatrix* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transition_time_matrix_);
  }
  _impl_.transition_time_matrix_ = reinterpret_cast<::operations_research::scheduling::jssp::TransitionTimeMatrix*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.scheduling.jssp.Machine.transition_time_matrix)
}
inline ::operations_research::scheduling::jssp::TransitionTimeMatrix* Machine::release_transition_time_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* released = _impl_.transition_time_matrix_;
  _impl_.transition_time_matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::operations_research::scheduling::jssp::TransitionTimeMatrix* Machine::unsafe_arena_release_transition_time_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Machine.transition_time_matrix)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* temp = _impl_.transition_time_matrix_;
  _impl_.transition_time_matrix_ = nullptr;
  return temp;
}
inline ::operations_research::scheduling::jssp::TransitionTimeMatrix* Machine::_internal_mutable_transition_time_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transition_time_matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::operations_research::scheduling::jssp::TransitionTimeMatrix>(GetArena());
    _impl_.transition_time_matrix_ = reinterpret_cast<::operations_research::scheduling::jssp::TransitionTimeMatrix*>(p);
  }
  return _impl_.transition_time_matrix_;
}
inline ::operations_research::scheduling::jssp::TransitionTimeMatrix* Machine::mutable_transition_time_matrix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::scheduling::jssp::TransitionTimeMatrix* _msg = _internal_mutable_transition_time_matrix();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Machine.transition_time_matrix)
  return _msg;
}
inline void Machine::set_allocated_transition_time_matrix(::operations_research::scheduling::jssp::TransitionTimeMatrix* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::operations_research::scheduling::jssp::TransitionTimeMatrix*>(_impl_.transition_time_matrix_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::operations_research::scheduling::jssp::TransitionTimeMatrix*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transition_time_matrix_ = reinterpret_cast<::operations_research::scheduling::jssp::TransitionTimeMatrix*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Machine.transition_time_matrix)
}

// string name = 16;
inline void Machine::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Machine::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.Machine.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Machine::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.Machine.name)
}
inline std::string* Machine::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.Machine.name)
  return _s;
}
inline const std::string& Machine::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Machine::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Machine::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Machine::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.Machine.name)
  return _impl_.name_.Release();
}
inline void Machine::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.Machine.name)
}

// -------------------------------------------------------------------

// JobPrecedence

// int32 first_job_index = 1;
inline void JobPrecedence::clear_first_job_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_job_index_ = 0;
}
inline ::int32_t JobPrecedence::first_job_index() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JobPrecedence.first_job_index)
  return _internal_first_job_index();
}
inline void JobPrecedence::set_first_job_index(::int32_t value) {
  _internal_set_first_job_index(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JobPrecedence.first_job_index)
}
inline ::int32_t JobPrecedence::_internal_first_job_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_job_index_;
}
inline void JobPrecedence::_internal_set_first_job_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_job_index_ = value;
}

// int32 second_job_index = 2;
inline void JobPrecedence::clear_second_job_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.second_job_index_ = 0;
}
inline ::int32_t JobPrecedence::second_job_index() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JobPrecedence.second_job_index)
  return _internal_second_job_index();
}
inline void JobPrecedence::set_second_job_index(::int32_t value) {
  _internal_set_second_job_index(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JobPrecedence.second_job_index)
}
inline ::int32_t JobPrecedence::_internal_second_job_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.second_job_index_;
}
inline void JobPrecedence::_internal_set_second_job_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.second_job_index_ = value;
}

// int64 min_delay = 3;
inline void JobPrecedence::clear_min_delay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_delay_ = ::int64_t{0};
}
inline ::int64_t JobPrecedence::min_delay() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JobPrecedence.min_delay)
  return _internal_min_delay();
}
inline void JobPrecedence::set_min_delay(::int64_t value) {
  _internal_set_min_delay(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JobPrecedence.min_delay)
}
inline ::int64_t JobPrecedence::_internal_min_delay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_delay_;
}
inline void JobPrecedence::_internal_set_min_delay(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_delay_ = value;
}

// -------------------------------------------------------------------

// JsspInputProblem

// repeated .operations_research.scheduling.jssp.Job jobs = 1;
inline int JsspInputProblem::_internal_jobs_size() const {
  return _internal_jobs().size();
}
inline int JsspInputProblem::jobs_size() const {
  return _internal_jobs_size();
}
inline void JsspInputProblem::clear_jobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobs_.Clear();
}
inline ::operations_research::scheduling::jssp::Job* JsspInputProblem::mutable_jobs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return _internal_mutable_jobs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Job>* JsspInputProblem::mutable_jobs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jobs();
}
inline const ::operations_research::scheduling::jssp::Job& JsspInputProblem::jobs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return _internal_jobs().Get(index);
}
inline ::operations_research::scheduling::jssp::Job* JsspInputProblem::add_jobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::operations_research::scheduling::jssp::Job* _add = _internal_mutable_jobs()->Add();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Job>& JsspInputProblem::jobs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.JsspInputProblem.jobs)
  return _internal_jobs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Job>&
JsspInputProblem::_internal_jobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Job>*
JsspInputProblem::_internal_mutable_jobs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jobs_;
}

// repeated .operations_research.scheduling.jssp.Machine machines = 2;
inline int JsspInputProblem::_internal_machines_size() const {
  return _internal_machines().size();
}
inline int JsspInputProblem::machines_size() const {
  return _internal_machines_size();
}
inline void JsspInputProblem::clear_machines() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.machines_.Clear();
}
inline ::operations_research::scheduling::jssp::Machine* JsspInputProblem::mutable_machines(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return _internal_mutable_machines()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Machine>* JsspInputProblem::mutable_machines()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.JsspInputProblem.machines)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_machines();
}
inline const ::operations_research::scheduling::jssp::Machine& JsspInputProblem::machines(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return _internal_machines().Get(index);
}
inline ::operations_research::scheduling::jssp::Machine* JsspInputProblem::add_machines() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::operations_research::scheduling::jssp::Machine* _add = _internal_mutable_machines()->Add();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Machine>& JsspInputProblem::machines() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.JsspInputProblem.machines)
  return _internal_machines();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Machine>&
JsspInputProblem::_internal_machines() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.machines_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::Machine>*
JsspInputProblem::_internal_mutable_machines() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.machines_;
}

// repeated .operations_research.scheduling.jssp.JobPrecedence precedences = 3;
inline int JsspInputProblem::_internal_precedences_size() const {
  return _internal_precedences().size();
}
inline int JsspInputProblem::precedences_size() const {
  return _internal_precedences_size();
}
inline void JsspInputProblem::clear_precedences() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.precedences_.Clear();
}
inline ::operations_research::scheduling::jssp::JobPrecedence* JsspInputProblem::mutable_precedences(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return _internal_mutable_precedences()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::JobPrecedence>* JsspInputProblem::mutable_precedences()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_precedences();
}
inline const ::operations_research::scheduling::jssp::JobPrecedence& JsspInputProblem::precedences(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return _internal_precedences().Get(index);
}
inline ::operations_research::scheduling::jssp::JobPrecedence* JsspInputProblem::add_precedences() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::operations_research::scheduling::jssp::JobPrecedence* _add = _internal_mutable_precedences()->Add();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::JobPrecedence>& JsspInputProblem::precedences() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.JsspInputProblem.precedences)
  return _internal_precedences();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::JobPrecedence>&
JsspInputProblem::_internal_precedences() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.precedences_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::JobPrecedence>*
JsspInputProblem::_internal_mutable_precedences() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.precedences_;
}

// int64 makespan_cost_per_time_unit = 4;
inline void JsspInputProblem::clear_makespan_cost_per_time_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.makespan_cost_per_time_unit_ = ::int64_t{0};
}
inline ::int64_t JsspInputProblem::makespan_cost_per_time_unit() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.makespan_cost_per_time_unit)
  return _internal_makespan_cost_per_time_unit();
}
inline void JsspInputProblem::set_makespan_cost_per_time_unit(::int64_t value) {
  _internal_set_makespan_cost_per_time_unit(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspInputProblem.makespan_cost_per_time_unit)
}
inline ::int64_t JsspInputProblem::_internal_makespan_cost_per_time_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.makespan_cost_per_time_unit_;
}
inline void JsspInputProblem::_internal_set_makespan_cost_per_time_unit(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.makespan_cost_per_time_unit_ = value;
}

// .google.protobuf.DoubleValue scaling_factor = 5;
inline bool JsspInputProblem::has_scaling_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scaling_factor_ != nullptr);
  return value;
}
inline const ::google::protobuf::DoubleValue& JsspInputProblem::_internal_scaling_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::DoubleValue* p = _impl_.scaling_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::DoubleValue&>(::google::protobuf::_DoubleValue_default_instance_);
}
inline const ::google::protobuf::DoubleValue& JsspInputProblem::scaling_factor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
  return _internal_scaling_factor();
}
inline void JsspInputProblem::unsafe_arena_set_allocated_scaling_factor(::google::protobuf::DoubleValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scaling_factor_);
  }
  _impl_.scaling_factor_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
}
inline ::google::protobuf::DoubleValue* JsspInputProblem::release_scaling_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* released = _impl_.scaling_factor_;
  _impl_.scaling_factor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::DoubleValue* JsspInputProblem::unsafe_arena_release_scaling_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::DoubleValue* temp = _impl_.scaling_factor_;
  _impl_.scaling_factor_ = nullptr;
  return temp;
}
inline ::google::protobuf::DoubleValue* JsspInputProblem::_internal_mutable_scaling_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.scaling_factor_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::DoubleValue>(GetArena());
    _impl_.scaling_factor_ = reinterpret_cast<::google::protobuf::DoubleValue*>(p);
  }
  return _impl_.scaling_factor_;
}
inline ::google::protobuf::DoubleValue* JsspInputProblem::mutable_scaling_factor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::DoubleValue* _msg = _internal_mutable_scaling_factor();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
  return _msg;
}
inline void JsspInputProblem::set_allocated_scaling_factor(::google::protobuf::DoubleValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scaling_factor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.scaling_factor_ = reinterpret_cast<::google::protobuf::DoubleValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.JsspInputProblem.scaling_factor)
}

// int32 seed = 24;
inline void JsspInputProblem::clear_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seed_ = 0;
}
inline ::int32_t JsspInputProblem::seed() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.seed)
  return _internal_seed();
}
inline void JsspInputProblem::set_seed(::int32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspInputProblem.seed)
}
inline ::int32_t JsspInputProblem::_internal_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seed_;
}
inline void JsspInputProblem::_internal_set_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seed_ = value;
}

// string name = 16;
inline void JsspInputProblem::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& JsspInputProblem::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspInputProblem.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JsspInputProblem::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspInputProblem.name)
}
inline std::string* JsspInputProblem::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspInputProblem.name)
  return _s;
}
inline const std::string& JsspInputProblem::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void JsspInputProblem::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* JsspInputProblem::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* JsspInputProblem::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.scheduling.jssp.JsspInputProblem.name)
  return _impl_.name_.Release();
}
inline void JsspInputProblem::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.scheduling.jssp.JsspInputProblem.name)
}

// -------------------------------------------------------------------

// AssignedTask

// int32 alternative_index = 1;
inline void AssignedTask::clear_alternative_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alternative_index_ = 0;
}
inline ::int32_t AssignedTask::alternative_index() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedTask.alternative_index)
  return _internal_alternative_index();
}
inline void AssignedTask::set_alternative_index(::int32_t value) {
  _internal_set_alternative_index(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.AssignedTask.alternative_index)
}
inline ::int32_t AssignedTask::_internal_alternative_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alternative_index_;
}
inline void AssignedTask::_internal_set_alternative_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.alternative_index_ = value;
}

// int64 start_time = 2;
inline void AssignedTask::clear_start_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t AssignedTask::start_time() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedTask.start_time)
  return _internal_start_time();
}
inline void AssignedTask::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.AssignedTask.start_time)
}
inline ::int64_t AssignedTask::_internal_start_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_time_;
}
inline void AssignedTask::_internal_set_start_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_time_ = value;
}

// -------------------------------------------------------------------

// AssignedJob

// repeated .operations_research.scheduling.jssp.AssignedTask tasks = 1;
inline int AssignedJob::_internal_tasks_size() const {
  return _internal_tasks().size();
}
inline int AssignedJob::tasks_size() const {
  return _internal_tasks_size();
}
inline void AssignedJob::clear_tasks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tasks_.Clear();
}
inline ::operations_research::scheduling::jssp::AssignedTask* AssignedJob::mutable_tasks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.AssignedJob.tasks)
  return _internal_mutable_tasks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedTask>* AssignedJob::mutable_tasks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.AssignedJob.tasks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasks();
}
inline const ::operations_research::scheduling::jssp::AssignedTask& AssignedJob::tasks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedJob.tasks)
  return _internal_tasks().Get(index);
}
inline ::operations_research::scheduling::jssp::AssignedTask* AssignedJob::add_tasks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::operations_research::scheduling::jssp::AssignedTask* _add = _internal_mutable_tasks()->Add();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.AssignedJob.tasks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedTask>& AssignedJob::tasks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.AssignedJob.tasks)
  return _internal_tasks();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedTask>&
AssignedJob::_internal_tasks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasks_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedTask>*
AssignedJob::_internal_mutable_tasks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasks_;
}

// int64 due_date_cost = 2;
inline void AssignedJob::clear_due_date_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.due_date_cost_ = ::int64_t{0};
}
inline ::int64_t AssignedJob::due_date_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedJob.due_date_cost)
  return _internal_due_date_cost();
}
inline void AssignedJob::set_due_date_cost(::int64_t value) {
  _internal_set_due_date_cost(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.AssignedJob.due_date_cost)
}
inline ::int64_t AssignedJob::_internal_due_date_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.due_date_cost_;
}
inline void AssignedJob::_internal_set_due_date_cost(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.due_date_cost_ = value;
}

// int64 sum_of_task_costs = 3;
inline void AssignedJob::clear_sum_of_task_costs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sum_of_task_costs_ = ::int64_t{0};
}
inline ::int64_t AssignedJob::sum_of_task_costs() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.AssignedJob.sum_of_task_costs)
  return _internal_sum_of_task_costs();
}
inline void AssignedJob::set_sum_of_task_costs(::int64_t value) {
  _internal_set_sum_of_task_costs(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.AssignedJob.sum_of_task_costs)
}
inline ::int64_t AssignedJob::_internal_sum_of_task_costs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sum_of_task_costs_;
}
inline void AssignedJob::_internal_set_sum_of_task_costs(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sum_of_task_costs_ = value;
}

// -------------------------------------------------------------------

// JsspOutputSolution

// repeated .operations_research.scheduling.jssp.AssignedJob jobs = 1;
inline int JsspOutputSolution::_internal_jobs_size() const {
  return _internal_jobs().size();
}
inline int JsspOutputSolution::jobs_size() const {
  return _internal_jobs_size();
}
inline void JsspOutputSolution::clear_jobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobs_.Clear();
}
inline ::operations_research::scheduling::jssp::AssignedJob* JsspOutputSolution::mutable_jobs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return _internal_mutable_jobs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedJob>* JsspOutputSolution::mutable_jobs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jobs();
}
inline const ::operations_research::scheduling::jssp::AssignedJob& JsspOutputSolution::jobs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return _internal_jobs().Get(index);
}
inline ::operations_research::scheduling::jssp::AssignedJob* JsspOutputSolution::add_jobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::operations_research::scheduling::jssp::AssignedJob* _add = _internal_mutable_jobs()->Add();
  // @@protoc_insertion_point(field_add:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedJob>& JsspOutputSolution::jobs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.scheduling.jssp.JsspOutputSolution.jobs)
  return _internal_jobs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedJob>&
JsspOutputSolution::_internal_jobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::scheduling::jssp::AssignedJob>*
JsspOutputSolution::_internal_mutable_jobs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jobs_;
}

// int64 makespan_cost = 2;
inline void JsspOutputSolution::clear_makespan_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.makespan_cost_ = ::int64_t{0};
}
inline ::int64_t JsspOutputSolution::makespan_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspOutputSolution.makespan_cost)
  return _internal_makespan_cost();
}
inline void JsspOutputSolution::set_makespan_cost(::int64_t value) {
  _internal_set_makespan_cost(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspOutputSolution.makespan_cost)
}
inline ::int64_t JsspOutputSolution::_internal_makespan_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.makespan_cost_;
}
inline void JsspOutputSolution::_internal_set_makespan_cost(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.makespan_cost_ = value;
}

// int64 total_cost = 3;
inline void JsspOutputSolution::clear_total_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_cost_ = ::int64_t{0};
}
inline ::int64_t JsspOutputSolution::total_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.scheduling.jssp.JsspOutputSolution.total_cost)
  return _internal_total_cost();
}
inline void JsspOutputSolution::set_total_cost(::int64_t value) {
  _internal_set_total_cost(value);
  // @@protoc_insertion_point(field_set:operations_research.scheduling.jssp.JsspOutputSolution.total_cost)
}
inline ::int64_t JsspOutputSolution::_internal_total_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_cost_;
}
inline void JsspOutputSolution::_internal_set_total_cost(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_cost_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace jssp
}  // namespace scheduling
}  // namespace operations_research


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ortools_2fscheduling_2fjobshop_5fscheduling_2eproto_2epb_2eh
