// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use idesyde_core::data::{DecisionModelHeader, DesignModelHeader, ExplorationConfiguration};

use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_BODY_ENCODING: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_BODY_ENCODING: i8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BODY_ENCODING: [BodyEncoding; 4] = [
    BodyEncoding::FlatBuffer,
    BodyEncoding::CBOR,
    BodyEncoding::MsgPack,
    BodyEncoding::JSON_UTF8,
];

/// A decision model message must be serialzied to be passed around between modules.
/// This enumeration dictates what type of encoding is used for the bytes present
/// insidea decision model message.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BodyEncoding(pub i8);
#[allow(non_upper_case_globals)]
impl BodyEncoding {
    pub const FlatBuffer: Self = Self(0);
    pub const CBOR: Self = Self(1);
    pub const MsgPack: Self = Self(2);
    pub const JSON_UTF8: Self = Self(3);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::FlatBuffer, Self::CBOR, Self::MsgPack, Self::JSON_UTF8];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::FlatBuffer => Some("FlatBuffer"),
            Self::CBOR => Some("CBOR"),
            Self::MsgPack => Some("MsgPack"),
            Self::JSON_UTF8 => Some("JSON_UTF8"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for BodyEncoding {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for BodyEncoding {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for BodyEncoding {
    type Output = BodyEncoding;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BodyEncoding {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for BodyEncoding {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

pub enum DecisionModelMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A decision model is a collection of parameters and associated functions that potentially define design spaces,
///  e.g. a decision model for tiled based platforms.
///
/// This message enables the decision models to be exchaged between modules and programs in an opaque form.
pub struct DecisionModelMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DecisionModelMessage<'a> {
    type Inner = DecisionModelMessage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DecisionModelMessage<'a> {
    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_BODY_ENCODING: flatbuffers::VOffsetT = 6;
    pub const VT_BODY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DecisionModelMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DecisionModelMessageArgs<'args>,
    ) -> flatbuffers::WIPOffset<DecisionModelMessage<'bldr>> {
        let mut builder = DecisionModelMessageBuilder::new(_fbb);
        if let Some(x) = args.body {
            builder.add_body(x);
        }
        if let Some(x) = args.header {
            builder.add_header(x);
        }
        builder.add_body_encoding(args.body_encoding);
        builder.finish()
    }

    #[inline]
    pub fn header(&self) -> Option<DecisionModelHeader<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DecisionModelHeader>>(
                    DecisionModelMessage::VT_HEADER,
                    None,
                )
        }
    }
    #[inline]
    pub fn body_encoding(&self) -> BodyEncoding {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<BodyEncoding>(
                    DecisionModelMessage::VT_BODY_ENCODING,
                    Some(BodyEncoding::FlatBuffer),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn body(&self) -> Option<flatbuffers::Vector<'a, i8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                    DecisionModelMessage::VT_BODY,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for DecisionModelMessage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DecisionModelHeader>>(
                "header",
                Self::VT_HEADER,
                false,
            )?
            .visit_field::<BodyEncoding>("body_encoding", Self::VT_BODY_ENCODING, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(
                "body",
                Self::VT_BODY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DecisionModelMessageArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<DecisionModelHeader<'a>>>,
    pub body_encoding: BodyEncoding,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for DecisionModelMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        DecisionModelMessageArgs {
            header: None,
            body_encoding: BodyEncoding::FlatBuffer,
            body: None,
        }
    }
}

pub struct DecisionModelMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DecisionModelMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_header(&mut self, header: flatbuffers::WIPOffset<DecisionModelHeader<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DecisionModelHeader>>(
                DecisionModelMessage::VT_HEADER,
                header,
            );
    }
    #[inline]
    pub fn add_body_encoding(&mut self, body_encoding: BodyEncoding) {
        self.fbb_.push_slot::<BodyEncoding>(
            DecisionModelMessage::VT_BODY_ENCODING,
            body_encoding,
            BodyEncoding::FlatBuffer,
        );
    }
    #[inline]
    pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DecisionModelMessage::VT_BODY, body);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DecisionModelMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DecisionModelMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DecisionModelMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DecisionModelMessage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DecisionModelMessage");
        ds.field("header", &self.header());
        ds.field("body_encoding", &self.body_encoding());
        ds.field("body", &self.body());
        ds.finish()
    }
}
pub enum DesignModelMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A design model is a model used by MDE frameworks and tools, e.g. Simulink and ForSyDe IO.
/// Like [DesignModel], this trait requires a header so that the identification procedure can work
/// correctly and terminate. The header gives an idea to the framework on how much can be "identified"
/// from the input MDE model, i.e. the [DesignModel].
///
/// This message enables the design models to be exchaged between modules and programs in an opaque form.
pub struct DesignModelMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesignModelMessage<'a> {
    type Inner = DesignModelMessage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DesignModelMessage<'a> {
    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_FORMAT: flatbuffers::VOffsetT = 6;
    pub const VT_BODY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DesignModelMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DesignModelMessageArgs<'args>,
    ) -> flatbuffers::WIPOffset<DesignModelMessage<'bldr>> {
        let mut builder = DesignModelMessageBuilder::new(_fbb);
        if let Some(x) = args.body {
            builder.add_body(x);
        }
        if let Some(x) = args.format {
            builder.add_format(x);
        }
        if let Some(x) = args.header {
            builder.add_header(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn header(&self) -> Option<DesignModelHeader<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DesignModelHeader>>(
                    DesignModelMessage::VT_HEADER,
                    None,
                )
        }
    }
    #[inline]
    pub fn format(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DesignModelMessage::VT_FORMAT, None)
        }
    }
    #[inline]
    pub fn body(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DesignModelMessage::VT_BODY, None)
        }
    }
}

impl flatbuffers::Verifiable for DesignModelMessage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DesignModelHeader>>(
                "header",
                Self::VT_HEADER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("format", Self::VT_FORMAT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
            .finish();
        Ok(())
    }
}
pub struct DesignModelMessageArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<DesignModelHeader<'a>>>,
    pub format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DesignModelMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        DesignModelMessageArgs {
            header: None,
            format: None,
            body: None,
        }
    }
}

pub struct DesignModelMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesignModelMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_header(&mut self, header: flatbuffers::WIPOffset<DesignModelHeader<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DesignModelHeader>>(
                DesignModelMessage::VT_HEADER,
                header,
            );
    }
    #[inline]
    pub fn add_format(&mut self, format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DesignModelMessage::VT_FORMAT, format);
    }
    #[inline]
    pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DesignModelMessage::VT_BODY, body);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DesignModelMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DesignModelMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DesignModelMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DesignModelMessage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DesignModelMessage");
        ds.field("header", &self.header());
        ds.field("format", &self.format());
        ds.field("body", &self.body());
        ds.finish()
    }
}
pub enum ExplorationSolutionMessageEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A simple struct to define a key-valye pair that is used inside the exploration solution message.
pub struct ExplorationSolutionMessageEntry<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationSolutionMessageEntry<'a> {
    type Inner = ExplorationSolutionMessageEntry<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ExplorationSolutionMessageEntry<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExplorationSolutionMessageEntry { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExplorationSolutionMessageEntryArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExplorationSolutionMessageEntry<'bldr>> {
        let mut builder = ExplorationSolutionMessageEntryBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                ExplorationSolutionMessageEntry::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f64>(ExplorationSolutionMessageEntry::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ExplorationSolutionMessageEntry<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<f64>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct ExplorationSolutionMessageEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f64,
}
impl<'a> Default for ExplorationSolutionMessageEntryArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExplorationSolutionMessageEntryArgs {
            name: None,
            value: 0.0,
        }
    }
}

pub struct ExplorationSolutionMessageEntryBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationSolutionMessageEntryBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExplorationSolutionMessageEntry::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f64) {
        self.fbb_
            .push_slot::<f64>(ExplorationSolutionMessageEntry::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExplorationSolutionMessageEntryBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExplorationSolutionMessageEntryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationSolutionMessageEntry<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExplorationSolutionMessageEntry<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExplorationSolutionMessageEntry");
        ds.field("name", &self.name());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum ExplorationSolutionMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A exploration message contains the decision model with its enhanced parameters as well as the objectives.
///
/// Both the model and its objectives are given back as a message so that explorers can quickly use the objectives
/// directly instead of rebuilding the model and recomputing the objectives from the rebuild model.
/// On a more advanced note, taking the objectives directly also enables the explorer to focus only on a few
/// design goals and/or share objectives between decision models that are "alike" but not of the same category.
pub struct ExplorationSolutionMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationSolutionMessage<'a> {
    type Inner = ExplorationSolutionMessage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ExplorationSolutionMessage<'a> {
    pub const VT_SOLVED: flatbuffers::VOffsetT = 4;
    pub const VT_OBJECTIVES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExplorationSolutionMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExplorationSolutionMessageArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExplorationSolutionMessage<'bldr>> {
        let mut builder = ExplorationSolutionMessageBuilder::new(_fbb);
        if let Some(x) = args.objectives {
            builder.add_objectives(x);
        }
        if let Some(x) = args.solved {
            builder.add_solved(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn solved(&self) -> Option<DecisionModelMessage<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DecisionModelMessage>>(
                    ExplorationSolutionMessage::VT_SOLVED,
                    None,
                )
        }
    }
    #[inline]
    pub fn objectives(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry>,
                >,
            >>(ExplorationSolutionMessage::VT_OBJECTIVES, None)
        }
    }
}

impl flatbuffers::Verifiable for ExplorationSolutionMessage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DecisionModelMessage>>(
                "solved",
                Self::VT_SOLVED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry>,
                >,
            >>("objectives", Self::VT_OBJECTIVES, false)?
            .finish();
        Ok(())
    }
}
pub struct ExplorationSolutionMessageArgs<'a> {
    pub solved: Option<flatbuffers::WIPOffset<DecisionModelMessage<'a>>>,
    pub objectives: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for ExplorationSolutionMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExplorationSolutionMessageArgs {
            solved: None,
            objectives: None,
        }
    }
}

pub struct ExplorationSolutionMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationSolutionMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_solved(&mut self, solved: flatbuffers::WIPOffset<DecisionModelMessage<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DecisionModelMessage>>(
                ExplorationSolutionMessage::VT_SOLVED,
                solved,
            );
    }
    #[inline]
    pub fn add_objectives(
        &mut self,
        objectives: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExplorationSolutionMessage::VT_OBJECTIVES,
            objectives,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExplorationSolutionMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExplorationSolutionMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationSolutionMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExplorationSolutionMessage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExplorationSolutionMessage");
        ds.field("solved", &self.solved());
        ds.field("objectives", &self.objectives());
        ds.finish()
    }
}
pub enum IdentificationResultMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The results of an identification step during the identification procedure.
///
/// The "messages" enable the modules to broadcast informative messages to the orchestrator,
/// who then can report to the user as it deems appropriate.
pub struct IdentificationResultMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentificationResultMessage<'a> {
    type Inner = IdentificationResultMessage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> IdentificationResultMessage<'a> {
    pub const VT_IDENTIFIED: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IdentificationResultMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IdentificationResultMessageArgs<'args>,
    ) -> flatbuffers::WIPOffset<IdentificationResultMessage<'bldr>> {
        let mut builder = IdentificationResultMessageBuilder::new(_fbb);
        if let Some(x) = args.messages {
            builder.add_messages(x);
        }
        if let Some(x) = args.identified {
            builder.add_identified(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn identified(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DecisionModelMessage<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DecisionModelMessage>>,
            >>(IdentificationResultMessage::VT_IDENTIFIED, None)
        }
    }
    #[inline]
    pub fn messages(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(IdentificationResultMessage::VT_MESSAGES, None)
        }
    }
}

impl flatbuffers::Verifiable for IdentificationResultMessage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DecisionModelMessage>>,
            >>("identified", Self::VT_IDENTIFIED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("messages", Self::VT_MESSAGES, false)?
            .finish();
        Ok(())
    }
}
pub struct IdentificationResultMessageArgs<'a> {
    pub identified: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DecisionModelMessage<'a>>>,
        >,
    >,
    pub messages: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for IdentificationResultMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        IdentificationResultMessageArgs {
            identified: None,
            messages: None,
        }
    }
}

pub struct IdentificationResultMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IdentificationResultMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_identified(
        &mut self,
        identified: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DecisionModelMessage<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            IdentificationResultMessage::VT_IDENTIFIED,
            identified,
        );
    }
    #[inline]
    pub fn add_messages(
        &mut self,
        messages: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            IdentificationResultMessage::VT_MESSAGES,
            messages,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> IdentificationResultMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        IdentificationResultMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IdentificationResultMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IdentificationResultMessage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IdentificationResultMessage");
        ds.field("identified", &self.identified());
        ds.field("messages", &self.messages());
        ds.finish()
    }
}
pub enum ExplorationRequestMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A request for exploration.
///
/// All the extra parameters related to exploration are aggregated into the ExplorationConfiguration
/// object/
pub struct ExplorationRequestMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationRequestMessage<'a> {
    type Inner = ExplorationRequestMessage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ExplorationRequestMessage<'a> {
    pub const VT_MODEL: flatbuffers::VOffsetT = 4;
    pub const VT_SOLUTIONS: flatbuffers::VOffsetT = 6;
    pub const VT_CONFIGURATION: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExplorationRequestMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExplorationRequestMessageArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExplorationRequestMessage<'bldr>> {
        let mut builder = ExplorationRequestMessageBuilder::new(_fbb);
        if let Some(x) = args.configuration {
            builder.add_configuration(x);
        }
        if let Some(x) = args.solutions {
            builder.add_solutions(x);
        }
        if let Some(x) = args.model {
            builder.add_model(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn model(&self) -> Option<DecisionModelMessage<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DecisionModelMessage>>(
                    ExplorationRequestMessage::VT_MODEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn solutions(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage>>,
            >>(ExplorationRequestMessage::VT_SOLUTIONS, None)
        }
    }
    #[inline]
    pub fn configuration(&self) -> Option<ExplorationConfiguration<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<ExplorationConfiguration>>(
                    ExplorationRequestMessage::VT_CONFIGURATION,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for ExplorationRequestMessage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<DecisionModelMessage>>(
                "model",
                Self::VT_MODEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage>>,
            >>("solutions", Self::VT_SOLUTIONS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<ExplorationConfiguration>>(
                "configuration",
                Self::VT_CONFIGURATION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ExplorationRequestMessageArgs<'a> {
    pub model: Option<flatbuffers::WIPOffset<DecisionModelMessage<'a>>>,
    pub solutions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage<'a>>>,
        >,
    >,
    pub configuration: Option<flatbuffers::WIPOffset<ExplorationConfiguration<'a>>>,
}
impl<'a> Default for ExplorationRequestMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExplorationRequestMessageArgs {
            model: None,
            solutions: None,
            configuration: None,
        }
    }
}

pub struct ExplorationRequestMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationRequestMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_model(&mut self, model: flatbuffers::WIPOffset<DecisionModelMessage<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DecisionModelMessage>>(
                ExplorationRequestMessage::VT_MODEL,
                model,
            );
    }
    #[inline]
    pub fn add_solutions(
        &mut self,
        solutions: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExplorationRequestMessage::VT_SOLUTIONS,
            solutions,
        );
    }
    #[inline]
    pub fn add_configuration(
        &mut self,
        configuration: flatbuffers::WIPOffset<ExplorationConfiguration<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<ExplorationConfiguration>>(
                ExplorationRequestMessage::VT_CONFIGURATION,
                configuration,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExplorationRequestMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExplorationRequestMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationRequestMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExplorationRequestMessage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExplorationRequestMessage");
        ds.field("model", &self.model());
        ds.field("solutions", &self.solutions());
        ds.field("configuration", &self.configuration());
        ds.finish()
    }
}
pub enum ReverseIdentificationResultMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Analogous of a identification result message but for the reverse identification procedure.
pub struct ReverseIdentificationResultMessage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReverseIdentificationResultMessage<'a> {
    type Inner = ReverseIdentificationResultMessage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReverseIdentificationResultMessage<'a> {
    pub const VT_IDENTIFIED: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReverseIdentificationResultMessage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReverseIdentificationResultMessageArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReverseIdentificationResultMessage<'bldr>> {
        let mut builder = ReverseIdentificationResultMessageBuilder::new(_fbb);
        if let Some(x) = args.messages {
            builder.add_messages(x);
        }
        if let Some(x) = args.identified {
            builder.add_identified(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn identified(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesignModelMessage<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesignModelMessage>>,
            >>(ReverseIdentificationResultMessage::VT_IDENTIFIED, None)
        }
    }
    #[inline]
    pub fn messages(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReverseIdentificationResultMessage::VT_MESSAGES, None)
        }
    }
}

impl flatbuffers::Verifiable for ReverseIdentificationResultMessage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesignModelMessage>>,
            >>("identified", Self::VT_IDENTIFIED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("messages", Self::VT_MESSAGES, false)?
            .finish();
        Ok(())
    }
}
pub struct ReverseIdentificationResultMessageArgs<'a> {
    pub identified: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesignModelMessage<'a>>>,
        >,
    >,
    pub messages: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ReverseIdentificationResultMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReverseIdentificationResultMessageArgs {
            identified: None,
            messages: None,
        }
    }
}

pub struct ReverseIdentificationResultMessageBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReverseIdentificationResultMessageBuilder<'a, 'b> {
    #[inline]
    pub fn add_identified(
        &mut self,
        identified: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DesignModelMessage<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReverseIdentificationResultMessage::VT_IDENTIFIED,
            identified,
        );
    }
    #[inline]
    pub fn add_messages(
        &mut self,
        messages: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReverseIdentificationResultMessage::VT_MESSAGES,
            messages,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ReverseIdentificationResultMessageBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReverseIdentificationResultMessageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReverseIdentificationResultMessage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReverseIdentificationResultMessage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReverseIdentificationResultMessage");
        ds.field("identified", &self.identified());
        ds.field("messages", &self.messages());
        ds.finish()
    }
}
