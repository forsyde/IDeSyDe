# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from typing import Optional
np = import_numpy()

# A header to exchange fundamental data about a decision model between different models in different languages.
#
# This data record captures which elements of the target design models have been partially identified.
# It provides a `category` to distinguish what type of decision model this is, so that different languages
# can know which of their own data structures they should deserialize the decision model into.
#
# Check the following paper for more in-depth definitions:
#
# R. Jordão, I. Sander and M. Becker, "Formulation of Design Space Exploration Problems by
# Composable Design Space Identification," 2021 Design, Automation & Test in Europe Conference &
# Exhibition (DATE), 2021, pp. 1204-1207, doi: 10.23919/DATE51398.2021.9474082.
class DecisionModelHeader(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DecisionModelHeader()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDecisionModelHeader(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # DecisionModelHeader
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # DecisionModelHeader
    def Part(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # DecisionModelHeader
    def PartLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # DecisionModelHeader
    def PartIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # DecisionModelHeader
    def Category(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def DecisionModelHeaderStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def DecisionModelHeaderAddPart(builder: flatbuffers.Builder, part: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(part), 0)

def DecisionModelHeaderStartPartVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def DecisionModelHeaderAddCategory(builder: flatbuffers.Builder, category: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(category), 0)

def DecisionModelHeaderEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



# A header to exchange fundamental data about a design model between different models in different languages.
#
# This data record captures which elements of the target design models taht can be partially identified.
# It provides a `category` to distinguish what type of design model this is, so that different languages
# can know which of their own data structures they should deserialize the design model into.
#
# Check the following paper for more in-depth definitions:
#
# R. Jordão, I. Sander and M. Becker, "Formulation of Design Space Exploration Problems by
# Composable Design Space Identification," 2021 Design, Automation & Test in Europe Conference &
# Exhibition (DATE), 2021, pp. 1204-1207, doi: 10.23919/DATE51398.2021.9474082.
class DesignModelHeader(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DesignModelHeader()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDesignModelHeader(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # DesignModelHeader
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # DesignModelHeader
    def Elements(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # DesignModelHeader
    def ElementsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # DesignModelHeader
    def ElementsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # DesignModelHeader
    def Category(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def DesignModelHeaderStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def DesignModelHeaderAddElements(builder: flatbuffers.Builder, elements: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(elements), 0)

def DesignModelHeaderStartElementsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def DesignModelHeaderAddCategory(builder: flatbuffers.Builder, category: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(category), 0)

def DesignModelHeaderEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



# The bidding information an explorer should return for a decision model.
#
# The most important entry in this record is the `can_explore` boolean.
# If true, the explorer who returned this bidding can indeed explorer the decision model queried,
# regardless of efficiency, possible goals etc.
#
# The `is_exact` entry signals that once the explorer finishes the exploration for queried decision model,
# the design space is _fully explored_. 
# This is the opposite of an heuristic explorer.
#
# The `competitiveness` entry is an optimization-related number useful for heuristic explorers (is_exact == false).
# It describes the discrepancy between the optimal solution returned by this explorer and the problem's actual optimal solution.
# In terms os Pareto optimality, this factor represents the worst difference between the resulting approximate Pareto set and
# the actual Pareto set. 
# There are two ways to acquire this parameter. The first is to have a mathematical proof of competitiveness,
# like https://en.wikipedia.org/wiki/Christofides_algorithm or https://en.wikipedia.org/wiki/List_scheduling.
# The second is to perform _a lot_ of empirical test and assert a rough distance between the explorer results and 
# the known actual Pareto set.
#
# The last entry, `target_objectives` simply contains all the possible target objectives that the explorer can minimize
# for during its exploration.
class ExplorationBid(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ExplorationBid()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsExplorationBid(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # ExplorationBid
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ExplorationBid
    def CanExplore(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # ExplorationBid
    def IsExact(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # ExplorationBid
    def Competitiveness(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 2.0

    # ExplorationBid
    def TargetObjectives(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # ExplorationBid
    def TargetObjectivesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExplorationBid
    def TargetObjectivesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def ExplorationBidStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def ExplorationBidAddCanExplore(builder: flatbuffers.Builder, canExplore: bool):
    builder.PrependBoolSlot(0, canExplore, 0)

def ExplorationBidAddIsExact(builder: flatbuffers.Builder, isExact: bool):
    builder.PrependBoolSlot(1, isExact, 0)

def ExplorationBidAddCompetitiveness(builder: flatbuffers.Builder, competitiveness: float):
    builder.PrependFloat32Slot(2, competitiveness, 2.0)

def ExplorationBidAddTargetObjectives(builder: flatbuffers.Builder, targetObjectives: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(targetObjectives), 0)

def ExplorationBidStartTargetObjectivesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ExplorationBidEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



# The exchangeable configuration between explorers.
#
# This configuration is a superset of the configurations possible for all explorers;
# that is, the explorers do not need to use all paramters present here.
#
# At a minimum, all explorers should honor:
#  - max_sols: the maximum amount of solutions returned.
#  - total_timeout: the maximum accumulated amount of time elapsed, in seconds.
#  - improvement_timeout: the maximum amount of time elapsed between improvements, in seconds.
#    An improvement can both be a new dominant Pareto solution a new optimal solution in case of just one objective.
#  - improvement_iterations: the maximum amount of improvement steps tried between improvements.
#    This is specific to each explorer, but give a general gist on the effort spent to improve the current solution set.
#    For example, genetic algorithm explorers can use the generation age as the improvement step; constriant programming explorers
#    can use the amount of backtracks as improvement steps.
#  - strict: whether only new dominating solution are returned.
#  - target_objectives: the names of the optimisation objectives that the explorer should make its goal.
class ExplorationConfiguration(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ExplorationConfiguration()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsExplorationConfiguration(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # ExplorationConfiguration
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ExplorationConfiguration
    def MaxSols(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ExplorationConfiguration
    def TotalTimeout(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ExplorationConfiguration
    def ImprovementTimeout(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ExplorationConfiguration
    def TimeResolution(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ExplorationConfiguration
    def MemoryResolution(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ExplorationConfiguration
    def ImprovementIterations(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ExplorationConfiguration
    def Strict(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # ExplorationConfiguration
    def TargetObjectives(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # ExplorationConfiguration
    def TargetObjectivesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExplorationConfiguration
    def TargetObjectivesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

def ExplorationConfigurationStart(builder: flatbuffers.Builder):
    builder.StartObject(8)

def ExplorationConfigurationAddMaxSols(builder: flatbuffers.Builder, maxSols: int):
    builder.PrependUint64Slot(0, maxSols, 0)

def ExplorationConfigurationAddTotalTimeout(builder: flatbuffers.Builder, totalTimeout: int):
    builder.PrependUint64Slot(1, totalTimeout, 0)

def ExplorationConfigurationAddImprovementTimeout(builder: flatbuffers.Builder, improvementTimeout: int):
    builder.PrependUint64Slot(2, improvementTimeout, 0)

def ExplorationConfigurationAddTimeResolution(builder: flatbuffers.Builder, timeResolution: int):
    builder.PrependUint64Slot(3, timeResolution, 0)

def ExplorationConfigurationAddMemoryResolution(builder: flatbuffers.Builder, memoryResolution: int):
    builder.PrependUint64Slot(4, memoryResolution, 0)

def ExplorationConfigurationAddImprovementIterations(builder: flatbuffers.Builder, improvementIterations: int):
    builder.PrependUint64Slot(5, improvementIterations, 0)

def ExplorationConfigurationAddStrict(builder: flatbuffers.Builder, strict: bool):
    builder.PrependBoolSlot(6, strict, 0)

def ExplorationConfigurationAddTargetObjectives(builder: flatbuffers.Builder, targetObjectives: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(targetObjectives), 0)

def ExplorationConfigurationStartTargetObjectivesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ExplorationConfigurationEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



