// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum DecisionModelHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A header to exchange fundamental data about a decision model between different models in different languages.
///
/// This data record captures which elements of the target design models have been partially identified.
/// It provides a `category` to distinguish what type of decision model this is, so that different languages
/// can know which of their own data structures they should deserialize the decision model into.
///
/// Check the following paper for more in-depth definitions:
///
/// R. Jordão, I. Sander and M. Becker, "Formulation of Design Space Exploration Problems by
/// Composable Design Space Identification," 2021 Design, Automation & Test in Europe Conference &
/// Exhibition (DATE), 2021, pp. 1204-1207, doi: 10.23919/DATE51398.2021.9474082.
pub struct DecisionModelHeader<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DecisionModelHeader<'a> {
    type Inner = DecisionModelHeader<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DecisionModelHeader<'a> {
    pub const VT_COVERED_ELEMENTS: flatbuffers::VOffsetT = 4;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DecisionModelHeader { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DecisionModelHeaderArgs<'args>,
    ) -> flatbuffers::WIPOffset<DecisionModelHeader<'bldr>> {
        let mut builder = DecisionModelHeaderBuilder::new(_fbb);
        if let Some(x) = args.category {
            builder.add_category(x);
        }
        if let Some(x) = args.covered_elements {
            builder.add_covered_elements(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn covered_elements(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(DecisionModelHeader::VT_COVERED_ELEMENTS, None)
        }
    }
    #[inline]
    pub fn category(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DecisionModelHeader::VT_CATEGORY, None)
        }
    }
}

impl flatbuffers::Verifiable for DecisionModelHeader<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("covered_elements", Self::VT_COVERED_ELEMENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "category",
                Self::VT_CATEGORY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DecisionModelHeaderArgs<'a> {
    pub covered_elements: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub category: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DecisionModelHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        DecisionModelHeaderArgs {
            covered_elements: None,
            category: None,
        }
    }
}

pub struct DecisionModelHeaderBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DecisionModelHeaderBuilder<'a, 'b> {
    #[inline]
    pub fn add_covered_elements(
        &mut self,
        covered_elements: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DecisionModelHeader::VT_COVERED_ELEMENTS,
            covered_elements,
        );
    }
    #[inline]
    pub fn add_category(&mut self, category: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DecisionModelHeader::VT_CATEGORY,
            category,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DecisionModelHeaderBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DecisionModelHeaderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DecisionModelHeader<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DecisionModelHeader<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DecisionModelHeader");
        ds.field("covered_elements", &self.covered_elements());
        ds.field("category", &self.category());
        ds.finish()
    }
}
pub enum DesignModelHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A header to exchange fundamental data about a design model between different models in different languages.
///
/// This data record captures which elements of the target design models taht can be partially identified.
/// It provides a `category` to distinguish what type of design model this is, so that different languages
/// can know which of their own data structures they should deserialize the design model into.
///
/// Check the following paper for more in-depth definitions:
///
/// R. Jordão, I. Sander and M. Becker, "Formulation of Design Space Exploration Problems by
/// Composable Design Space Identification," 2021 Design, Automation & Test in Europe Conference &
/// Exhibition (DATE), 2021, pp. 1204-1207, doi: 10.23919/DATE51398.2021.9474082.
pub struct DesignModelHeader<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesignModelHeader<'a> {
    type Inner = DesignModelHeader<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DesignModelHeader<'a> {
    pub const VT_ELEMENTS: flatbuffers::VOffsetT = 4;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DesignModelHeader { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DesignModelHeaderArgs<'args>,
    ) -> flatbuffers::WIPOffset<DesignModelHeader<'bldr>> {
        let mut builder = DesignModelHeaderBuilder::new(_fbb);
        if let Some(x) = args.category {
            builder.add_category(x);
        }
        if let Some(x) = args.elements {
            builder.add_elements(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn elements(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(DesignModelHeader::VT_ELEMENTS, None)
        }
    }
    #[inline]
    pub fn category(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DesignModelHeader::VT_CATEGORY, None)
        }
    }
}

impl flatbuffers::Verifiable for DesignModelHeader<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("elements", Self::VT_ELEMENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "category",
                Self::VT_CATEGORY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DesignModelHeaderArgs<'a> {
    pub elements: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub category: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DesignModelHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        DesignModelHeaderArgs {
            elements: None,
            category: None,
        }
    }
}

pub struct DesignModelHeaderBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesignModelHeaderBuilder<'a, 'b> {
    #[inline]
    pub fn add_elements(
        &mut self,
        elements: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DesignModelHeader::VT_ELEMENTS,
            elements,
        );
    }
    #[inline]
    pub fn add_category(&mut self, category: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DesignModelHeader::VT_CATEGORY,
            category,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DesignModelHeaderBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DesignModelHeaderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DesignModelHeader<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DesignModelHeader<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DesignModelHeader");
        ds.field("elements", &self.elements());
        ds.field("category", &self.category());
        ds.finish()
    }
}
pub enum ExplorationBidOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The bidding information an explorer should return for a decision model.
///
/// The most important entry in this record is the `can_explore` boolean.
/// If true, the explorer who returned this bidding can indeed explorer the decision model queried,
/// regardless of efficiency, possible goals etc.
///
/// The `is_exact` entry signals that once the explorer finishes the exploration for queried decision model,
/// the design space is _fully explored_.
/// This is the opposite of an heuristic explorer.
///
/// The `competitiveness` entry is an optimization-related number useful for heuristic explorers (is_exact == false).
/// It describes the discrepancy between the optimal solution returned by this explorer and the problem's actual optimal solution.
/// In terms os Pareto optimality, this factor represents the worst difference between the resulting approximate Pareto set and
/// the actual Pareto set.
/// There are two ways to acquire this parameter. The first is to have a mathematical proof of competitiveness,
/// like https://en.wikipedia.org/wiki/Christofides_algorithm or https://en.wikipedia.org/wiki/List_scheduling.
/// The second is to perform _a lot_ of empirical test and assert a rough distance between the explorer results and
/// the known actual Pareto set.
///
/// The last entry, `target_objectives` simply contains all the possible target objectives that the explorer can minimize
/// for during its exploration.
pub struct ExplorationBid<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationBid<'a> {
    type Inner = ExplorationBid<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ExplorationBid<'a> {
    pub const VT_CAN_EXPLORE: flatbuffers::VOffsetT = 4;
    pub const VT_IS_EXACT: flatbuffers::VOffsetT = 6;
    pub const VT_COMPETITIVENESS: flatbuffers::VOffsetT = 8;
    pub const VT_TARGET_OBJECTIVES: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExplorationBid { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExplorationBidArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExplorationBid<'bldr>> {
        let mut builder = ExplorationBidBuilder::new(_fbb);
        if let Some(x) = args.target_objectives {
            builder.add_target_objectives(x);
        }
        builder.add_competitiveness(args.competitiveness);
        builder.add_is_exact(args.is_exact);
        builder.add_can_explore(args.can_explore);
        builder.finish()
    }

    #[inline]
    pub fn can_explore(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ExplorationBid::VT_CAN_EXPLORE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn is_exact(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ExplorationBid::VT_IS_EXACT, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn competitiveness(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(ExplorationBid::VT_COMPETITIVENESS, Some(2.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn target_objectives(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ExplorationBid::VT_TARGET_OBJECTIVES, None)
        }
    }
}

impl flatbuffers::Verifiable for ExplorationBid<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("can_explore", Self::VT_CAN_EXPLORE, false)?
            .visit_field::<bool>("is_exact", Self::VT_IS_EXACT, false)?
            .visit_field::<f32>("competitiveness", Self::VT_COMPETITIVENESS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("target_objectives", Self::VT_TARGET_OBJECTIVES, false)?
            .finish();
        Ok(())
    }
}
pub struct ExplorationBidArgs<'a> {
    pub can_explore: bool,
    pub is_exact: bool,
    pub competitiveness: f32,
    pub target_objectives: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ExplorationBidArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExplorationBidArgs {
            can_explore: false,
            is_exact: false,
            competitiveness: 2.0,
            target_objectives: None,
        }
    }
}

pub struct ExplorationBidBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationBidBuilder<'a, 'b> {
    #[inline]
    pub fn add_can_explore(&mut self, can_explore: bool) {
        self.fbb_
            .push_slot::<bool>(ExplorationBid::VT_CAN_EXPLORE, can_explore, false);
    }
    #[inline]
    pub fn add_is_exact(&mut self, is_exact: bool) {
        self.fbb_
            .push_slot::<bool>(ExplorationBid::VT_IS_EXACT, is_exact, false);
    }
    #[inline]
    pub fn add_competitiveness(&mut self, competitiveness: f32) {
        self.fbb_
            .push_slot::<f32>(ExplorationBid::VT_COMPETITIVENESS, competitiveness, 2.0);
    }
    #[inline]
    pub fn add_target_objectives(
        &mut self,
        target_objectives: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExplorationBid::VT_TARGET_OBJECTIVES,
            target_objectives,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExplorationBidBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExplorationBidBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationBid<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExplorationBid<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExplorationBid");
        ds.field("can_explore", &self.can_explore());
        ds.field("is_exact", &self.is_exact());
        ds.field("competitiveness", &self.competitiveness());
        ds.field("target_objectives", &self.target_objectives());
        ds.finish()
    }
}
pub enum ExplorationConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The exchangeable configuration between explorers.
///
/// This configuration is a superset of the configurations possible for all explorers;
/// that is, the explorers do not need to use all paramters present here.
///
/// At a minimum, all explorers should honor:
///  - max_sols: the maximum amount of solutions returned.
///  - total_timeout: the maximum accumulated amount of time elapsed, in seconds.
///  - improvement_timeout: the maximum amount of time elapsed between improvements, in seconds.
///    An improvement can both be a new dominant Pareto solution a new optimal solution in case of just one objective.
///  - improvement_iterations: the maximum amount of improvement steps tried between improvements.
///    This is specific to each explorer, but give a general gist on the effort spent to improve the current solution set.
///    For example, genetic algorithm explorers can use the generation age as the improvement step; constriant programming explorers
///    can use the amount of backtracks as improvement steps.
///  - strict: whether only new dominating solution are returned.
///  - target_objectives: the names of the optimisation objectives that the explorer should make its goal.
pub struct ExplorationConfiguration<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationConfiguration<'a> {
    type Inner = ExplorationConfiguration<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ExplorationConfiguration<'a> {
    pub const VT_MAX_SOLS: flatbuffers::VOffsetT = 4;
    pub const VT_TOTAL_TIMEOUT: flatbuffers::VOffsetT = 6;
    pub const VT_IMPROVEMENT_TIMEOUT: flatbuffers::VOffsetT = 8;
    pub const VT_TIME_RESOLUTION: flatbuffers::VOffsetT = 10;
    pub const VT_MEMORY_RESOLUTION: flatbuffers::VOffsetT = 12;
    pub const VT_IMPROVEMENT_ITERATIONS: flatbuffers::VOffsetT = 14;
    pub const VT_STRICT: flatbuffers::VOffsetT = 16;
    pub const VT_TARGET_OBJECTIVES: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExplorationConfiguration { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExplorationConfigurationArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExplorationConfiguration<'bldr>> {
        let mut builder = ExplorationConfigurationBuilder::new(_fbb);
        builder.add_improvement_iterations(args.improvement_iterations);
        builder.add_memory_resolution(args.memory_resolution);
        builder.add_time_resolution(args.time_resolution);
        builder.add_improvement_timeout(args.improvement_timeout);
        builder.add_total_timeout(args.total_timeout);
        builder.add_max_sols(args.max_sols);
        if let Some(x) = args.target_objectives {
            builder.add_target_objectives(x);
        }
        builder.add_strict(args.strict);
        builder.finish()
    }

    #[inline]
    pub fn max_sols(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(ExplorationConfiguration::VT_MAX_SOLS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn total_timeout(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(ExplorationConfiguration::VT_TOTAL_TIMEOUT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn improvement_timeout(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(ExplorationConfiguration::VT_IMPROVEMENT_TIMEOUT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn time_resolution(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(ExplorationConfiguration::VT_TIME_RESOLUTION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn memory_resolution(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(ExplorationConfiguration::VT_MEMORY_RESOLUTION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn improvement_iterations(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(ExplorationConfiguration::VT_IMPROVEMENT_ITERATIONS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn strict(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ExplorationConfiguration::VT_STRICT, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn target_objectives(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ExplorationConfiguration::VT_TARGET_OBJECTIVES, None)
        }
    }
}

impl flatbuffers::Verifiable for ExplorationConfiguration<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("max_sols", Self::VT_MAX_SOLS, false)?
            .visit_field::<u64>("total_timeout", Self::VT_TOTAL_TIMEOUT, false)?
            .visit_field::<u64>("improvement_timeout", Self::VT_IMPROVEMENT_TIMEOUT, false)?
            .visit_field::<u64>("time_resolution", Self::VT_TIME_RESOLUTION, false)?
            .visit_field::<u64>("memory_resolution", Self::VT_MEMORY_RESOLUTION, false)?
            .visit_field::<u64>(
                "improvement_iterations",
                Self::VT_IMPROVEMENT_ITERATIONS,
                false,
            )?
            .visit_field::<bool>("strict", Self::VT_STRICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("target_objectives", Self::VT_TARGET_OBJECTIVES, false)?
            .finish();
        Ok(())
    }
}
pub struct ExplorationConfigurationArgs<'a> {
    pub max_sols: u64,
    pub total_timeout: u64,
    pub improvement_timeout: u64,
    pub time_resolution: u64,
    pub memory_resolution: u64,
    pub improvement_iterations: u64,
    pub strict: bool,
    pub target_objectives: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ExplorationConfigurationArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExplorationConfigurationArgs {
            max_sols: 0,
            total_timeout: 0,
            improvement_timeout: 0,
            time_resolution: 0,
            memory_resolution: 0,
            improvement_iterations: 0,
            strict: false,
            target_objectives: None,
        }
    }
}

pub struct ExplorationConfigurationBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationConfigurationBuilder<'a, 'b> {
    #[inline]
    pub fn add_max_sols(&mut self, max_sols: u64) {
        self.fbb_
            .push_slot::<u64>(ExplorationConfiguration::VT_MAX_SOLS, max_sols, 0);
    }
    #[inline]
    pub fn add_total_timeout(&mut self, total_timeout: u64) {
        self.fbb_
            .push_slot::<u64>(ExplorationConfiguration::VT_TOTAL_TIMEOUT, total_timeout, 0);
    }
    #[inline]
    pub fn add_improvement_timeout(&mut self, improvement_timeout: u64) {
        self.fbb_.push_slot::<u64>(
            ExplorationConfiguration::VT_IMPROVEMENT_TIMEOUT,
            improvement_timeout,
            0,
        );
    }
    #[inline]
    pub fn add_time_resolution(&mut self, time_resolution: u64) {
        self.fbb_.push_slot::<u64>(
            ExplorationConfiguration::VT_TIME_RESOLUTION,
            time_resolution,
            0,
        );
    }
    #[inline]
    pub fn add_memory_resolution(&mut self, memory_resolution: u64) {
        self.fbb_.push_slot::<u64>(
            ExplorationConfiguration::VT_MEMORY_RESOLUTION,
            memory_resolution,
            0,
        );
    }
    #[inline]
    pub fn add_improvement_iterations(&mut self, improvement_iterations: u64) {
        self.fbb_.push_slot::<u64>(
            ExplorationConfiguration::VT_IMPROVEMENT_ITERATIONS,
            improvement_iterations,
            0,
        );
    }
    #[inline]
    pub fn add_strict(&mut self, strict: bool) {
        self.fbb_
            .push_slot::<bool>(ExplorationConfiguration::VT_STRICT, strict, false);
    }
    #[inline]
    pub fn add_target_objectives(
        &mut self,
        target_objectives: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExplorationConfiguration::VT_TARGET_OBJECTIVES,
            target_objectives,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExplorationConfigurationBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExplorationConfigurationBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationConfiguration<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExplorationConfiguration<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExplorationConfiguration");
        ds.field("max_sols", &self.max_sols());
        ds.field("total_timeout", &self.total_timeout());
        ds.field("improvement_timeout", &self.improvement_timeout());
        ds.field("time_resolution", &self.time_resolution());
        ds.field("memory_resolution", &self.memory_resolution());
        ds.field("improvement_iterations", &self.improvement_iterations());
        ds.field("strict", &self.strict());
        ds.field("target_objectives", &self.target_objectives());
        ds.finish()
    }
}
