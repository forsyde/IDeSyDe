// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BODY_ENCODING: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BODY_ENCODING: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BODY_ENCODING: [BodyEncoding; 4] = [
  BodyEncoding::FlatBuffer,
  BodyEncoding::CBOR,
  BodyEncoding::MsgPack,
  BodyEncoding::JSON_UTF8,
];

/// A decision model message must be serialzied to be passed around between modules.
/// This enumeration dictates what type of encoding is used for the bytes present
/// insidea decision model message.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BodyEncoding(pub i8);
#[allow(non_upper_case_globals)]
impl BodyEncoding {
  pub const FlatBuffer: Self = Self(0);
  pub const CBOR: Self = Self(1);
  pub const MsgPack: Self = Self(2);
  pub const JSON_UTF8: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FlatBuffer,
    Self::CBOR,
    Self::MsgPack,
    Self::JSON_UTF8,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FlatBuffer => Some("FlatBuffer"),
      Self::CBOR => Some("CBOR"),
      Self::MsgPack => Some("MsgPack"),
      Self::JSON_UTF8 => Some("JSON_UTF8"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BodyEncoding {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BodyEncoding {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BodyEncoding {
    type Output = BodyEncoding;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BodyEncoding {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BodyEncoding {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BodyEncoding {}
pub enum DecisionModelHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A header to exchange fundamental data about a decision model between different models in different languages.
///
/// This data record captures which elements of the target design models have been partially identified.
/// It provides a `category` to distinguish what type of decision model this is, so that different languages
/// can know which of their own data structures they should deserialize the decision model into.
///
/// Check the following paper for more in-depth definitions:
///
/// R. Jordão, I. Sander and M. Becker, "Formulation of Design Space Exploration Problems by
/// Composable Design Space Identification," 2021 Design, Automation & Test in Europe Conference &
/// Exhibition (DATE), 2021, pp. 1204-1207, doi: 10.23919/DATE51398.2021.9474082.
pub struct DecisionModelHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DecisionModelHeader<'a> {
  type Inner = DecisionModelHeader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DecisionModelHeader<'a> {
  pub const VT_COVERED_ELEMENTS: flatbuffers::VOffsetT = 4;
  pub const VT_CATEGORY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DecisionModelHeader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DecisionModelHeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<DecisionModelHeader<'bldr>> {
    let mut builder = DecisionModelHeaderBuilder::new(_fbb);
    if let Some(x) = args.category { builder.add_category(x); }
    if let Some(x) = args.covered_elements { builder.add_covered_elements(x); }
    builder.finish()
  }


  #[inline]
  pub fn covered_elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DecisionModelHeader::VT_COVERED_ELEMENTS, None)}
  }
  #[inline]
  pub fn category(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DecisionModelHeader::VT_CATEGORY, None)}
  }
}

impl flatbuffers::Verifiable for DecisionModelHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("covered_elements", Self::VT_COVERED_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("category", Self::VT_CATEGORY, false)?
     .finish();
    Ok(())
  }
}
pub struct DecisionModelHeaderArgs<'a> {
    pub covered_elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub category: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DecisionModelHeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    DecisionModelHeaderArgs {
      covered_elements: None,
      category: None,
    }
  }
}

pub struct DecisionModelHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DecisionModelHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_covered_elements(&mut self, covered_elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DecisionModelHeader::VT_COVERED_ELEMENTS, covered_elements);
  }
  #[inline]
  pub fn add_category(&mut self, category: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DecisionModelHeader::VT_CATEGORY, category);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DecisionModelHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DecisionModelHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DecisionModelHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DecisionModelHeader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DecisionModelHeader");
      ds.field("covered_elements", &self.covered_elements());
      ds.field("category", &self.category());
      ds.finish()
  }
}
pub enum DesignModelHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A header to exchange fundamental data about a design model between different models in different languages.
///
/// This data record captures which elements of the target design models taht can be partially identified.
/// It provides a `category` to distinguish what type of design model this is, so that different languages
/// can know which of their own data structures they should deserialize the design model into.
///
/// Check the following paper for more in-depth definitions:
///
/// R. Jordão, I. Sander and M. Becker, "Formulation of Design Space Exploration Problems by
/// Composable Design Space Identification," 2021 Design, Automation & Test in Europe Conference &
/// Exhibition (DATE), 2021, pp. 1204-1207, doi: 10.23919/DATE51398.2021.9474082.
pub struct DesignModelHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesignModelHeader<'a> {
  type Inner = DesignModelHeader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DesignModelHeader<'a> {
  pub const VT_ELEMENTS: flatbuffers::VOffsetT = 4;
  pub const VT_CATEGORY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DesignModelHeader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DesignModelHeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<DesignModelHeader<'bldr>> {
    let mut builder = DesignModelHeaderBuilder::new(_fbb);
    if let Some(x) = args.category { builder.add_category(x); }
    if let Some(x) = args.elements { builder.add_elements(x); }
    builder.finish()
  }


  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DesignModelHeader::VT_ELEMENTS, None)}
  }
  #[inline]
  pub fn category(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DesignModelHeader::VT_CATEGORY, None)}
  }
}

impl flatbuffers::Verifiable for DesignModelHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("elements", Self::VT_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("category", Self::VT_CATEGORY, false)?
     .finish();
    Ok(())
  }
}
pub struct DesignModelHeaderArgs<'a> {
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub category: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DesignModelHeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    DesignModelHeaderArgs {
      elements: None,
      category: None,
    }
  }
}

pub struct DesignModelHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesignModelHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DesignModelHeader::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn add_category(&mut self, category: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DesignModelHeader::VT_CATEGORY, category);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DesignModelHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DesignModelHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DesignModelHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DesignModelHeader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DesignModelHeader");
      ds.field("elements", &self.elements());
      ds.field("category", &self.category());
      ds.finish()
  }
}
pub enum ExplorationBidOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The bidding information an explorer should return for a decision model.
///
/// The most important entry in this record is the `can_explore` boolean.
/// If true, the explorer who returned this bidding can indeed explorer the decision model queried,
/// regardless of efficiency, possible goals etc.
///
/// The `is_exact` entry signals that once the explorer finishes the exploration for queried decision model,
/// the design space is _fully explored_. 
/// This is the opposite of an heuristic explorer.
///
/// The `competitiveness` entry is an optimization-related number useful for heuristic explorers (is_exact == false).
/// It describes the discrepancy between the optimal solution returned by this explorer and the problem's actual optimal solution.
/// In terms os Pareto optimality, this factor represents the worst difference between the resulting approximate Pareto set and
/// the actual Pareto set. 
/// There are two ways to acquire this parameter. The first is to have a mathematical proof of competitiveness,
/// like https://en.wikipedia.org/wiki/Christofides_algorithm or https://en.wikipedia.org/wiki/List_scheduling.
/// The second is to perform _a lot_ of empirical test and assert a rough distance between the explorer results and 
/// the known actual Pareto set.
///
/// The last entry, `target_objectives` simply contains all the possible target objectives that the explorer can minimize
/// for during its exploration.
pub struct ExplorationBid<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationBid<'a> {
  type Inner = ExplorationBid<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExplorationBid<'a> {
  pub const VT_CAN_EXPLORE: flatbuffers::VOffsetT = 4;
  pub const VT_IS_EXACT: flatbuffers::VOffsetT = 6;
  pub const VT_COMPETITIVENESS: flatbuffers::VOffsetT = 8;
  pub const VT_TARGET_OBJECTIVES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExplorationBid { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExplorationBidArgs<'args>
  ) -> flatbuffers::WIPOffset<ExplorationBid<'bldr>> {
    let mut builder = ExplorationBidBuilder::new(_fbb);
    if let Some(x) = args.target_objectives { builder.add_target_objectives(x); }
    builder.add_competitiveness(args.competitiveness);
    builder.add_is_exact(args.is_exact);
    builder.add_can_explore(args.can_explore);
    builder.finish()
  }


  #[inline]
  pub fn can_explore(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ExplorationBid::VT_CAN_EXPLORE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_exact(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ExplorationBid::VT_IS_EXACT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn competitiveness(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ExplorationBid::VT_COMPETITIVENESS, Some(2.0)).unwrap()}
  }
  #[inline]
  pub fn target_objectives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ExplorationBid::VT_TARGET_OBJECTIVES, None)}
  }
}

impl flatbuffers::Verifiable for ExplorationBid<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("can_explore", Self::VT_CAN_EXPLORE, false)?
     .visit_field::<bool>("is_exact", Self::VT_IS_EXACT, false)?
     .visit_field::<f32>("competitiveness", Self::VT_COMPETITIVENESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("target_objectives", Self::VT_TARGET_OBJECTIVES, false)?
     .finish();
    Ok(())
  }
}
pub struct ExplorationBidArgs<'a> {
    pub can_explore: bool,
    pub is_exact: bool,
    pub competitiveness: f32,
    pub target_objectives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ExplorationBidArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExplorationBidArgs {
      can_explore: false,
      is_exact: false,
      competitiveness: 2.0,
      target_objectives: None,
    }
  }
}

pub struct ExplorationBidBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationBidBuilder<'a, 'b> {
  #[inline]
  pub fn add_can_explore(&mut self, can_explore: bool) {
    self.fbb_.push_slot::<bool>(ExplorationBid::VT_CAN_EXPLORE, can_explore, false);
  }
  #[inline]
  pub fn add_is_exact(&mut self, is_exact: bool) {
    self.fbb_.push_slot::<bool>(ExplorationBid::VT_IS_EXACT, is_exact, false);
  }
  #[inline]
  pub fn add_competitiveness(&mut self, competitiveness: f32) {
    self.fbb_.push_slot::<f32>(ExplorationBid::VT_COMPETITIVENESS, competitiveness, 2.0);
  }
  #[inline]
  pub fn add_target_objectives(&mut self, target_objectives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExplorationBid::VT_TARGET_OBJECTIVES, target_objectives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExplorationBidBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExplorationBidBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationBid<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExplorationBid<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExplorationBid");
      ds.field("can_explore", &self.can_explore());
      ds.field("is_exact", &self.is_exact());
      ds.field("competitiveness", &self.competitiveness());
      ds.field("target_objectives", &self.target_objectives());
      ds.finish()
  }
}
pub enum ExplorationConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The exchangeable configuration between explorers.
///
/// This configuration is a superset of the configurations possible for all explorers;
/// that is, the explorers do not need to use all paramters present here.
///
/// At a minimum, all explorers should honor:
///  - max_sols: the maximum amount of solutions returned.
///  - total_timeout: the maximum accumulated amount of time elapsed, in seconds.
///  - improvement_timeout: the maximum amount of time elapsed between improvements, in seconds.
///    An improvement can both be a new dominant Pareto solution a new optimal solution in case of just one objective.
///  - improvement_iterations: the maximum amount of improvement steps tried between improvements.
///    This is specific to each explorer, but give a general gist on the effort spent to improve the current solution set.
///    For example, genetic algorithm explorers can use the generation age as the improvement step; constriant programming explorers
///    can use the amount of backtracks as improvement steps.
///  - strict: whether only new dominating solution are returned.
///  - target_objectives: the names of the optimisation objectives that the explorer should make its goal.
pub struct ExplorationConfiguration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationConfiguration<'a> {
  type Inner = ExplorationConfiguration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExplorationConfiguration<'a> {
  pub const VT_MAX_SOLS: flatbuffers::VOffsetT = 4;
  pub const VT_TOTAL_TIMEOUT: flatbuffers::VOffsetT = 6;
  pub const VT_IMPROVEMENT_TIMEOUT: flatbuffers::VOffsetT = 8;
  pub const VT_TIME_RESOLUTION: flatbuffers::VOffsetT = 10;
  pub const VT_MEMORY_RESOLUTION: flatbuffers::VOffsetT = 12;
  pub const VT_IMPROVEMENT_ITERATIONS: flatbuffers::VOffsetT = 14;
  pub const VT_STRICT: flatbuffers::VOffsetT = 16;
  pub const VT_TARGET_OBJECTIVES: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExplorationConfiguration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExplorationConfigurationArgs<'args>
  ) -> flatbuffers::WIPOffset<ExplorationConfiguration<'bldr>> {
    let mut builder = ExplorationConfigurationBuilder::new(_fbb);
    builder.add_improvement_iterations(args.improvement_iterations);
    builder.add_memory_resolution(args.memory_resolution);
    builder.add_time_resolution(args.time_resolution);
    builder.add_improvement_timeout(args.improvement_timeout);
    builder.add_total_timeout(args.total_timeout);
    builder.add_max_sols(args.max_sols);
    if let Some(x) = args.target_objectives { builder.add_target_objectives(x); }
    builder.add_strict(args.strict);
    builder.finish()
  }


  #[inline]
  pub fn max_sols(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExplorationConfiguration::VT_MAX_SOLS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn total_timeout(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExplorationConfiguration::VT_TOTAL_TIMEOUT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn improvement_timeout(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExplorationConfiguration::VT_IMPROVEMENT_TIMEOUT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn time_resolution(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExplorationConfiguration::VT_TIME_RESOLUTION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn memory_resolution(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExplorationConfiguration::VT_MEMORY_RESOLUTION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn improvement_iterations(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ExplorationConfiguration::VT_IMPROVEMENT_ITERATIONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn strict(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ExplorationConfiguration::VT_STRICT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn target_objectives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ExplorationConfiguration::VT_TARGET_OBJECTIVES, None)}
  }
}

impl flatbuffers::Verifiable for ExplorationConfiguration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("max_sols", Self::VT_MAX_SOLS, false)?
     .visit_field::<u64>("total_timeout", Self::VT_TOTAL_TIMEOUT, false)?
     .visit_field::<u64>("improvement_timeout", Self::VT_IMPROVEMENT_TIMEOUT, false)?
     .visit_field::<u64>("time_resolution", Self::VT_TIME_RESOLUTION, false)?
     .visit_field::<u64>("memory_resolution", Self::VT_MEMORY_RESOLUTION, false)?
     .visit_field::<u64>("improvement_iterations", Self::VT_IMPROVEMENT_ITERATIONS, false)?
     .visit_field::<bool>("strict", Self::VT_STRICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("target_objectives", Self::VT_TARGET_OBJECTIVES, false)?
     .finish();
    Ok(())
  }
}
pub struct ExplorationConfigurationArgs<'a> {
    pub max_sols: u64,
    pub total_timeout: u64,
    pub improvement_timeout: u64,
    pub time_resolution: u64,
    pub memory_resolution: u64,
    pub improvement_iterations: u64,
    pub strict: bool,
    pub target_objectives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ExplorationConfigurationArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExplorationConfigurationArgs {
      max_sols: 0,
      total_timeout: 0,
      improvement_timeout: 0,
      time_resolution: 0,
      memory_resolution: 0,
      improvement_iterations: 0,
      strict: false,
      target_objectives: None,
    }
  }
}

pub struct ExplorationConfigurationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationConfigurationBuilder<'a, 'b> {
  #[inline]
  pub fn add_max_sols(&mut self, max_sols: u64) {
    self.fbb_.push_slot::<u64>(ExplorationConfiguration::VT_MAX_SOLS, max_sols, 0);
  }
  #[inline]
  pub fn add_total_timeout(&mut self, total_timeout: u64) {
    self.fbb_.push_slot::<u64>(ExplorationConfiguration::VT_TOTAL_TIMEOUT, total_timeout, 0);
  }
  #[inline]
  pub fn add_improvement_timeout(&mut self, improvement_timeout: u64) {
    self.fbb_.push_slot::<u64>(ExplorationConfiguration::VT_IMPROVEMENT_TIMEOUT, improvement_timeout, 0);
  }
  #[inline]
  pub fn add_time_resolution(&mut self, time_resolution: u64) {
    self.fbb_.push_slot::<u64>(ExplorationConfiguration::VT_TIME_RESOLUTION, time_resolution, 0);
  }
  #[inline]
  pub fn add_memory_resolution(&mut self, memory_resolution: u64) {
    self.fbb_.push_slot::<u64>(ExplorationConfiguration::VT_MEMORY_RESOLUTION, memory_resolution, 0);
  }
  #[inline]
  pub fn add_improvement_iterations(&mut self, improvement_iterations: u64) {
    self.fbb_.push_slot::<u64>(ExplorationConfiguration::VT_IMPROVEMENT_ITERATIONS, improvement_iterations, 0);
  }
  #[inline]
  pub fn add_strict(&mut self, strict: bool) {
    self.fbb_.push_slot::<bool>(ExplorationConfiguration::VT_STRICT, strict, false);
  }
  #[inline]
  pub fn add_target_objectives(&mut self, target_objectives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExplorationConfiguration::VT_TARGET_OBJECTIVES, target_objectives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExplorationConfigurationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExplorationConfigurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationConfiguration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExplorationConfiguration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExplorationConfiguration");
      ds.field("max_sols", &self.max_sols());
      ds.field("total_timeout", &self.total_timeout());
      ds.field("improvement_timeout", &self.improvement_timeout());
      ds.field("time_resolution", &self.time_resolution());
      ds.field("memory_resolution", &self.memory_resolution());
      ds.field("improvement_iterations", &self.improvement_iterations());
      ds.field("strict", &self.strict());
      ds.field("target_objectives", &self.target_objectives());
      ds.finish()
  }
}
pub enum DecisionModelMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A decision model is a collection of parameters and associated functions that potentially define design spaces,
///  e.g. a decision model for tiled based platforms.
///
/// This message enables the decision models to be exchaged between modules and programs in an opaque form.
pub struct DecisionModelMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DecisionModelMessage<'a> {
  type Inner = DecisionModelMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DecisionModelMessage<'a> {
  pub const VT_HEADER: flatbuffers::VOffsetT = 4;
  pub const VT_BODY_ENCODING: flatbuffers::VOffsetT = 6;
  pub const VT_BODY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DecisionModelMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DecisionModelMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<DecisionModelMessage<'bldr>> {
    let mut builder = DecisionModelMessageBuilder::new(_fbb);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.header { builder.add_header(x); }
    builder.add_body_encoding(args.body_encoding);
    builder.finish()
  }


  #[inline]
  pub fn header(&self) -> Option<DecisionModelHeader<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DecisionModelHeader>>(DecisionModelMessage::VT_HEADER, None)}
  }
  #[inline]
  pub fn body_encoding(&self) -> BodyEncoding {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BodyEncoding>(DecisionModelMessage::VT_BODY_ENCODING, Some(BodyEncoding::FlatBuffer)).unwrap()}
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Vector<'a, i8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(DecisionModelMessage::VT_BODY, None)}
  }
}

impl flatbuffers::Verifiable for DecisionModelMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DecisionModelHeader>>("header", Self::VT_HEADER, false)?
     .visit_field::<BodyEncoding>("body_encoding", Self::VT_BODY_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>("body", Self::VT_BODY, false)?
     .finish();
    Ok(())
  }
}
pub struct DecisionModelMessageArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<DecisionModelHeader<'a>>>,
    pub body_encoding: BodyEncoding,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for DecisionModelMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    DecisionModelMessageArgs {
      header: None,
      body_encoding: BodyEncoding::FlatBuffer,
      body: None,
    }
  }
}

pub struct DecisionModelMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DecisionModelMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<DecisionModelHeader<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DecisionModelHeader>>(DecisionModelMessage::VT_HEADER, header);
  }
  #[inline]
  pub fn add_body_encoding(&mut self, body_encoding: BodyEncoding) {
    self.fbb_.push_slot::<BodyEncoding>(DecisionModelMessage::VT_BODY_ENCODING, body_encoding, BodyEncoding::FlatBuffer);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DecisionModelMessage::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DecisionModelMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DecisionModelMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DecisionModelMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DecisionModelMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DecisionModelMessage");
      ds.field("header", &self.header());
      ds.field("body_encoding", &self.body_encoding());
      ds.field("body", &self.body());
      ds.finish()
  }
}
pub enum DesignModelMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A design model is a model used by MDE frameworks and tools, e.g. Simulink and ForSyDe IO.
/// Like [DesignModel], this trait requires a header so that the identification procedure can work
/// correctly and terminate. The header gives an idea to the framework on how much can be "identified"
/// from the input MDE model, i.e. the [DesignModel].
///
/// This message enables the design models to be exchaged between modules and programs in an opaque form.
pub struct DesignModelMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesignModelMessage<'a> {
  type Inner = DesignModelMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DesignModelMessage<'a> {
  pub const VT_HEADER: flatbuffers::VOffsetT = 4;
  pub const VT_FORMAT: flatbuffers::VOffsetT = 6;
  pub const VT_BODY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DesignModelMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DesignModelMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<DesignModelMessage<'bldr>> {
    let mut builder = DesignModelMessageBuilder::new(_fbb);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.format { builder.add_format(x); }
    if let Some(x) = args.header { builder.add_header(x); }
    builder.finish()
  }


  #[inline]
  pub fn header(&self) -> Option<DesignModelHeader<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DesignModelHeader>>(DesignModelMessage::VT_HEADER, None)}
  }
  #[inline]
  pub fn format(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DesignModelMessage::VT_FORMAT, None)}
  }
  #[inline]
  pub fn body(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DesignModelMessage::VT_BODY, None)}
  }
}

impl flatbuffers::Verifiable for DesignModelMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DesignModelHeader>>("header", Self::VT_HEADER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("format", Self::VT_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
     .finish();
    Ok(())
  }
}
pub struct DesignModelMessageArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<DesignModelHeader<'a>>>,
    pub format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DesignModelMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    DesignModelMessageArgs {
      header: None,
      format: None,
      body: None,
    }
  }
}

pub struct DesignModelMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesignModelMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<DesignModelHeader<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DesignModelHeader>>(DesignModelMessage::VT_HEADER, header);
  }
  #[inline]
  pub fn add_format(&mut self, format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DesignModelMessage::VT_FORMAT, format);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DesignModelMessage::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DesignModelMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DesignModelMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DesignModelMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DesignModelMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DesignModelMessage");
      ds.field("header", &self.header());
      ds.field("format", &self.format());
      ds.field("body", &self.body());
      ds.finish()
  }
}
pub enum ExplorationSolutionMessageEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A simple struct to define a key-valye pair that is used inside the exploration solution message.
pub struct ExplorationSolutionMessageEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationSolutionMessageEntry<'a> {
  type Inner = ExplorationSolutionMessageEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExplorationSolutionMessageEntry<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExplorationSolutionMessageEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExplorationSolutionMessageEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<ExplorationSolutionMessageEntry<'bldr>> {
    let mut builder = ExplorationSolutionMessageEntryBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExplorationSolutionMessageEntry::VT_NAME, None)}
  }
  #[inline]
  pub fn value(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ExplorationSolutionMessageEntry::VT_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ExplorationSolutionMessageEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<f64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ExplorationSolutionMessageEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f64,
}
impl<'a> Default for ExplorationSolutionMessageEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExplorationSolutionMessageEntryArgs {
      name: None,
      value: 0.0,
    }
  }
}

pub struct ExplorationSolutionMessageEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationSolutionMessageEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExplorationSolutionMessageEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: f64) {
    self.fbb_.push_slot::<f64>(ExplorationSolutionMessageEntry::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExplorationSolutionMessageEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExplorationSolutionMessageEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationSolutionMessageEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExplorationSolutionMessageEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExplorationSolutionMessageEntry");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ExplorationSolutionMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A exploration message contains the decision model with its enhanced parameters as well as the objectives.
///
/// Both the model and its objectives are given back as a message so that explorers can quickly use the objectives
/// directly instead of rebuilding the model and recomputing the objectives from the rebuild model.
/// On a more advanced note, taking the objectives directly also enables the explorer to focus only on a few
/// design goals and/or share objectives between decision models that are "alike" but not of the same category.
pub struct ExplorationSolutionMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationSolutionMessage<'a> {
  type Inner = ExplorationSolutionMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExplorationSolutionMessage<'a> {
  pub const VT_SOLVED: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECTIVES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExplorationSolutionMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExplorationSolutionMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<ExplorationSolutionMessage<'bldr>> {
    let mut builder = ExplorationSolutionMessageBuilder::new(_fbb);
    if let Some(x) = args.objectives { builder.add_objectives(x); }
    if let Some(x) = args.solved { builder.add_solved(x); }
    builder.finish()
  }


  #[inline]
  pub fn solved(&self) -> Option<DecisionModelMessage<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DecisionModelMessage>>(ExplorationSolutionMessage::VT_SOLVED, None)}
  }
  #[inline]
  pub fn objectives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry>>>>(ExplorationSolutionMessage::VT_OBJECTIVES, None)}
  }
}

impl flatbuffers::Verifiable for ExplorationSolutionMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DecisionModelMessage>>("solved", Self::VT_SOLVED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry>>>>("objectives", Self::VT_OBJECTIVES, false)?
     .finish();
    Ok(())
  }
}
pub struct ExplorationSolutionMessageArgs<'a> {
    pub solved: Option<flatbuffers::WIPOffset<DecisionModelMessage<'a>>>,
    pub objectives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry<'a>>>>>,
}
impl<'a> Default for ExplorationSolutionMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExplorationSolutionMessageArgs {
      solved: None,
      objectives: None,
    }
  }
}

pub struct ExplorationSolutionMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationSolutionMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_solved(&mut self, solved: flatbuffers::WIPOffset<DecisionModelMessage<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DecisionModelMessage>>(ExplorationSolutionMessage::VT_SOLVED, solved);
  }
  #[inline]
  pub fn add_objectives(&mut self, objectives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ExplorationSolutionMessageEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExplorationSolutionMessage::VT_OBJECTIVES, objectives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExplorationSolutionMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExplorationSolutionMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationSolutionMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExplorationSolutionMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExplorationSolutionMessage");
      ds.field("solved", &self.solved());
      ds.field("objectives", &self.objectives());
      ds.finish()
  }
}
pub enum IdentificationResultMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The results of an identification step during the identification procedure.
///
/// The "messages" enable the modules to broadcast informative messages to the orchestrator,
/// who then can report to the user as it deems appropriate.
pub struct IdentificationResultMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentificationResultMessage<'a> {
  type Inner = IdentificationResultMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentificationResultMessage<'a> {
  pub const VT_IDENTIFIED: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentificationResultMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args IdentificationResultMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentificationResultMessage<'bldr>> {
    let mut builder = IdentificationResultMessageBuilder::new(_fbb);
    if let Some(x) = args.messages { builder.add_messages(x); }
    if let Some(x) = args.identified { builder.add_identified(x); }
    builder.finish()
  }


  #[inline]
  pub fn identified(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DecisionModelMessage<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DecisionModelMessage>>>>(IdentificationResultMessage::VT_IDENTIFIED, None)}
  }
  #[inline]
  pub fn messages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(IdentificationResultMessage::VT_MESSAGES, None)}
  }
}

impl flatbuffers::Verifiable for IdentificationResultMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DecisionModelMessage>>>>("identified", Self::VT_IDENTIFIED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("messages", Self::VT_MESSAGES, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentificationResultMessageArgs<'a> {
    pub identified: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DecisionModelMessage<'a>>>>>,
    pub messages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for IdentificationResultMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentificationResultMessageArgs {
      identified: None,
      messages: None,
    }
  }
}

pub struct IdentificationResultMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IdentificationResultMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_identified(&mut self, identified: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DecisionModelMessage<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IdentificationResultMessage::VT_IDENTIFIED, identified);
  }
  #[inline]
  pub fn add_messages(&mut self, messages: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IdentificationResultMessage::VT_MESSAGES, messages);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IdentificationResultMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IdentificationResultMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentificationResultMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentificationResultMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentificationResultMessage");
      ds.field("identified", &self.identified());
      ds.field("messages", &self.messages());
      ds.finish()
  }
}
pub enum ExplorationRequestMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A request for exploration.
///
/// All the extra parameters related to exploration are aggregated into the ExplorationConfiguration
/// object/
pub struct ExplorationRequestMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExplorationRequestMessage<'a> {
  type Inner = ExplorationRequestMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExplorationRequestMessage<'a> {
  pub const VT_MODEL: flatbuffers::VOffsetT = 4;
  pub const VT_SOLUTIONS: flatbuffers::VOffsetT = 6;
  pub const VT_CONFIGURATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExplorationRequestMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExplorationRequestMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<ExplorationRequestMessage<'bldr>> {
    let mut builder = ExplorationRequestMessageBuilder::new(_fbb);
    if let Some(x) = args.configuration { builder.add_configuration(x); }
    if let Some(x) = args.solutions { builder.add_solutions(x); }
    if let Some(x) = args.model { builder.add_model(x); }
    builder.finish()
  }


  #[inline]
  pub fn model(&self) -> Option<DecisionModelMessage<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DecisionModelMessage>>(ExplorationRequestMessage::VT_MODEL, None)}
  }
  #[inline]
  pub fn solutions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage>>>>(ExplorationRequestMessage::VT_SOLUTIONS, None)}
  }
  #[inline]
  pub fn configuration(&self) -> Option<ExplorationConfiguration<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ExplorationConfiguration>>(ExplorationRequestMessage::VT_CONFIGURATION, None)}
  }
}

impl flatbuffers::Verifiable for ExplorationRequestMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DecisionModelMessage>>("model", Self::VT_MODEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage>>>>("solutions", Self::VT_SOLUTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ExplorationConfiguration>>("configuration", Self::VT_CONFIGURATION, false)?
     .finish();
    Ok(())
  }
}
pub struct ExplorationRequestMessageArgs<'a> {
    pub model: Option<flatbuffers::WIPOffset<DecisionModelMessage<'a>>>,
    pub solutions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExplorationSolutionMessage<'a>>>>>,
    pub configuration: Option<flatbuffers::WIPOffset<ExplorationConfiguration<'a>>>,
}
impl<'a> Default for ExplorationRequestMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExplorationRequestMessageArgs {
      model: None,
      solutions: None,
      configuration: None,
    }
  }
}

pub struct ExplorationRequestMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExplorationRequestMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_model(&mut self, model: flatbuffers::WIPOffset<DecisionModelMessage<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DecisionModelMessage>>(ExplorationRequestMessage::VT_MODEL, model);
  }
  #[inline]
  pub fn add_solutions(&mut self, solutions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ExplorationSolutionMessage<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExplorationRequestMessage::VT_SOLUTIONS, solutions);
  }
  #[inline]
  pub fn add_configuration(&mut self, configuration: flatbuffers::WIPOffset<ExplorationConfiguration<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ExplorationConfiguration>>(ExplorationRequestMessage::VT_CONFIGURATION, configuration);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExplorationRequestMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExplorationRequestMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExplorationRequestMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExplorationRequestMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExplorationRequestMessage");
      ds.field("model", &self.model());
      ds.field("solutions", &self.solutions());
      ds.field("configuration", &self.configuration());
      ds.finish()
  }
}
pub enum ReverseIdentificationResultMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Analogous of a identification result message but for the reverse identification procedure.
pub struct ReverseIdentificationResultMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReverseIdentificationResultMessage<'a> {
  type Inner = ReverseIdentificationResultMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReverseIdentificationResultMessage<'a> {
  pub const VT_IDENTIFIED: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReverseIdentificationResultMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReverseIdentificationResultMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<ReverseIdentificationResultMessage<'bldr>> {
    let mut builder = ReverseIdentificationResultMessageBuilder::new(_fbb);
    if let Some(x) = args.messages { builder.add_messages(x); }
    if let Some(x) = args.identified { builder.add_identified(x); }
    builder.finish()
  }


  #[inline]
  pub fn identified(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesignModelMessage<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesignModelMessage>>>>(ReverseIdentificationResultMessage::VT_IDENTIFIED, None)}
  }
  #[inline]
  pub fn messages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ReverseIdentificationResultMessage::VT_MESSAGES, None)}
  }
}

impl flatbuffers::Verifiable for ReverseIdentificationResultMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesignModelMessage>>>>("identified", Self::VT_IDENTIFIED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("messages", Self::VT_MESSAGES, false)?
     .finish();
    Ok(())
  }
}
pub struct ReverseIdentificationResultMessageArgs<'a> {
    pub identified: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesignModelMessage<'a>>>>>,
    pub messages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ReverseIdentificationResultMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReverseIdentificationResultMessageArgs {
      identified: None,
      messages: None,
    }
  }
}

pub struct ReverseIdentificationResultMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReverseIdentificationResultMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_identified(&mut self, identified: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DesignModelMessage<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReverseIdentificationResultMessage::VT_IDENTIFIED, identified);
  }
  #[inline]
  pub fn add_messages(&mut self, messages: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReverseIdentificationResultMessage::VT_MESSAGES, messages);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReverseIdentificationResultMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReverseIdentificationResultMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReverseIdentificationResultMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReverseIdentificationResultMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReverseIdentificationResultMessage");
      ds.field("identified", &self.identified());
      ds.field("messages", &self.messages());
      ds.finish()
  }
}
