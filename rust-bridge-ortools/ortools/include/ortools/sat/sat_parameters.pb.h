// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/sat/sat_parameters.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_ortools_2fsat_2fsat_5fparameters_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ortools_2fsat_2fsat_5fparameters_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ortools_2fsat_2fsat_5fparameters_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ortools_2fsat_2fsat_5fparameters_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ortools_2fsat_2fsat_5fparameters_2eproto;
namespace operations_research {
namespace sat {
class SatParameters;
struct SatParametersDefaultTypeInternal;
extern SatParametersDefaultTypeInternal _SatParameters_default_instance_;
}  // namespace sat
}  // namespace operations_research
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace operations_research {
namespace sat {
enum SatParameters_VariableOrder : int {
  SatParameters_VariableOrder_IN_ORDER = 0,
  SatParameters_VariableOrder_IN_REVERSE_ORDER = 1,
  SatParameters_VariableOrder_IN_RANDOM_ORDER = 2,
};

bool SatParameters_VariableOrder_IsValid(int value);
extern const uint32_t SatParameters_VariableOrder_internal_data_[];
constexpr SatParameters_VariableOrder SatParameters_VariableOrder_VariableOrder_MIN = static_cast<SatParameters_VariableOrder>(0);
constexpr SatParameters_VariableOrder SatParameters_VariableOrder_VariableOrder_MAX = static_cast<SatParameters_VariableOrder>(2);
constexpr int SatParameters_VariableOrder_VariableOrder_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_VariableOrder_descriptor();
template <typename T>
const std::string& SatParameters_VariableOrder_Name(T value) {
  static_assert(std::is_same<T, SatParameters_VariableOrder>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VariableOrder_Name().");
  return SatParameters_VariableOrder_Name(static_cast<SatParameters_VariableOrder>(value));
}
template <>
inline const std::string& SatParameters_VariableOrder_Name(SatParameters_VariableOrder value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_VariableOrder_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SatParameters_VariableOrder_Parse(absl::string_view name, SatParameters_VariableOrder* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_VariableOrder>(
      SatParameters_VariableOrder_descriptor(), name, value);
}
enum SatParameters_Polarity : int {
  SatParameters_Polarity_POLARITY_TRUE = 0,
  SatParameters_Polarity_POLARITY_FALSE = 1,
  SatParameters_Polarity_POLARITY_RANDOM = 2,
  SatParameters_Polarity_POLARITY_WEIGHTED_SIGN = 3,
  SatParameters_Polarity_POLARITY_REVERSE_WEIGHTED_SIGN = 4,
};

bool SatParameters_Polarity_IsValid(int value);
extern const uint32_t SatParameters_Polarity_internal_data_[];
constexpr SatParameters_Polarity SatParameters_Polarity_Polarity_MIN = static_cast<SatParameters_Polarity>(0);
constexpr SatParameters_Polarity SatParameters_Polarity_Polarity_MAX = static_cast<SatParameters_Polarity>(4);
constexpr int SatParameters_Polarity_Polarity_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_Polarity_descriptor();
template <typename T>
const std::string& SatParameters_Polarity_Name(T value) {
  static_assert(std::is_same<T, SatParameters_Polarity>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Polarity_Name().");
  return SatParameters_Polarity_Name(static_cast<SatParameters_Polarity>(value));
}
template <>
inline const std::string& SatParameters_Polarity_Name(SatParameters_Polarity value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_Polarity_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SatParameters_Polarity_Parse(absl::string_view name, SatParameters_Polarity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_Polarity>(
      SatParameters_Polarity_descriptor(), name, value);
}
enum SatParameters_ConflictMinimizationAlgorithm : int {
  SatParameters_ConflictMinimizationAlgorithm_NONE = 0,
  SatParameters_ConflictMinimizationAlgorithm_SIMPLE = 1,
  SatParameters_ConflictMinimizationAlgorithm_RECURSIVE = 2,
  SatParameters_ConflictMinimizationAlgorithm_EXPERIMENTAL = 3,
};

bool SatParameters_ConflictMinimizationAlgorithm_IsValid(int value);
extern const uint32_t SatParameters_ConflictMinimizationAlgorithm_internal_data_[];
constexpr SatParameters_ConflictMinimizationAlgorithm SatParameters_ConflictMinimizationAlgorithm_ConflictMinimizationAlgorithm_MIN = static_cast<SatParameters_ConflictMinimizationAlgorithm>(0);
constexpr SatParameters_ConflictMinimizationAlgorithm SatParameters_ConflictMinimizationAlgorithm_ConflictMinimizationAlgorithm_MAX = static_cast<SatParameters_ConflictMinimizationAlgorithm>(3);
constexpr int SatParameters_ConflictMinimizationAlgorithm_ConflictMinimizationAlgorithm_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_ConflictMinimizationAlgorithm_descriptor();
template <typename T>
const std::string& SatParameters_ConflictMinimizationAlgorithm_Name(T value) {
  static_assert(std::is_same<T, SatParameters_ConflictMinimizationAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConflictMinimizationAlgorithm_Name().");
  return SatParameters_ConflictMinimizationAlgorithm_Name(static_cast<SatParameters_ConflictMinimizationAlgorithm>(value));
}
template <>
inline const std::string& SatParameters_ConflictMinimizationAlgorithm_Name(SatParameters_ConflictMinimizationAlgorithm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_ConflictMinimizationAlgorithm_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SatParameters_ConflictMinimizationAlgorithm_Parse(absl::string_view name, SatParameters_ConflictMinimizationAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_ConflictMinimizationAlgorithm>(
      SatParameters_ConflictMinimizationAlgorithm_descriptor(), name, value);
}
enum SatParameters_BinaryMinizationAlgorithm : int {
  SatParameters_BinaryMinizationAlgorithm_NO_BINARY_MINIMIZATION = 0,
  SatParameters_BinaryMinizationAlgorithm_BINARY_MINIMIZATION_FIRST = 1,
  SatParameters_BinaryMinizationAlgorithm_BINARY_MINIMIZATION_FIRST_WITH_TRANSITIVE_REDUCTION = 4,
  SatParameters_BinaryMinizationAlgorithm_BINARY_MINIMIZATION_WITH_REACHABILITY = 2,
  SatParameters_BinaryMinizationAlgorithm_EXPERIMENTAL_BINARY_MINIMIZATION = 3,
};

bool SatParameters_BinaryMinizationAlgorithm_IsValid(int value);
extern const uint32_t SatParameters_BinaryMinizationAlgorithm_internal_data_[];
constexpr SatParameters_BinaryMinizationAlgorithm SatParameters_BinaryMinizationAlgorithm_BinaryMinizationAlgorithm_MIN = static_cast<SatParameters_BinaryMinizationAlgorithm>(0);
constexpr SatParameters_BinaryMinizationAlgorithm SatParameters_BinaryMinizationAlgorithm_BinaryMinizationAlgorithm_MAX = static_cast<SatParameters_BinaryMinizationAlgorithm>(4);
constexpr int SatParameters_BinaryMinizationAlgorithm_BinaryMinizationAlgorithm_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_BinaryMinizationAlgorithm_descriptor();
template <typename T>
const std::string& SatParameters_BinaryMinizationAlgorithm_Name(T value) {
  static_assert(std::is_same<T, SatParameters_BinaryMinizationAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BinaryMinizationAlgorithm_Name().");
  return SatParameters_BinaryMinizationAlgorithm_Name(static_cast<SatParameters_BinaryMinizationAlgorithm>(value));
}
template <>
inline const std::string& SatParameters_BinaryMinizationAlgorithm_Name(SatParameters_BinaryMinizationAlgorithm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_BinaryMinizationAlgorithm_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SatParameters_BinaryMinizationAlgorithm_Parse(absl::string_view name, SatParameters_BinaryMinizationAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_BinaryMinizationAlgorithm>(
      SatParameters_BinaryMinizationAlgorithm_descriptor(), name, value);
}
enum SatParameters_ClauseProtection : int {
  SatParameters_ClauseProtection_PROTECTION_NONE = 0,
  SatParameters_ClauseProtection_PROTECTION_ALWAYS = 1,
  SatParameters_ClauseProtection_PROTECTION_LBD = 2,
};

bool SatParameters_ClauseProtection_IsValid(int value);
extern const uint32_t SatParameters_ClauseProtection_internal_data_[];
constexpr SatParameters_ClauseProtection SatParameters_ClauseProtection_ClauseProtection_MIN = static_cast<SatParameters_ClauseProtection>(0);
constexpr SatParameters_ClauseProtection SatParameters_ClauseProtection_ClauseProtection_MAX = static_cast<SatParameters_ClauseProtection>(2);
constexpr int SatParameters_ClauseProtection_ClauseProtection_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_ClauseProtection_descriptor();
template <typename T>
const std::string& SatParameters_ClauseProtection_Name(T value) {
  static_assert(std::is_same<T, SatParameters_ClauseProtection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ClauseProtection_Name().");
  return SatParameters_ClauseProtection_Name(static_cast<SatParameters_ClauseProtection>(value));
}
template <>
inline const std::string& SatParameters_ClauseProtection_Name(SatParameters_ClauseProtection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_ClauseProtection_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SatParameters_ClauseProtection_Parse(absl::string_view name, SatParameters_ClauseProtection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_ClauseProtection>(
      SatParameters_ClauseProtection_descriptor(), name, value);
}
enum SatParameters_ClauseOrdering : int {
  SatParameters_ClauseOrdering_CLAUSE_ACTIVITY = 0,
  SatParameters_ClauseOrdering_CLAUSE_LBD = 1,
};

bool SatParameters_ClauseOrdering_IsValid(int value);
extern const uint32_t SatParameters_ClauseOrdering_internal_data_[];
constexpr SatParameters_ClauseOrdering SatParameters_ClauseOrdering_ClauseOrdering_MIN = static_cast<SatParameters_ClauseOrdering>(0);
constexpr SatParameters_ClauseOrdering SatParameters_ClauseOrdering_ClauseOrdering_MAX = static_cast<SatParameters_ClauseOrdering>(1);
constexpr int SatParameters_ClauseOrdering_ClauseOrdering_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_ClauseOrdering_descriptor();
template <typename T>
const std::string& SatParameters_ClauseOrdering_Name(T value) {
  static_assert(std::is_same<T, SatParameters_ClauseOrdering>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ClauseOrdering_Name().");
  return SatParameters_ClauseOrdering_Name(static_cast<SatParameters_ClauseOrdering>(value));
}
template <>
inline const std::string& SatParameters_ClauseOrdering_Name(SatParameters_ClauseOrdering value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_ClauseOrdering_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SatParameters_ClauseOrdering_Parse(absl::string_view name, SatParameters_ClauseOrdering* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_ClauseOrdering>(
      SatParameters_ClauseOrdering_descriptor(), name, value);
}
enum SatParameters_RestartAlgorithm : int {
  SatParameters_RestartAlgorithm_NO_RESTART = 0,
  SatParameters_RestartAlgorithm_LUBY_RESTART = 1,
  SatParameters_RestartAlgorithm_DL_MOVING_AVERAGE_RESTART = 2,
  SatParameters_RestartAlgorithm_LBD_MOVING_AVERAGE_RESTART = 3,
  SatParameters_RestartAlgorithm_FIXED_RESTART = 4,
};

bool SatParameters_RestartAlgorithm_IsValid(int value);
extern const uint32_t SatParameters_RestartAlgorithm_internal_data_[];
constexpr SatParameters_RestartAlgorithm SatParameters_RestartAlgorithm_RestartAlgorithm_MIN = static_cast<SatParameters_RestartAlgorithm>(0);
constexpr SatParameters_RestartAlgorithm SatParameters_RestartAlgorithm_RestartAlgorithm_MAX = static_cast<SatParameters_RestartAlgorithm>(4);
constexpr int SatParameters_RestartAlgorithm_RestartAlgorithm_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_RestartAlgorithm_descriptor();
template <typename T>
const std::string& SatParameters_RestartAlgorithm_Name(T value) {
  static_assert(std::is_same<T, SatParameters_RestartAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RestartAlgorithm_Name().");
  return SatParameters_RestartAlgorithm_Name(static_cast<SatParameters_RestartAlgorithm>(value));
}
template <>
inline const std::string& SatParameters_RestartAlgorithm_Name(SatParameters_RestartAlgorithm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_RestartAlgorithm_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SatParameters_RestartAlgorithm_Parse(absl::string_view name, SatParameters_RestartAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_RestartAlgorithm>(
      SatParameters_RestartAlgorithm_descriptor(), name, value);
}
enum SatParameters_MaxSatAssumptionOrder : int {
  SatParameters_MaxSatAssumptionOrder_DEFAULT_ASSUMPTION_ORDER = 0,
  SatParameters_MaxSatAssumptionOrder_ORDER_ASSUMPTION_BY_DEPTH = 1,
  SatParameters_MaxSatAssumptionOrder_ORDER_ASSUMPTION_BY_WEIGHT = 2,
};

bool SatParameters_MaxSatAssumptionOrder_IsValid(int value);
extern const uint32_t SatParameters_MaxSatAssumptionOrder_internal_data_[];
constexpr SatParameters_MaxSatAssumptionOrder SatParameters_MaxSatAssumptionOrder_MaxSatAssumptionOrder_MIN = static_cast<SatParameters_MaxSatAssumptionOrder>(0);
constexpr SatParameters_MaxSatAssumptionOrder SatParameters_MaxSatAssumptionOrder_MaxSatAssumptionOrder_MAX = static_cast<SatParameters_MaxSatAssumptionOrder>(2);
constexpr int SatParameters_MaxSatAssumptionOrder_MaxSatAssumptionOrder_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_MaxSatAssumptionOrder_descriptor();
template <typename T>
const std::string& SatParameters_MaxSatAssumptionOrder_Name(T value) {
  static_assert(std::is_same<T, SatParameters_MaxSatAssumptionOrder>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MaxSatAssumptionOrder_Name().");
  return SatParameters_MaxSatAssumptionOrder_Name(static_cast<SatParameters_MaxSatAssumptionOrder>(value));
}
template <>
inline const std::string& SatParameters_MaxSatAssumptionOrder_Name(SatParameters_MaxSatAssumptionOrder value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_MaxSatAssumptionOrder_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SatParameters_MaxSatAssumptionOrder_Parse(absl::string_view name, SatParameters_MaxSatAssumptionOrder* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_MaxSatAssumptionOrder>(
      SatParameters_MaxSatAssumptionOrder_descriptor(), name, value);
}
enum SatParameters_MaxSatStratificationAlgorithm : int {
  SatParameters_MaxSatStratificationAlgorithm_STRATIFICATION_NONE = 0,
  SatParameters_MaxSatStratificationAlgorithm_STRATIFICATION_DESCENT = 1,
  SatParameters_MaxSatStratificationAlgorithm_STRATIFICATION_ASCENT = 2,
};

bool SatParameters_MaxSatStratificationAlgorithm_IsValid(int value);
extern const uint32_t SatParameters_MaxSatStratificationAlgorithm_internal_data_[];
constexpr SatParameters_MaxSatStratificationAlgorithm SatParameters_MaxSatStratificationAlgorithm_MaxSatStratificationAlgorithm_MIN = static_cast<SatParameters_MaxSatStratificationAlgorithm>(0);
constexpr SatParameters_MaxSatStratificationAlgorithm SatParameters_MaxSatStratificationAlgorithm_MaxSatStratificationAlgorithm_MAX = static_cast<SatParameters_MaxSatStratificationAlgorithm>(2);
constexpr int SatParameters_MaxSatStratificationAlgorithm_MaxSatStratificationAlgorithm_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_MaxSatStratificationAlgorithm_descriptor();
template <typename T>
const std::string& SatParameters_MaxSatStratificationAlgorithm_Name(T value) {
  static_assert(std::is_same<T, SatParameters_MaxSatStratificationAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MaxSatStratificationAlgorithm_Name().");
  return SatParameters_MaxSatStratificationAlgorithm_Name(static_cast<SatParameters_MaxSatStratificationAlgorithm>(value));
}
template <>
inline const std::string& SatParameters_MaxSatStratificationAlgorithm_Name(SatParameters_MaxSatStratificationAlgorithm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_MaxSatStratificationAlgorithm_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SatParameters_MaxSatStratificationAlgorithm_Parse(absl::string_view name, SatParameters_MaxSatStratificationAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_MaxSatStratificationAlgorithm>(
      SatParameters_MaxSatStratificationAlgorithm_descriptor(), name, value);
}
enum SatParameters_SearchBranching : int {
  SatParameters_SearchBranching_AUTOMATIC_SEARCH = 0,
  SatParameters_SearchBranching_FIXED_SEARCH = 1,
  SatParameters_SearchBranching_PORTFOLIO_SEARCH = 2,
  SatParameters_SearchBranching_LP_SEARCH = 3,
  SatParameters_SearchBranching_PSEUDO_COST_SEARCH = 4,
  SatParameters_SearchBranching_PORTFOLIO_WITH_QUICK_RESTART_SEARCH = 5,
  SatParameters_SearchBranching_HINT_SEARCH = 6,
  SatParameters_SearchBranching_PARTIAL_FIXED_SEARCH = 7,
  SatParameters_SearchBranching_RANDOMIZED_SEARCH = 8,
};

bool SatParameters_SearchBranching_IsValid(int value);
extern const uint32_t SatParameters_SearchBranching_internal_data_[];
constexpr SatParameters_SearchBranching SatParameters_SearchBranching_SearchBranching_MIN = static_cast<SatParameters_SearchBranching>(0);
constexpr SatParameters_SearchBranching SatParameters_SearchBranching_SearchBranching_MAX = static_cast<SatParameters_SearchBranching>(8);
constexpr int SatParameters_SearchBranching_SearchBranching_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_SearchBranching_descriptor();
template <typename T>
const std::string& SatParameters_SearchBranching_Name(T value) {
  static_assert(std::is_same<T, SatParameters_SearchBranching>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SearchBranching_Name().");
  return SatParameters_SearchBranching_Name(static_cast<SatParameters_SearchBranching>(value));
}
template <>
inline const std::string& SatParameters_SearchBranching_Name(SatParameters_SearchBranching value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_SearchBranching_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool SatParameters_SearchBranching_Parse(absl::string_view name, SatParameters_SearchBranching* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_SearchBranching>(
      SatParameters_SearchBranching_descriptor(), name, value);
}
enum SatParameters_SharedTreeSplitStrategy : int {
  SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_AUTO = 0,
  SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_DISCREPANCY = 1,
  SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_OBJECTIVE_LB = 2,
  SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_BALANCED_TREE = 3,
  SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_FIRST_PROPOSAL = 4,
};

bool SatParameters_SharedTreeSplitStrategy_IsValid(int value);
extern const uint32_t SatParameters_SharedTreeSplitStrategy_internal_data_[];
constexpr SatParameters_SharedTreeSplitStrategy SatParameters_SharedTreeSplitStrategy_SharedTreeSplitStrategy_MIN = static_cast<SatParameters_SharedTreeSplitStrategy>(0);
constexpr SatParameters_SharedTreeSplitStrategy SatParameters_SharedTreeSplitStrategy_SharedTreeSplitStrategy_MAX = static_cast<SatParameters_SharedTreeSplitStrategy>(4);
constexpr int SatParameters_SharedTreeSplitStrategy_SharedTreeSplitStrategy_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_SharedTreeSplitStrategy_descriptor();
template <typename T>
const std::string& SatParameters_SharedTreeSplitStrategy_Name(T value) {
  static_assert(std::is_same<T, SatParameters_SharedTreeSplitStrategy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SharedTreeSplitStrategy_Name().");
  return SatParameters_SharedTreeSplitStrategy_Name(static_cast<SatParameters_SharedTreeSplitStrategy>(value));
}
template <>
inline const std::string& SatParameters_SharedTreeSplitStrategy_Name(SatParameters_SharedTreeSplitStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_SharedTreeSplitStrategy_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SatParameters_SharedTreeSplitStrategy_Parse(absl::string_view name, SatParameters_SharedTreeSplitStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_SharedTreeSplitStrategy>(
      SatParameters_SharedTreeSplitStrategy_descriptor(), name, value);
}
enum SatParameters_FPRoundingMethod : int {
  SatParameters_FPRoundingMethod_NEAREST_INTEGER = 0,
  SatParameters_FPRoundingMethod_LOCK_BASED = 1,
  SatParameters_FPRoundingMethod_ACTIVE_LOCK_BASED = 3,
  SatParameters_FPRoundingMethod_PROPAGATION_ASSISTED = 2,
};

bool SatParameters_FPRoundingMethod_IsValid(int value);
extern const uint32_t SatParameters_FPRoundingMethod_internal_data_[];
constexpr SatParameters_FPRoundingMethod SatParameters_FPRoundingMethod_FPRoundingMethod_MIN = static_cast<SatParameters_FPRoundingMethod>(0);
constexpr SatParameters_FPRoundingMethod SatParameters_FPRoundingMethod_FPRoundingMethod_MAX = static_cast<SatParameters_FPRoundingMethod>(3);
constexpr int SatParameters_FPRoundingMethod_FPRoundingMethod_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SatParameters_FPRoundingMethod_descriptor();
template <typename T>
const std::string& SatParameters_FPRoundingMethod_Name(T value) {
  static_assert(std::is_same<T, SatParameters_FPRoundingMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FPRoundingMethod_Name().");
  return SatParameters_FPRoundingMethod_Name(static_cast<SatParameters_FPRoundingMethod>(value));
}
template <>
inline const std::string& SatParameters_FPRoundingMethod_Name(SatParameters_FPRoundingMethod value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SatParameters_FPRoundingMethod_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SatParameters_FPRoundingMethod_Parse(absl::string_view name, SatParameters_FPRoundingMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SatParameters_FPRoundingMethod>(
      SatParameters_FPRoundingMethod_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SatParameters final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.sat.SatParameters) */ {
 public:
  inline SatParameters() : SatParameters(nullptr) {}
  ~SatParameters() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SatParameters(::google::protobuf::internal::ConstantInitialized);

  inline SatParameters(const SatParameters& from)
      : SatParameters(nullptr, from) {}
  SatParameters(SatParameters&& from) noexcept
    : SatParameters() {
    *this = ::std::move(from);
  }

  inline SatParameters& operator=(const SatParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline SatParameters& operator=(SatParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SatParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const SatParameters* internal_default_instance() {
    return reinterpret_cast<const SatParameters*>(
               &_SatParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SatParameters& a, SatParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(SatParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SatParameters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SatParameters* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SatParameters>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SatParameters& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SatParameters& from) {
    SatParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SatParameters* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "operations_research.sat.SatParameters";
  }
  protected:
  explicit SatParameters(::google::protobuf::Arena* arena);
  SatParameters(::google::protobuf::Arena* arena, const SatParameters& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VariableOrder = SatParameters_VariableOrder;
  static constexpr VariableOrder IN_ORDER = SatParameters_VariableOrder_IN_ORDER;
  static constexpr VariableOrder IN_REVERSE_ORDER = SatParameters_VariableOrder_IN_REVERSE_ORDER;
  static constexpr VariableOrder IN_RANDOM_ORDER = SatParameters_VariableOrder_IN_RANDOM_ORDER;
  static inline bool VariableOrder_IsValid(int value) {
    return SatParameters_VariableOrder_IsValid(value);
  }
  static constexpr VariableOrder VariableOrder_MIN = SatParameters_VariableOrder_VariableOrder_MIN;
  static constexpr VariableOrder VariableOrder_MAX = SatParameters_VariableOrder_VariableOrder_MAX;
  static constexpr int VariableOrder_ARRAYSIZE = SatParameters_VariableOrder_VariableOrder_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* VariableOrder_descriptor() {
    return SatParameters_VariableOrder_descriptor();
  }
  template <typename T>
  static inline const std::string& VariableOrder_Name(T value) {
    return SatParameters_VariableOrder_Name(value);
  }
  static inline bool VariableOrder_Parse(absl::string_view name, VariableOrder* value) {
    return SatParameters_VariableOrder_Parse(name, value);
  }

  using Polarity = SatParameters_Polarity;
  static constexpr Polarity POLARITY_TRUE = SatParameters_Polarity_POLARITY_TRUE;
  static constexpr Polarity POLARITY_FALSE = SatParameters_Polarity_POLARITY_FALSE;
  static constexpr Polarity POLARITY_RANDOM = SatParameters_Polarity_POLARITY_RANDOM;
  static constexpr Polarity POLARITY_WEIGHTED_SIGN = SatParameters_Polarity_POLARITY_WEIGHTED_SIGN;
  static constexpr Polarity POLARITY_REVERSE_WEIGHTED_SIGN = SatParameters_Polarity_POLARITY_REVERSE_WEIGHTED_SIGN;
  static inline bool Polarity_IsValid(int value) {
    return SatParameters_Polarity_IsValid(value);
  }
  static constexpr Polarity Polarity_MIN = SatParameters_Polarity_Polarity_MIN;
  static constexpr Polarity Polarity_MAX = SatParameters_Polarity_Polarity_MAX;
  static constexpr int Polarity_ARRAYSIZE = SatParameters_Polarity_Polarity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Polarity_descriptor() {
    return SatParameters_Polarity_descriptor();
  }
  template <typename T>
  static inline const std::string& Polarity_Name(T value) {
    return SatParameters_Polarity_Name(value);
  }
  static inline bool Polarity_Parse(absl::string_view name, Polarity* value) {
    return SatParameters_Polarity_Parse(name, value);
  }

  using ConflictMinimizationAlgorithm = SatParameters_ConflictMinimizationAlgorithm;
  static constexpr ConflictMinimizationAlgorithm NONE = SatParameters_ConflictMinimizationAlgorithm_NONE;
  static constexpr ConflictMinimizationAlgorithm SIMPLE = SatParameters_ConflictMinimizationAlgorithm_SIMPLE;
  static constexpr ConflictMinimizationAlgorithm RECURSIVE = SatParameters_ConflictMinimizationAlgorithm_RECURSIVE;
  static constexpr ConflictMinimizationAlgorithm EXPERIMENTAL = SatParameters_ConflictMinimizationAlgorithm_EXPERIMENTAL;
  static inline bool ConflictMinimizationAlgorithm_IsValid(int value) {
    return SatParameters_ConflictMinimizationAlgorithm_IsValid(value);
  }
  static constexpr ConflictMinimizationAlgorithm ConflictMinimizationAlgorithm_MIN = SatParameters_ConflictMinimizationAlgorithm_ConflictMinimizationAlgorithm_MIN;
  static constexpr ConflictMinimizationAlgorithm ConflictMinimizationAlgorithm_MAX = SatParameters_ConflictMinimizationAlgorithm_ConflictMinimizationAlgorithm_MAX;
  static constexpr int ConflictMinimizationAlgorithm_ARRAYSIZE = SatParameters_ConflictMinimizationAlgorithm_ConflictMinimizationAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ConflictMinimizationAlgorithm_descriptor() {
    return SatParameters_ConflictMinimizationAlgorithm_descriptor();
  }
  template <typename T>
  static inline const std::string& ConflictMinimizationAlgorithm_Name(T value) {
    return SatParameters_ConflictMinimizationAlgorithm_Name(value);
  }
  static inline bool ConflictMinimizationAlgorithm_Parse(absl::string_view name, ConflictMinimizationAlgorithm* value) {
    return SatParameters_ConflictMinimizationAlgorithm_Parse(name, value);
  }

  using BinaryMinizationAlgorithm = SatParameters_BinaryMinizationAlgorithm;
  static constexpr BinaryMinizationAlgorithm NO_BINARY_MINIMIZATION = SatParameters_BinaryMinizationAlgorithm_NO_BINARY_MINIMIZATION;
  static constexpr BinaryMinizationAlgorithm BINARY_MINIMIZATION_FIRST = SatParameters_BinaryMinizationAlgorithm_BINARY_MINIMIZATION_FIRST;
  static constexpr BinaryMinizationAlgorithm BINARY_MINIMIZATION_FIRST_WITH_TRANSITIVE_REDUCTION = SatParameters_BinaryMinizationAlgorithm_BINARY_MINIMIZATION_FIRST_WITH_TRANSITIVE_REDUCTION;
  static constexpr BinaryMinizationAlgorithm BINARY_MINIMIZATION_WITH_REACHABILITY = SatParameters_BinaryMinizationAlgorithm_BINARY_MINIMIZATION_WITH_REACHABILITY;
  static constexpr BinaryMinizationAlgorithm EXPERIMENTAL_BINARY_MINIMIZATION = SatParameters_BinaryMinizationAlgorithm_EXPERIMENTAL_BINARY_MINIMIZATION;
  static inline bool BinaryMinizationAlgorithm_IsValid(int value) {
    return SatParameters_BinaryMinizationAlgorithm_IsValid(value);
  }
  static constexpr BinaryMinizationAlgorithm BinaryMinizationAlgorithm_MIN = SatParameters_BinaryMinizationAlgorithm_BinaryMinizationAlgorithm_MIN;
  static constexpr BinaryMinizationAlgorithm BinaryMinizationAlgorithm_MAX = SatParameters_BinaryMinizationAlgorithm_BinaryMinizationAlgorithm_MAX;
  static constexpr int BinaryMinizationAlgorithm_ARRAYSIZE = SatParameters_BinaryMinizationAlgorithm_BinaryMinizationAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BinaryMinizationAlgorithm_descriptor() {
    return SatParameters_BinaryMinizationAlgorithm_descriptor();
  }
  template <typename T>
  static inline const std::string& BinaryMinizationAlgorithm_Name(T value) {
    return SatParameters_BinaryMinizationAlgorithm_Name(value);
  }
  static inline bool BinaryMinizationAlgorithm_Parse(absl::string_view name, BinaryMinizationAlgorithm* value) {
    return SatParameters_BinaryMinizationAlgorithm_Parse(name, value);
  }

  using ClauseProtection = SatParameters_ClauseProtection;
  static constexpr ClauseProtection PROTECTION_NONE = SatParameters_ClauseProtection_PROTECTION_NONE;
  static constexpr ClauseProtection PROTECTION_ALWAYS = SatParameters_ClauseProtection_PROTECTION_ALWAYS;
  static constexpr ClauseProtection PROTECTION_LBD = SatParameters_ClauseProtection_PROTECTION_LBD;
  static inline bool ClauseProtection_IsValid(int value) {
    return SatParameters_ClauseProtection_IsValid(value);
  }
  static constexpr ClauseProtection ClauseProtection_MIN = SatParameters_ClauseProtection_ClauseProtection_MIN;
  static constexpr ClauseProtection ClauseProtection_MAX = SatParameters_ClauseProtection_ClauseProtection_MAX;
  static constexpr int ClauseProtection_ARRAYSIZE = SatParameters_ClauseProtection_ClauseProtection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ClauseProtection_descriptor() {
    return SatParameters_ClauseProtection_descriptor();
  }
  template <typename T>
  static inline const std::string& ClauseProtection_Name(T value) {
    return SatParameters_ClauseProtection_Name(value);
  }
  static inline bool ClauseProtection_Parse(absl::string_view name, ClauseProtection* value) {
    return SatParameters_ClauseProtection_Parse(name, value);
  }

  using ClauseOrdering = SatParameters_ClauseOrdering;
  static constexpr ClauseOrdering CLAUSE_ACTIVITY = SatParameters_ClauseOrdering_CLAUSE_ACTIVITY;
  static constexpr ClauseOrdering CLAUSE_LBD = SatParameters_ClauseOrdering_CLAUSE_LBD;
  static inline bool ClauseOrdering_IsValid(int value) {
    return SatParameters_ClauseOrdering_IsValid(value);
  }
  static constexpr ClauseOrdering ClauseOrdering_MIN = SatParameters_ClauseOrdering_ClauseOrdering_MIN;
  static constexpr ClauseOrdering ClauseOrdering_MAX = SatParameters_ClauseOrdering_ClauseOrdering_MAX;
  static constexpr int ClauseOrdering_ARRAYSIZE = SatParameters_ClauseOrdering_ClauseOrdering_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ClauseOrdering_descriptor() {
    return SatParameters_ClauseOrdering_descriptor();
  }
  template <typename T>
  static inline const std::string& ClauseOrdering_Name(T value) {
    return SatParameters_ClauseOrdering_Name(value);
  }
  static inline bool ClauseOrdering_Parse(absl::string_view name, ClauseOrdering* value) {
    return SatParameters_ClauseOrdering_Parse(name, value);
  }

  using RestartAlgorithm = SatParameters_RestartAlgorithm;
  static constexpr RestartAlgorithm NO_RESTART = SatParameters_RestartAlgorithm_NO_RESTART;
  static constexpr RestartAlgorithm LUBY_RESTART = SatParameters_RestartAlgorithm_LUBY_RESTART;
  static constexpr RestartAlgorithm DL_MOVING_AVERAGE_RESTART = SatParameters_RestartAlgorithm_DL_MOVING_AVERAGE_RESTART;
  static constexpr RestartAlgorithm LBD_MOVING_AVERAGE_RESTART = SatParameters_RestartAlgorithm_LBD_MOVING_AVERAGE_RESTART;
  static constexpr RestartAlgorithm FIXED_RESTART = SatParameters_RestartAlgorithm_FIXED_RESTART;
  static inline bool RestartAlgorithm_IsValid(int value) {
    return SatParameters_RestartAlgorithm_IsValid(value);
  }
  static constexpr RestartAlgorithm RestartAlgorithm_MIN = SatParameters_RestartAlgorithm_RestartAlgorithm_MIN;
  static constexpr RestartAlgorithm RestartAlgorithm_MAX = SatParameters_RestartAlgorithm_RestartAlgorithm_MAX;
  static constexpr int RestartAlgorithm_ARRAYSIZE = SatParameters_RestartAlgorithm_RestartAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RestartAlgorithm_descriptor() {
    return SatParameters_RestartAlgorithm_descriptor();
  }
  template <typename T>
  static inline const std::string& RestartAlgorithm_Name(T value) {
    return SatParameters_RestartAlgorithm_Name(value);
  }
  static inline bool RestartAlgorithm_Parse(absl::string_view name, RestartAlgorithm* value) {
    return SatParameters_RestartAlgorithm_Parse(name, value);
  }

  using MaxSatAssumptionOrder = SatParameters_MaxSatAssumptionOrder;
  static constexpr MaxSatAssumptionOrder DEFAULT_ASSUMPTION_ORDER = SatParameters_MaxSatAssumptionOrder_DEFAULT_ASSUMPTION_ORDER;
  static constexpr MaxSatAssumptionOrder ORDER_ASSUMPTION_BY_DEPTH = SatParameters_MaxSatAssumptionOrder_ORDER_ASSUMPTION_BY_DEPTH;
  static constexpr MaxSatAssumptionOrder ORDER_ASSUMPTION_BY_WEIGHT = SatParameters_MaxSatAssumptionOrder_ORDER_ASSUMPTION_BY_WEIGHT;
  static inline bool MaxSatAssumptionOrder_IsValid(int value) {
    return SatParameters_MaxSatAssumptionOrder_IsValid(value);
  }
  static constexpr MaxSatAssumptionOrder MaxSatAssumptionOrder_MIN = SatParameters_MaxSatAssumptionOrder_MaxSatAssumptionOrder_MIN;
  static constexpr MaxSatAssumptionOrder MaxSatAssumptionOrder_MAX = SatParameters_MaxSatAssumptionOrder_MaxSatAssumptionOrder_MAX;
  static constexpr int MaxSatAssumptionOrder_ARRAYSIZE = SatParameters_MaxSatAssumptionOrder_MaxSatAssumptionOrder_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MaxSatAssumptionOrder_descriptor() {
    return SatParameters_MaxSatAssumptionOrder_descriptor();
  }
  template <typename T>
  static inline const std::string& MaxSatAssumptionOrder_Name(T value) {
    return SatParameters_MaxSatAssumptionOrder_Name(value);
  }
  static inline bool MaxSatAssumptionOrder_Parse(absl::string_view name, MaxSatAssumptionOrder* value) {
    return SatParameters_MaxSatAssumptionOrder_Parse(name, value);
  }

  using MaxSatStratificationAlgorithm = SatParameters_MaxSatStratificationAlgorithm;
  static constexpr MaxSatStratificationAlgorithm STRATIFICATION_NONE = SatParameters_MaxSatStratificationAlgorithm_STRATIFICATION_NONE;
  static constexpr MaxSatStratificationAlgorithm STRATIFICATION_DESCENT = SatParameters_MaxSatStratificationAlgorithm_STRATIFICATION_DESCENT;
  static constexpr MaxSatStratificationAlgorithm STRATIFICATION_ASCENT = SatParameters_MaxSatStratificationAlgorithm_STRATIFICATION_ASCENT;
  static inline bool MaxSatStratificationAlgorithm_IsValid(int value) {
    return SatParameters_MaxSatStratificationAlgorithm_IsValid(value);
  }
  static constexpr MaxSatStratificationAlgorithm MaxSatStratificationAlgorithm_MIN = SatParameters_MaxSatStratificationAlgorithm_MaxSatStratificationAlgorithm_MIN;
  static constexpr MaxSatStratificationAlgorithm MaxSatStratificationAlgorithm_MAX = SatParameters_MaxSatStratificationAlgorithm_MaxSatStratificationAlgorithm_MAX;
  static constexpr int MaxSatStratificationAlgorithm_ARRAYSIZE = SatParameters_MaxSatStratificationAlgorithm_MaxSatStratificationAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MaxSatStratificationAlgorithm_descriptor() {
    return SatParameters_MaxSatStratificationAlgorithm_descriptor();
  }
  template <typename T>
  static inline const std::string& MaxSatStratificationAlgorithm_Name(T value) {
    return SatParameters_MaxSatStratificationAlgorithm_Name(value);
  }
  static inline bool MaxSatStratificationAlgorithm_Parse(absl::string_view name, MaxSatStratificationAlgorithm* value) {
    return SatParameters_MaxSatStratificationAlgorithm_Parse(name, value);
  }

  using SearchBranching = SatParameters_SearchBranching;
  static constexpr SearchBranching AUTOMATIC_SEARCH = SatParameters_SearchBranching_AUTOMATIC_SEARCH;
  static constexpr SearchBranching FIXED_SEARCH = SatParameters_SearchBranching_FIXED_SEARCH;
  static constexpr SearchBranching PORTFOLIO_SEARCH = SatParameters_SearchBranching_PORTFOLIO_SEARCH;
  static constexpr SearchBranching LP_SEARCH = SatParameters_SearchBranching_LP_SEARCH;
  static constexpr SearchBranching PSEUDO_COST_SEARCH = SatParameters_SearchBranching_PSEUDO_COST_SEARCH;
  static constexpr SearchBranching PORTFOLIO_WITH_QUICK_RESTART_SEARCH = SatParameters_SearchBranching_PORTFOLIO_WITH_QUICK_RESTART_SEARCH;
  static constexpr SearchBranching HINT_SEARCH = SatParameters_SearchBranching_HINT_SEARCH;
  static constexpr SearchBranching PARTIAL_FIXED_SEARCH = SatParameters_SearchBranching_PARTIAL_FIXED_SEARCH;
  static constexpr SearchBranching RANDOMIZED_SEARCH = SatParameters_SearchBranching_RANDOMIZED_SEARCH;
  static inline bool SearchBranching_IsValid(int value) {
    return SatParameters_SearchBranching_IsValid(value);
  }
  static constexpr SearchBranching SearchBranching_MIN = SatParameters_SearchBranching_SearchBranching_MIN;
  static constexpr SearchBranching SearchBranching_MAX = SatParameters_SearchBranching_SearchBranching_MAX;
  static constexpr int SearchBranching_ARRAYSIZE = SatParameters_SearchBranching_SearchBranching_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SearchBranching_descriptor() {
    return SatParameters_SearchBranching_descriptor();
  }
  template <typename T>
  static inline const std::string& SearchBranching_Name(T value) {
    return SatParameters_SearchBranching_Name(value);
  }
  static inline bool SearchBranching_Parse(absl::string_view name, SearchBranching* value) {
    return SatParameters_SearchBranching_Parse(name, value);
  }

  using SharedTreeSplitStrategy = SatParameters_SharedTreeSplitStrategy;
  static constexpr SharedTreeSplitStrategy SPLIT_STRATEGY_AUTO = SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_AUTO;
  static constexpr SharedTreeSplitStrategy SPLIT_STRATEGY_DISCREPANCY = SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_DISCREPANCY;
  static constexpr SharedTreeSplitStrategy SPLIT_STRATEGY_OBJECTIVE_LB = SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_OBJECTIVE_LB;
  static constexpr SharedTreeSplitStrategy SPLIT_STRATEGY_BALANCED_TREE = SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_BALANCED_TREE;
  static constexpr SharedTreeSplitStrategy SPLIT_STRATEGY_FIRST_PROPOSAL = SatParameters_SharedTreeSplitStrategy_SPLIT_STRATEGY_FIRST_PROPOSAL;
  static inline bool SharedTreeSplitStrategy_IsValid(int value) {
    return SatParameters_SharedTreeSplitStrategy_IsValid(value);
  }
  static constexpr SharedTreeSplitStrategy SharedTreeSplitStrategy_MIN = SatParameters_SharedTreeSplitStrategy_SharedTreeSplitStrategy_MIN;
  static constexpr SharedTreeSplitStrategy SharedTreeSplitStrategy_MAX = SatParameters_SharedTreeSplitStrategy_SharedTreeSplitStrategy_MAX;
  static constexpr int SharedTreeSplitStrategy_ARRAYSIZE = SatParameters_SharedTreeSplitStrategy_SharedTreeSplitStrategy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SharedTreeSplitStrategy_descriptor() {
    return SatParameters_SharedTreeSplitStrategy_descriptor();
  }
  template <typename T>
  static inline const std::string& SharedTreeSplitStrategy_Name(T value) {
    return SatParameters_SharedTreeSplitStrategy_Name(value);
  }
  static inline bool SharedTreeSplitStrategy_Parse(absl::string_view name, SharedTreeSplitStrategy* value) {
    return SatParameters_SharedTreeSplitStrategy_Parse(name, value);
  }

  using FPRoundingMethod = SatParameters_FPRoundingMethod;
  static constexpr FPRoundingMethod NEAREST_INTEGER = SatParameters_FPRoundingMethod_NEAREST_INTEGER;
  static constexpr FPRoundingMethod LOCK_BASED = SatParameters_FPRoundingMethod_LOCK_BASED;
  static constexpr FPRoundingMethod ACTIVE_LOCK_BASED = SatParameters_FPRoundingMethod_ACTIVE_LOCK_BASED;
  static constexpr FPRoundingMethod PROPAGATION_ASSISTED = SatParameters_FPRoundingMethod_PROPAGATION_ASSISTED;
  static inline bool FPRoundingMethod_IsValid(int value) {
    return SatParameters_FPRoundingMethod_IsValid(value);
  }
  static constexpr FPRoundingMethod FPRoundingMethod_MIN = SatParameters_FPRoundingMethod_FPRoundingMethod_MIN;
  static constexpr FPRoundingMethod FPRoundingMethod_MAX = SatParameters_FPRoundingMethod_FPRoundingMethod_MAX;
  static constexpr int FPRoundingMethod_ARRAYSIZE = SatParameters_FPRoundingMethod_FPRoundingMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FPRoundingMethod_descriptor() {
    return SatParameters_FPRoundingMethod_descriptor();
  }
  template <typename T>
  static inline const std::string& FPRoundingMethod_Name(T value) {
    return SatParameters_FPRoundingMethod_Name(value);
  }
  static inline bool FPRoundingMethod_Parse(absl::string_view name, FPRoundingMethod* value) {
    return SatParameters_FPRoundingMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRestartAlgorithmsFieldNumber = 61,
    kSubsolversFieldNumber = 207,
    kIgnoreSubsolversFieldNumber = 209,
    kSubsolverParamsFieldNumber = 210,
    kExtraSubsolversFieldNumber = 219,
    kDefaultRestartAlgorithmsFieldNumber = 70,
    kNameFieldNumber = 171,
    kLogPrefixFieldNumber = 185,
    kPreferredVariableOrderFieldNumber = 1,
    kClauseCleanupTargetFieldNumber = 13,
    kRandomBranchesRatioFieldNumber = 32,
    kRandomPolarityRatioFieldNumber = 45,
    kMaxSatAssumptionOrderFieldNumber = 51,
    kClauseCleanupProtectionFieldNumber = 58,
    kClauseCleanupOrderingFieldNumber = 60,
    kNumConflictsBeforeStrategyChangesFieldNumber = 68,
    kStrategyChangeIncreaseRatioFieldNumber = 69,
    kInitialVariablesActivityFieldNumber = 76,
    kSearchBranchingFieldNumber = 82,
    kUseErwaHeuristicFieldNumber = 75,
    kAlsoBumpVariablesInConflictReasonsFieldNumber = 77,
    kUseBlockingRestartFieldNumber = 64,
    kPermuteVariableRandomlyFieldNumber = 178,
    kSearchRandomVariablePoolSizeFieldNumber = 104,
    kNumSearchWorkersFieldNumber = 100,
    kLogToResponseFieldNumber = 187,
    kUsePbResolutionFieldNumber = 43,
    kMinimizeReductionDuringPbResolutionFieldNumber = 48,
    kUseSatInprocessingFieldNumber = 163,
    kProbingPeriodAtRootFieldNumber = 142,
    kInterleaveBatchSizeFieldNumber = 134,
    kPermutePresolveConstraintOrderFieldNumber = 179,
    kUseAbslRandomFieldNumber = 180,
    kLogSearchProgressFieldNumber = 41,
    kLogSubsolverStatisticsFieldNumber = 189,
    kUseOverloadCheckerInCumulativeFieldNumber = 78,
    kUseTimetableEdgeFindingInCumulativeFieldNumber = 79,
    kUseHardPrecedencesInCumulativeFieldNumber = 215,
    kExploitAllPrecedencesFieldNumber = 220,
    kOptimizeWithCoreFieldNumber = 83,
    kOptimizeWithLbTreeSearchFieldNumber = 188,
    kOptimizeWithMaxHsFieldNumber = 85,
    kTestFeasibilityJumpFieldNumber = 240,
    kUseLnsOnlyFieldNumber = 101,
    kUseLbRelaxLnsFieldNumber = 255,
    kDiversifyLnsParamsFieldNumber = 137,
    kRandomizeSearchFieldNumber = 103,
    kDebugMaxNumPresolveOperationsFieldNumber = 151,
    kUseSharedTreeSearchFieldNumber = 236,
    kEnumerateAllSolutionsFieldNumber = 87,
    kKeepAllFeasibleSolutionsInPresolveFieldNumber = 173,
    kFillTightenedDomainsInResponseFieldNumber = 132,
    kPushAllTasksTowardStartFieldNumber = 262,
    kUseOptionalVariablesFieldNumber = 108,
    kUseBranchingInLpFieldNumber = 139,
    kUseCombinedNoOverlapFieldNumber = 133,
    kRelativeGapLimitFieldNumber = 160,
    kPresolveExtractIntegerEnforcementFieldNumber = 174,
    kInterleaveSearchFieldNumber = 136,
    kDebugPostsolveWithFullSolverFieldNumber = 162,
    kDebugCrashOnBadHintFieldNumber = 195,
    kAddObjectiveCutFieldNumber = 197,
    kRepairHintFieldNumber = 167,
    kFixVariablesToTheirHintedValueFieldNumber = 192,
    kExploitBestSolutionFieldNumber = 130,
    kFillAdditionalSolutionsInResponseFieldNumber = 194,
    kStopAfterFirstSolutionFieldNumber = 98,
    kStopAfterPresolveFieldNumber = 149,
    kStopAfterRootPropagationFieldNumber = 252,
    kUseTimetablingInNoOverlap2DFieldNumber = 200,
    kUseEnergeticReasoningInNoOverlap2DFieldNumber = 213,
    kUsePairwiseReasoningInNoOverlap2DFieldNumber = 251,
    kOnlyAddCutsAtLevelZeroFieldNumber = 92,
    kDetectTableWithCostFieldNumber = 216,
    kExpandAlldiffConstraintsFieldNumber = 170,
    kDisableConstraintExpansionFieldNumber = 181,
    kEncodeComplexLinearConstraintWithIntegerFieldNumber = 223,
    kMaxSatReverseAssumptionOrderFieldNumber = 52,
    kUseStrongPropagationInDisjunctiveFieldNumber = 230,
    kUseDynamicPrecedenceInDisjunctiveFieldNumber = 263,
    kUseDynamicPrecedenceInCumulativeFieldNumber = 268,
    kExploitRelaxationSolutionFieldNumber = 161,
    kUseProbingSearchFieldNumber = 176,
    kUseObjectiveLbSearchFieldNumber = 228,
    kUseObjectiveShavingSearchFieldNumber = 253,
    kNumWorkersFieldNumber = 206,
    kPolishLpSolutionFieldNumber = 175,
    kNewLinearPropagationFieldNumber = 224,
    kMipScaleLargeDomainFieldNumber = 225,
    kOnlySolveIpFieldNumber = 222,
    kSharedTreeNumWorkersFieldNumber = 235,
    kSharedTreeSplitStrategyFieldNumber = 239,
    kNumViolationLsFieldNumber = 244,
    kFeasibilityJumpVarRandomizationProbabilityFieldNumber = 247,
    kInitialPolarityFieldNumber = 2,
    kMinimizationAlgorithmFieldNumber = 4,
    kVariableActivityDecayFieldNumber = 15,
    kMaxVariableActivityValueFieldNumber = 16,
    kClauseActivityDecayFieldNumber = 17,
    kClauseCleanupPeriodFieldNumber = 11,
    kGlucoseDecayIncrementPeriodFieldNumber = 24,
    kMaxClauseActivityValueFieldNumber = 18,
    kGlucoseMaxDecayFieldNumber = 22,
    kGlucoseDecayIncrementFieldNumber = 23,
    kRestartPeriodFieldNumber = 30,
    kRandomSeedFieldNumber = 31,
    kMaxTimeInSecondsFieldNumber = 36,
    kMaxNumberOfConflictsFieldNumber = 37,
    kMaxMemoryInMbFieldNumber = 40,
    kBinaryMinimizationAlgorithmFieldNumber = 34,
    kPbCleanupIncrementFieldNumber = 46,
    kPbCleanupRatioFieldNumber = 47,
    kCoreMinimizationLevelFieldNumber = 50,
    kMaxSatStratificationFieldNumber = 53,
    kPresolveBveThresholdFieldNumber = 54,
    kPresolveBveClauseWeightFieldNumber = 55,
    kPresolveProbingDeterministicTimeLimitFieldNumber = 57,
    kClauseCleanupLbdBoundFieldNumber = 59,
    kRestartRunningWindowSizeFieldNumber = 62,
    kRestartDlAverageRatioFieldNumber = 63,
    kBlockingRestartMultiplierFieldNumber = 66,
    kMaxDeterministicTimeFieldNumber = 67,
    kBlockingRestartWindowSizeFieldNumber = 65,
    kPresolveBvaThresholdFieldNumber = 73,
    kRestartLbdAverageRatioFieldNumber = 71,
    kFindMultipleCoresFieldNumber = 84,
    kCoverOptimizationFieldNumber = 89,
    kUsePrecedencesInDisjunctiveConstraintFieldNumber = 74,
    kUseDisjunctiveConstraintInCumulativeFieldNumber = 80,
    kUsePhaseSavingFieldNumber = 44,
    kSubsumptionDuringConflictAnalysisFieldNumber = 56,
    kLogToStdoutFieldNumber = 186,
    kCountAssumptionLevelsInLbdFieldNumber = 49,
    kPresolveBlockedClauseFieldNumber = 88,
    kPresolveUseBvaFieldNumber = 72,
    kCpModelPresolveFieldNumber = 86,
    kCpModelUseSatPresolveFieldNumber = 93,
    kLinearizationLevelFieldNumber = 90,
    kMaxNumCutsFieldNumber = 91,
    kMinimizeWithPropagationRestartPeriodFieldNumber = 96,
    kMinimizeWithPropagationNumDecisionsFieldNumber = 97,
    kBinarySearchNumConflictsFieldNumber = 99,
    kBooleanEncodingLevelFieldNumber = 107,
    kCpModelProbingLevelFieldNumber = 110,
    kMinOrthogonalityForLpConstraintsFieldNumber = 115,
    kShareObjectiveBoundsFieldNumber = 113,
    kShareLevelZeroBoundsFieldNumber = 114,
    kShareBinaryClausesFieldNumber = 203,
    kUseOptimizationHintsFieldNumber = 35,
    kMaxIntegerRoundingScalingFieldNumber = 119,
    kMaxConsecutiveInactiveCountFieldNumber = 121,
    kNewConstraintsBatchSizeFieldNumber = 122,
    kPseudoCostReliabilityThresholdFieldNumber = 123,
    kMipMaxBoundFieldNumber = 124,
    kMipVarScalingFieldNumber = 125,
    kMipWantedPrecisionFieldNumber = 126,
    kMipCheckPrecisionFieldNumber = 128,
    kMipMaxActivityExponentFieldNumber = 127,
    kAddCliqueCutsFieldNumber = 172,
    kAddLinMaxCutsFieldNumber = 152,
    kAddLpConstraintsLazilyFieldNumber = 112,
    kExploitIntegerLpSolutionFieldNumber = 94,
    kMaxPresolveIterationsFieldNumber = 138,
    kUseFeasibilityPumpFieldNumber = 164,
    kUseExactLpReasonFieldNumber = 109,
    kCatchSigintSignalFieldNumber = 135,
    kUseImpliedBoundsFieldNumber = 144,
    kMergeNoOverlapWorkLimitFieldNumber = 145,
    kFeasibilityJumpEnableRestartsFieldNumber = 250,
    kInstantiateAllVariablesFieldNumber = 106,
    kAutoDetectGreaterThanAtLeastOneOfFieldNumber = 95,
    kUseRinsLnsFieldNumber = 129,
    kPresolveSubstitutionLevelFieldNumber = 147,
    kMergeAtMostOneWorkLimitFieldNumber = 146,
    kMaxAllDiffCutSizeFieldNumber = 148,
    kHintConflictLimitFieldNumber = 153,
    kMaxCutRoundsAtLevelZeroFieldNumber = 154,
    kUseDualSchedulingHeuristicsFieldNumber = 214,
    kAddCgCutsFieldNumber = 117,
    kAddMirCutsFieldNumber = 120,
    kAddZeroHalfCutsFieldNumber = 169,
    kCutMaxActiveCountValueFieldNumber = 155,
    kCutActiveCountDecayFieldNumber = 156,
    kAbsoluteGapLimitFieldNumber = 159,
    kCutCleanupTargetFieldNumber = 157,
    kFpRoundingFieldNumber = 165,
    kPolarityRephaseIncrementFieldNumber = 168,
    kExploitAllLpSolutionFieldNumber = 116,
    kExploitObjectiveFieldNumber = 131,
    kUseShavingInProbingSearchFieldNumber = 204,
    kUseFeasibilityJumpFieldNumber = 265,
    kConvertIntervalsFieldNumber = 177,
    kMipAutomaticallyScaleVariablesFieldNumber = 166,
    kMipComputeTrueObjectiveBoundFieldNumber = 198,
    kSymmetryLevelFieldNumber = 183,
    kClauseCleanupRatioFieldNumber = 190,
    kMaxDomainSizeWhenEncodingEqNeqConstraintsFieldNumber = 191,
    kSolutionPoolSizeFieldNumber = 193,
    kMipMaxValidMagnitudeFieldNumber = 199,
    kPresolveInclusionWorkLimitFieldNumber = 201,
    kCutLevelFieldNumber = 196,
    kMinNumLnsWorkersFieldNumber = 211,
    kShavingSearchDeterministicTimeFieldNumber = 205,
    kExpandReservoirConstraintsFieldNumber = 182,
    kIgnoreNamesFieldNumber = 202,
    kInferAllDiffsFieldNumber = 233,
    kFindBigLinearOverlapFieldNumber = 234,
    kTableCompressionLevelFieldNumber = 217,
    kPropagationLoopDetectionFactorFieldNumber = 221,
    kProbingDeterministicTimeLimitFieldNumber = 226,
    kRootLpIterationsFieldNumber = 227,
    kMaxSizeToCreatePrecedenceLiteralsInDisjunctiveFieldNumber = 229,
    kMipDropToleranceFieldNumber = 232,
    kSharedTreeWorkerObjectiveSplitProbabilityFieldNumber = 237,
    kFeasibilityJumpDecayFieldNumber = 242,
    kSharedTreeMaxNodesPerWorkerFieldNumber = 238,
    kViolationLsPerturbationPeriodFieldNumber = 249,
    kFeasibilityJumpVarPerburbationRangeRatioFieldNumber = 248,
    kLinearSplitSizeFieldNumber = 256,
    kFeasibilityJumpLinearizationLevelFieldNumber = 257,
    kViolationLsCompoundMoveProbabilityFieldNumber = 259,
    kFeasibilityJumpRestartFactorFieldNumber = 258,
    kMaxNumIntervalsForTimetableEdgeFindingFieldNumber = 260,
    kMipPresolveLevelFieldNumber = 261,
    kFeasibilityJumpMaxExpandedConstraintSizeFieldNumber = 264,
    kLpPrimalToleranceFieldNumber = 266,
    kLpDualToleranceFieldNumber = 267,
  };
  // repeated .operations_research.sat.SatParameters.RestartAlgorithm restart_algorithms = 61;
  int restart_algorithms_size() const;
  private:
  int _internal_restart_algorithms_size() const;

  public:
  void clear_restart_algorithms() ;
  public:
  ::operations_research::sat::SatParameters_RestartAlgorithm restart_algorithms(int index) const;
  void set_restart_algorithms(int index, ::operations_research::sat::SatParameters_RestartAlgorithm value);
  void add_restart_algorithms(::operations_research::sat::SatParameters_RestartAlgorithm value);
  const ::google::protobuf::RepeatedField<int>& restart_algorithms() const;
  ::google::protobuf::RepeatedField<int>* mutable_restart_algorithms();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_restart_algorithms() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_restart_algorithms();

  public:
  // repeated string subsolvers = 207;
  int subsolvers_size() const;
  private:
  int _internal_subsolvers_size() const;

  public:
  void clear_subsolvers() ;
  const std::string& subsolvers(int index) const;
  std::string* mutable_subsolvers(int index);
  void set_subsolvers(int index, const std::string& value);
  void set_subsolvers(int index, std::string&& value);
  void set_subsolvers(int index, const char* value);
  void set_subsolvers(int index, const char* value, std::size_t size);
  void set_subsolvers(int index, absl::string_view value);
  std::string* add_subsolvers();
  void add_subsolvers(const std::string& value);
  void add_subsolvers(std::string&& value);
  void add_subsolvers(const char* value);
  void add_subsolvers(const char* value, std::size_t size);
  void add_subsolvers(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& subsolvers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_subsolvers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_subsolvers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_subsolvers();

  public:
  // repeated string ignore_subsolvers = 209;
  int ignore_subsolvers_size() const;
  private:
  int _internal_ignore_subsolvers_size() const;

  public:
  void clear_ignore_subsolvers() ;
  const std::string& ignore_subsolvers(int index) const;
  std::string* mutable_ignore_subsolvers(int index);
  void set_ignore_subsolvers(int index, const std::string& value);
  void set_ignore_subsolvers(int index, std::string&& value);
  void set_ignore_subsolvers(int index, const char* value);
  void set_ignore_subsolvers(int index, const char* value, std::size_t size);
  void set_ignore_subsolvers(int index, absl::string_view value);
  std::string* add_ignore_subsolvers();
  void add_ignore_subsolvers(const std::string& value);
  void add_ignore_subsolvers(std::string&& value);
  void add_ignore_subsolvers(const char* value);
  void add_ignore_subsolvers(const char* value, std::size_t size);
  void add_ignore_subsolvers(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& ignore_subsolvers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_ignore_subsolvers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_ignore_subsolvers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_ignore_subsolvers();

  public:
  // repeated .operations_research.sat.SatParameters subsolver_params = 210;
  int subsolver_params_size() const;
  private:
  int _internal_subsolver_params_size() const;

  public:
  void clear_subsolver_params() ;
  ::operations_research::sat::SatParameters* mutable_subsolver_params(int index);
  ::google::protobuf::RepeatedPtrField< ::operations_research::sat::SatParameters >*
      mutable_subsolver_params();
  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::SatParameters>& _internal_subsolver_params() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::SatParameters>* _internal_mutable_subsolver_params();
  public:
  const ::operations_research::sat::SatParameters& subsolver_params(int index) const;
  ::operations_research::sat::SatParameters* add_subsolver_params();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::sat::SatParameters >&
      subsolver_params() const;
  // repeated string extra_subsolvers = 219;
  int extra_subsolvers_size() const;
  private:
  int _internal_extra_subsolvers_size() const;

  public:
  void clear_extra_subsolvers() ;
  const std::string& extra_subsolvers(int index) const;
  std::string* mutable_extra_subsolvers(int index);
  void set_extra_subsolvers(int index, const std::string& value);
  void set_extra_subsolvers(int index, std::string&& value);
  void set_extra_subsolvers(int index, const char* value);
  void set_extra_subsolvers(int index, const char* value, std::size_t size);
  void set_extra_subsolvers(int index, absl::string_view value);
  std::string* add_extra_subsolvers();
  void add_extra_subsolvers(const std::string& value);
  void add_extra_subsolvers(std::string&& value);
  void add_extra_subsolvers(const char* value);
  void add_extra_subsolvers(const char* value, std::size_t size);
  void add_extra_subsolvers(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& extra_subsolvers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_extra_subsolvers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_extra_subsolvers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_extra_subsolvers();

  public:
  // optional string default_restart_algorithms = 70 [default = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"];
  bool has_default_restart_algorithms() const;
  void clear_default_restart_algorithms() ;
  const std::string& default_restart_algorithms() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_restart_algorithms(Arg_&& arg, Args_... args);
  std::string* mutable_default_restart_algorithms();
  PROTOBUF_NODISCARD std::string* release_default_restart_algorithms();
  void set_allocated_default_restart_algorithms(std::string* value);

  private:
  const std::string& _internal_default_restart_algorithms() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_restart_algorithms(
      const std::string& value);
  std::string* _internal_mutable_default_restart_algorithms();

  public:
  // optional string name = 171 [default = ""];
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string log_prefix = 185 [default = ""];
  bool has_log_prefix() const;
  void clear_log_prefix() ;
  const std::string& log_prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_log_prefix();
  PROTOBUF_NODISCARD std::string* release_log_prefix();
  void set_allocated_log_prefix(std::string* value);

  private:
  const std::string& _internal_log_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_prefix(
      const std::string& value);
  std::string* _internal_mutable_log_prefix();

  public:
  // optional .operations_research.sat.SatParameters.VariableOrder preferred_variable_order = 1 [default = IN_ORDER];
  bool has_preferred_variable_order() const;
  void clear_preferred_variable_order() ;
  ::operations_research::sat::SatParameters_VariableOrder preferred_variable_order() const;
  void set_preferred_variable_order(::operations_research::sat::SatParameters_VariableOrder value);

  private:
  ::operations_research::sat::SatParameters_VariableOrder _internal_preferred_variable_order() const;
  void _internal_set_preferred_variable_order(::operations_research::sat::SatParameters_VariableOrder value);

  public:
  // optional int32 clause_cleanup_target = 13 [default = 0];
  bool has_clause_cleanup_target() const;
  void clear_clause_cleanup_target() ;
  ::int32_t clause_cleanup_target() const;
  void set_clause_cleanup_target(::int32_t value);

  private:
  ::int32_t _internal_clause_cleanup_target() const;
  void _internal_set_clause_cleanup_target(::int32_t value);

  public:
  // optional double random_branches_ratio = 32 [default = 0];
  bool has_random_branches_ratio() const;
  void clear_random_branches_ratio() ;
  double random_branches_ratio() const;
  void set_random_branches_ratio(double value);

  private:
  double _internal_random_branches_ratio() const;
  void _internal_set_random_branches_ratio(double value);

  public:
  // optional double random_polarity_ratio = 45 [default = 0];
  bool has_random_polarity_ratio() const;
  void clear_random_polarity_ratio() ;
  double random_polarity_ratio() const;
  void set_random_polarity_ratio(double value);

  private:
  double _internal_random_polarity_ratio() const;
  void _internal_set_random_polarity_ratio(double value);

  public:
  // optional .operations_research.sat.SatParameters.MaxSatAssumptionOrder max_sat_assumption_order = 51 [default = DEFAULT_ASSUMPTION_ORDER];
  bool has_max_sat_assumption_order() const;
  void clear_max_sat_assumption_order() ;
  ::operations_research::sat::SatParameters_MaxSatAssumptionOrder max_sat_assumption_order() const;
  void set_max_sat_assumption_order(::operations_research::sat::SatParameters_MaxSatAssumptionOrder value);

  private:
  ::operations_research::sat::SatParameters_MaxSatAssumptionOrder _internal_max_sat_assumption_order() const;
  void _internal_set_max_sat_assumption_order(::operations_research::sat::SatParameters_MaxSatAssumptionOrder value);

  public:
  // optional .operations_research.sat.SatParameters.ClauseProtection clause_cleanup_protection = 58 [default = PROTECTION_NONE];
  bool has_clause_cleanup_protection() const;
  void clear_clause_cleanup_protection() ;
  ::operations_research::sat::SatParameters_ClauseProtection clause_cleanup_protection() const;
  void set_clause_cleanup_protection(::operations_research::sat::SatParameters_ClauseProtection value);

  private:
  ::operations_research::sat::SatParameters_ClauseProtection _internal_clause_cleanup_protection() const;
  void _internal_set_clause_cleanup_protection(::operations_research::sat::SatParameters_ClauseProtection value);

  public:
  // optional .operations_research.sat.SatParameters.ClauseOrdering clause_cleanup_ordering = 60 [default = CLAUSE_ACTIVITY];
  bool has_clause_cleanup_ordering() const;
  void clear_clause_cleanup_ordering() ;
  ::operations_research::sat::SatParameters_ClauseOrdering clause_cleanup_ordering() const;
  void set_clause_cleanup_ordering(::operations_research::sat::SatParameters_ClauseOrdering value);

  private:
  ::operations_research::sat::SatParameters_ClauseOrdering _internal_clause_cleanup_ordering() const;
  void _internal_set_clause_cleanup_ordering(::operations_research::sat::SatParameters_ClauseOrdering value);

  public:
  // optional int32 num_conflicts_before_strategy_changes = 68 [default = 0];
  bool has_num_conflicts_before_strategy_changes() const;
  void clear_num_conflicts_before_strategy_changes() ;
  ::int32_t num_conflicts_before_strategy_changes() const;
  void set_num_conflicts_before_strategy_changes(::int32_t value);

  private:
  ::int32_t _internal_num_conflicts_before_strategy_changes() const;
  void _internal_set_num_conflicts_before_strategy_changes(::int32_t value);

  public:
  // optional double strategy_change_increase_ratio = 69 [default = 0];
  bool has_strategy_change_increase_ratio() const;
  void clear_strategy_change_increase_ratio() ;
  double strategy_change_increase_ratio() const;
  void set_strategy_change_increase_ratio(double value);

  private:
  double _internal_strategy_change_increase_ratio() const;
  void _internal_set_strategy_change_increase_ratio(double value);

  public:
  // optional double initial_variables_activity = 76 [default = 0];
  bool has_initial_variables_activity() const;
  void clear_initial_variables_activity() ;
  double initial_variables_activity() const;
  void set_initial_variables_activity(double value);

  private:
  double _internal_initial_variables_activity() const;
  void _internal_set_initial_variables_activity(double value);

  public:
  // optional .operations_research.sat.SatParameters.SearchBranching search_branching = 82 [default = AUTOMATIC_SEARCH];
  bool has_search_branching() const;
  void clear_search_branching() ;
  ::operations_research::sat::SatParameters_SearchBranching search_branching() const;
  void set_search_branching(::operations_research::sat::SatParameters_SearchBranching value);

  private:
  ::operations_research::sat::SatParameters_SearchBranching _internal_search_branching() const;
  void _internal_set_search_branching(::operations_research::sat::SatParameters_SearchBranching value);

  public:
  // optional bool use_erwa_heuristic = 75 [default = false];
  bool has_use_erwa_heuristic() const;
  void clear_use_erwa_heuristic() ;
  bool use_erwa_heuristic() const;
  void set_use_erwa_heuristic(bool value);

  private:
  bool _internal_use_erwa_heuristic() const;
  void _internal_set_use_erwa_heuristic(bool value);

  public:
  // optional bool also_bump_variables_in_conflict_reasons = 77 [default = false];
  bool has_also_bump_variables_in_conflict_reasons() const;
  void clear_also_bump_variables_in_conflict_reasons() ;
  bool also_bump_variables_in_conflict_reasons() const;
  void set_also_bump_variables_in_conflict_reasons(bool value);

  private:
  bool _internal_also_bump_variables_in_conflict_reasons() const;
  void _internal_set_also_bump_variables_in_conflict_reasons(bool value);

  public:
  // optional bool use_blocking_restart = 64 [default = false];
  bool has_use_blocking_restart() const;
  void clear_use_blocking_restart() ;
  bool use_blocking_restart() const;
  void set_use_blocking_restart(bool value);

  private:
  bool _internal_use_blocking_restart() const;
  void _internal_set_use_blocking_restart(bool value);

  public:
  // optional bool permute_variable_randomly = 178 [default = false];
  bool has_permute_variable_randomly() const;
  void clear_permute_variable_randomly() ;
  bool permute_variable_randomly() const;
  void set_permute_variable_randomly(bool value);

  private:
  bool _internal_permute_variable_randomly() const;
  void _internal_set_permute_variable_randomly(bool value);

  public:
  // optional int64 search_random_variable_pool_size = 104 [default = 0];
  bool has_search_random_variable_pool_size() const;
  void clear_search_random_variable_pool_size() ;
  ::int64_t search_random_variable_pool_size() const;
  void set_search_random_variable_pool_size(::int64_t value);

  private:
  ::int64_t _internal_search_random_variable_pool_size() const;
  void _internal_set_search_random_variable_pool_size(::int64_t value);

  public:
  // optional int32 num_search_workers = 100 [default = 0];
  bool has_num_search_workers() const;
  void clear_num_search_workers() ;
  ::int32_t num_search_workers() const;
  void set_num_search_workers(::int32_t value);

  private:
  ::int32_t _internal_num_search_workers() const;
  void _internal_set_num_search_workers(::int32_t value);

  public:
  // optional bool log_to_response = 187 [default = false];
  bool has_log_to_response() const;
  void clear_log_to_response() ;
  bool log_to_response() const;
  void set_log_to_response(bool value);

  private:
  bool _internal_log_to_response() const;
  void _internal_set_log_to_response(bool value);

  public:
  // optional bool use_pb_resolution = 43 [default = false];
  bool has_use_pb_resolution() const;
  void clear_use_pb_resolution() ;
  bool use_pb_resolution() const;
  void set_use_pb_resolution(bool value);

  private:
  bool _internal_use_pb_resolution() const;
  void _internal_set_use_pb_resolution(bool value);

  public:
  // optional bool minimize_reduction_during_pb_resolution = 48 [default = false];
  bool has_minimize_reduction_during_pb_resolution() const;
  void clear_minimize_reduction_during_pb_resolution() ;
  bool minimize_reduction_during_pb_resolution() const;
  void set_minimize_reduction_during_pb_resolution(bool value);

  private:
  bool _internal_minimize_reduction_during_pb_resolution() const;
  void _internal_set_minimize_reduction_during_pb_resolution(bool value);

  public:
  // optional bool use_sat_inprocessing = 163 [default = false];
  bool has_use_sat_inprocessing() const;
  void clear_use_sat_inprocessing() ;
  bool use_sat_inprocessing() const;
  void set_use_sat_inprocessing(bool value);

  private:
  bool _internal_use_sat_inprocessing() const;
  void _internal_set_use_sat_inprocessing(bool value);

  public:
  // optional int64 probing_period_at_root = 142 [default = 0];
  bool has_probing_period_at_root() const;
  void clear_probing_period_at_root() ;
  ::int64_t probing_period_at_root() const;
  void set_probing_period_at_root(::int64_t value);

  private:
  ::int64_t _internal_probing_period_at_root() const;
  void _internal_set_probing_period_at_root(::int64_t value);

  public:
  // optional int32 interleave_batch_size = 134 [default = 0];
  bool has_interleave_batch_size() const;
  void clear_interleave_batch_size() ;
  ::int32_t interleave_batch_size() const;
  void set_interleave_batch_size(::int32_t value);

  private:
  ::int32_t _internal_interleave_batch_size() const;
  void _internal_set_interleave_batch_size(::int32_t value);

  public:
  // optional bool permute_presolve_constraint_order = 179 [default = false];
  bool has_permute_presolve_constraint_order() const;
  void clear_permute_presolve_constraint_order() ;
  bool permute_presolve_constraint_order() const;
  void set_permute_presolve_constraint_order(bool value);

  private:
  bool _internal_permute_presolve_constraint_order() const;
  void _internal_set_permute_presolve_constraint_order(bool value);

  public:
  // optional bool use_absl_random = 180 [default = false];
  bool has_use_absl_random() const;
  void clear_use_absl_random() ;
  bool use_absl_random() const;
  void set_use_absl_random(bool value);

  private:
  bool _internal_use_absl_random() const;
  void _internal_set_use_absl_random(bool value);

  public:
  // optional bool log_search_progress = 41 [default = false];
  bool has_log_search_progress() const;
  void clear_log_search_progress() ;
  bool log_search_progress() const;
  void set_log_search_progress(bool value);

  private:
  bool _internal_log_search_progress() const;
  void _internal_set_log_search_progress(bool value);

  public:
  // optional bool log_subsolver_statistics = 189 [default = false];
  bool has_log_subsolver_statistics() const;
  void clear_log_subsolver_statistics() ;
  bool log_subsolver_statistics() const;
  void set_log_subsolver_statistics(bool value);

  private:
  bool _internal_log_subsolver_statistics() const;
  void _internal_set_log_subsolver_statistics(bool value);

  public:
  // optional bool use_overload_checker_in_cumulative = 78 [default = false];
  bool has_use_overload_checker_in_cumulative() const;
  void clear_use_overload_checker_in_cumulative() ;
  bool use_overload_checker_in_cumulative() const;
  void set_use_overload_checker_in_cumulative(bool value);

  private:
  bool _internal_use_overload_checker_in_cumulative() const;
  void _internal_set_use_overload_checker_in_cumulative(bool value);

  public:
  // optional bool use_timetable_edge_finding_in_cumulative = 79 [default = false];
  bool has_use_timetable_edge_finding_in_cumulative() const;
  void clear_use_timetable_edge_finding_in_cumulative() ;
  bool use_timetable_edge_finding_in_cumulative() const;
  void set_use_timetable_edge_finding_in_cumulative(bool value);

  private:
  bool _internal_use_timetable_edge_finding_in_cumulative() const;
  void _internal_set_use_timetable_edge_finding_in_cumulative(bool value);

  public:
  // optional bool use_hard_precedences_in_cumulative = 215 [default = false];
  bool has_use_hard_precedences_in_cumulative() const;
  void clear_use_hard_precedences_in_cumulative() ;
  bool use_hard_precedences_in_cumulative() const;
  void set_use_hard_precedences_in_cumulative(bool value);

  private:
  bool _internal_use_hard_precedences_in_cumulative() const;
  void _internal_set_use_hard_precedences_in_cumulative(bool value);

  public:
  // optional bool exploit_all_precedences = 220 [default = false];
  bool has_exploit_all_precedences() const;
  void clear_exploit_all_precedences() ;
  bool exploit_all_precedences() const;
  void set_exploit_all_precedences(bool value);

  private:
  bool _internal_exploit_all_precedences() const;
  void _internal_set_exploit_all_precedences(bool value);

  public:
  // optional bool optimize_with_core = 83 [default = false];
  bool has_optimize_with_core() const;
  void clear_optimize_with_core() ;
  bool optimize_with_core() const;
  void set_optimize_with_core(bool value);

  private:
  bool _internal_optimize_with_core() const;
  void _internal_set_optimize_with_core(bool value);

  public:
  // optional bool optimize_with_lb_tree_search = 188 [default = false];
  bool has_optimize_with_lb_tree_search() const;
  void clear_optimize_with_lb_tree_search() ;
  bool optimize_with_lb_tree_search() const;
  void set_optimize_with_lb_tree_search(bool value);

  private:
  bool _internal_optimize_with_lb_tree_search() const;
  void _internal_set_optimize_with_lb_tree_search(bool value);

  public:
  // optional bool optimize_with_max_hs = 85 [default = false];
  bool has_optimize_with_max_hs() const;
  void clear_optimize_with_max_hs() ;
  bool optimize_with_max_hs() const;
  void set_optimize_with_max_hs(bool value);

  private:
  bool _internal_optimize_with_max_hs() const;
  void _internal_set_optimize_with_max_hs(bool value);

  public:
  // optional bool test_feasibility_jump = 240 [default = false];
  bool has_test_feasibility_jump() const;
  void clear_test_feasibility_jump() ;
  bool test_feasibility_jump() const;
  void set_test_feasibility_jump(bool value);

  private:
  bool _internal_test_feasibility_jump() const;
  void _internal_set_test_feasibility_jump(bool value);

  public:
  // optional bool use_lns_only = 101 [default = false];
  bool has_use_lns_only() const;
  void clear_use_lns_only() ;
  bool use_lns_only() const;
  void set_use_lns_only(bool value);

  private:
  bool _internal_use_lns_only() const;
  void _internal_set_use_lns_only(bool value);

  public:
  // optional bool use_lb_relax_lns = 255 [default = false];
  bool has_use_lb_relax_lns() const;
  void clear_use_lb_relax_lns() ;
  bool use_lb_relax_lns() const;
  void set_use_lb_relax_lns(bool value);

  private:
  bool _internal_use_lb_relax_lns() const;
  void _internal_set_use_lb_relax_lns(bool value);

  public:
  // optional bool diversify_lns_params = 137 [default = false];
  bool has_diversify_lns_params() const;
  void clear_diversify_lns_params() ;
  bool diversify_lns_params() const;
  void set_diversify_lns_params(bool value);

  private:
  bool _internal_diversify_lns_params() const;
  void _internal_set_diversify_lns_params(bool value);

  public:
  // optional bool randomize_search = 103 [default = false];
  bool has_randomize_search() const;
  void clear_randomize_search() ;
  bool randomize_search() const;
  void set_randomize_search(bool value);

  private:
  bool _internal_randomize_search() const;
  void _internal_set_randomize_search(bool value);

  public:
  // optional int32 debug_max_num_presolve_operations = 151 [default = 0];
  bool has_debug_max_num_presolve_operations() const;
  void clear_debug_max_num_presolve_operations() ;
  ::int32_t debug_max_num_presolve_operations() const;
  void set_debug_max_num_presolve_operations(::int32_t value);

  private:
  ::int32_t _internal_debug_max_num_presolve_operations() const;
  void _internal_set_debug_max_num_presolve_operations(::int32_t value);

  public:
  // optional bool use_shared_tree_search = 236 [default = false];
  bool has_use_shared_tree_search() const;
  void clear_use_shared_tree_search() ;
  bool use_shared_tree_search() const;
  void set_use_shared_tree_search(bool value);

  private:
  bool _internal_use_shared_tree_search() const;
  void _internal_set_use_shared_tree_search(bool value);

  public:
  // optional bool enumerate_all_solutions = 87 [default = false];
  bool has_enumerate_all_solutions() const;
  void clear_enumerate_all_solutions() ;
  bool enumerate_all_solutions() const;
  void set_enumerate_all_solutions(bool value);

  private:
  bool _internal_enumerate_all_solutions() const;
  void _internal_set_enumerate_all_solutions(bool value);

  public:
  // optional bool keep_all_feasible_solutions_in_presolve = 173 [default = false];
  bool has_keep_all_feasible_solutions_in_presolve() const;
  void clear_keep_all_feasible_solutions_in_presolve() ;
  bool keep_all_feasible_solutions_in_presolve() const;
  void set_keep_all_feasible_solutions_in_presolve(bool value);

  private:
  bool _internal_keep_all_feasible_solutions_in_presolve() const;
  void _internal_set_keep_all_feasible_solutions_in_presolve(bool value);

  public:
  // optional bool fill_tightened_domains_in_response = 132 [default = false];
  bool has_fill_tightened_domains_in_response() const;
  void clear_fill_tightened_domains_in_response() ;
  bool fill_tightened_domains_in_response() const;
  void set_fill_tightened_domains_in_response(bool value);

  private:
  bool _internal_fill_tightened_domains_in_response() const;
  void _internal_set_fill_tightened_domains_in_response(bool value);

  public:
  // optional bool push_all_tasks_toward_start = 262 [default = false];
  bool has_push_all_tasks_toward_start() const;
  void clear_push_all_tasks_toward_start() ;
  bool push_all_tasks_toward_start() const;
  void set_push_all_tasks_toward_start(bool value);

  private:
  bool _internal_push_all_tasks_toward_start() const;
  void _internal_set_push_all_tasks_toward_start(bool value);

  public:
  // optional bool use_optional_variables = 108 [default = false];
  bool has_use_optional_variables() const;
  void clear_use_optional_variables() ;
  bool use_optional_variables() const;
  void set_use_optional_variables(bool value);

  private:
  bool _internal_use_optional_variables() const;
  void _internal_set_use_optional_variables(bool value);

  public:
  // optional bool use_branching_in_lp = 139 [default = false];
  bool has_use_branching_in_lp() const;
  void clear_use_branching_in_lp() ;
  bool use_branching_in_lp() const;
  void set_use_branching_in_lp(bool value);

  private:
  bool _internal_use_branching_in_lp() const;
  void _internal_set_use_branching_in_lp(bool value);

  public:
  // optional bool use_combined_no_overlap = 133 [default = false];
  bool has_use_combined_no_overlap() const;
  void clear_use_combined_no_overlap() ;
  bool use_combined_no_overlap() const;
  void set_use_combined_no_overlap(bool value);

  private:
  bool _internal_use_combined_no_overlap() const;
  void _internal_set_use_combined_no_overlap(bool value);

  public:
  // optional double relative_gap_limit = 160 [default = 0];
  bool has_relative_gap_limit() const;
  void clear_relative_gap_limit() ;
  double relative_gap_limit() const;
  void set_relative_gap_limit(double value);

  private:
  double _internal_relative_gap_limit() const;
  void _internal_set_relative_gap_limit(double value);

  public:
  // optional bool presolve_extract_integer_enforcement = 174 [default = false];
  bool has_presolve_extract_integer_enforcement() const;
  void clear_presolve_extract_integer_enforcement() ;
  bool presolve_extract_integer_enforcement() const;
  void set_presolve_extract_integer_enforcement(bool value);

  private:
  bool _internal_presolve_extract_integer_enforcement() const;
  void _internal_set_presolve_extract_integer_enforcement(bool value);

  public:
  // optional bool interleave_search = 136 [default = false];
  bool has_interleave_search() const;
  void clear_interleave_search() ;
  bool interleave_search() const;
  void set_interleave_search(bool value);

  private:
  bool _internal_interleave_search() const;
  void _internal_set_interleave_search(bool value);

  public:
  // optional bool debug_postsolve_with_full_solver = 162 [default = false];
  bool has_debug_postsolve_with_full_solver() const;
  void clear_debug_postsolve_with_full_solver() ;
  bool debug_postsolve_with_full_solver() const;
  void set_debug_postsolve_with_full_solver(bool value);

  private:
  bool _internal_debug_postsolve_with_full_solver() const;
  void _internal_set_debug_postsolve_with_full_solver(bool value);

  public:
  // optional bool debug_crash_on_bad_hint = 195 [default = false];
  bool has_debug_crash_on_bad_hint() const;
  void clear_debug_crash_on_bad_hint() ;
  bool debug_crash_on_bad_hint() const;
  void set_debug_crash_on_bad_hint(bool value);

  private:
  bool _internal_debug_crash_on_bad_hint() const;
  void _internal_set_debug_crash_on_bad_hint(bool value);

  public:
  // optional bool add_objective_cut = 197 [default = false];
  bool has_add_objective_cut() const;
  void clear_add_objective_cut() ;
  bool add_objective_cut() const;
  void set_add_objective_cut(bool value);

  private:
  bool _internal_add_objective_cut() const;
  void _internal_set_add_objective_cut(bool value);

  public:
  // optional bool repair_hint = 167 [default = false];
  bool has_repair_hint() const;
  void clear_repair_hint() ;
  bool repair_hint() const;
  void set_repair_hint(bool value);

  private:
  bool _internal_repair_hint() const;
  void _internal_set_repair_hint(bool value);

  public:
  // optional bool fix_variables_to_their_hinted_value = 192 [default = false];
  bool has_fix_variables_to_their_hinted_value() const;
  void clear_fix_variables_to_their_hinted_value() ;
  bool fix_variables_to_their_hinted_value() const;
  void set_fix_variables_to_their_hinted_value(bool value);

  private:
  bool _internal_fix_variables_to_their_hinted_value() const;
  void _internal_set_fix_variables_to_their_hinted_value(bool value);

  public:
  // optional bool exploit_best_solution = 130 [default = false];
  bool has_exploit_best_solution() const;
  void clear_exploit_best_solution() ;
  bool exploit_best_solution() const;
  void set_exploit_best_solution(bool value);

  private:
  bool _internal_exploit_best_solution() const;
  void _internal_set_exploit_best_solution(bool value);

  public:
  // optional bool fill_additional_solutions_in_response = 194 [default = false];
  bool has_fill_additional_solutions_in_response() const;
  void clear_fill_additional_solutions_in_response() ;
  bool fill_additional_solutions_in_response() const;
  void set_fill_additional_solutions_in_response(bool value);

  private:
  bool _internal_fill_additional_solutions_in_response() const;
  void _internal_set_fill_additional_solutions_in_response(bool value);

  public:
  // optional bool stop_after_first_solution = 98 [default = false];
  bool has_stop_after_first_solution() const;
  void clear_stop_after_first_solution() ;
  bool stop_after_first_solution() const;
  void set_stop_after_first_solution(bool value);

  private:
  bool _internal_stop_after_first_solution() const;
  void _internal_set_stop_after_first_solution(bool value);

  public:
  // optional bool stop_after_presolve = 149 [default = false];
  bool has_stop_after_presolve() const;
  void clear_stop_after_presolve() ;
  bool stop_after_presolve() const;
  void set_stop_after_presolve(bool value);

  private:
  bool _internal_stop_after_presolve() const;
  void _internal_set_stop_after_presolve(bool value);

  public:
  // optional bool stop_after_root_propagation = 252 [default = false];
  bool has_stop_after_root_propagation() const;
  void clear_stop_after_root_propagation() ;
  bool stop_after_root_propagation() const;
  void set_stop_after_root_propagation(bool value);

  private:
  bool _internal_stop_after_root_propagation() const;
  void _internal_set_stop_after_root_propagation(bool value);

  public:
  // optional bool use_timetabling_in_no_overlap_2d = 200 [default = false];
  bool has_use_timetabling_in_no_overlap_2d() const;
  void clear_use_timetabling_in_no_overlap_2d() ;
  bool use_timetabling_in_no_overlap_2d() const;
  void set_use_timetabling_in_no_overlap_2d(bool value);

  private:
  bool _internal_use_timetabling_in_no_overlap_2d() const;
  void _internal_set_use_timetabling_in_no_overlap_2d(bool value);

  public:
  // optional bool use_energetic_reasoning_in_no_overlap_2d = 213 [default = false];
  bool has_use_energetic_reasoning_in_no_overlap_2d() const;
  void clear_use_energetic_reasoning_in_no_overlap_2d() ;
  bool use_energetic_reasoning_in_no_overlap_2d() const;
  void set_use_energetic_reasoning_in_no_overlap_2d(bool value);

  private:
  bool _internal_use_energetic_reasoning_in_no_overlap_2d() const;
  void _internal_set_use_energetic_reasoning_in_no_overlap_2d(bool value);

  public:
  // optional bool use_pairwise_reasoning_in_no_overlap_2d = 251 [default = false];
  bool has_use_pairwise_reasoning_in_no_overlap_2d() const;
  void clear_use_pairwise_reasoning_in_no_overlap_2d() ;
  bool use_pairwise_reasoning_in_no_overlap_2d() const;
  void set_use_pairwise_reasoning_in_no_overlap_2d(bool value);

  private:
  bool _internal_use_pairwise_reasoning_in_no_overlap_2d() const;
  void _internal_set_use_pairwise_reasoning_in_no_overlap_2d(bool value);

  public:
  // optional bool only_add_cuts_at_level_zero = 92 [default = false];
  bool has_only_add_cuts_at_level_zero() const;
  void clear_only_add_cuts_at_level_zero() ;
  bool only_add_cuts_at_level_zero() const;
  void set_only_add_cuts_at_level_zero(bool value);

  private:
  bool _internal_only_add_cuts_at_level_zero() const;
  void _internal_set_only_add_cuts_at_level_zero(bool value);

  public:
  // optional bool detect_table_with_cost = 216 [default = false];
  bool has_detect_table_with_cost() const;
  void clear_detect_table_with_cost() ;
  bool detect_table_with_cost() const;
  void set_detect_table_with_cost(bool value);

  private:
  bool _internal_detect_table_with_cost() const;
  void _internal_set_detect_table_with_cost(bool value);

  public:
  // optional bool expand_alldiff_constraints = 170 [default = false];
  bool has_expand_alldiff_constraints() const;
  void clear_expand_alldiff_constraints() ;
  bool expand_alldiff_constraints() const;
  void set_expand_alldiff_constraints(bool value);

  private:
  bool _internal_expand_alldiff_constraints() const;
  void _internal_set_expand_alldiff_constraints(bool value);

  public:
  // optional bool disable_constraint_expansion = 181 [default = false];
  bool has_disable_constraint_expansion() const;
  void clear_disable_constraint_expansion() ;
  bool disable_constraint_expansion() const;
  void set_disable_constraint_expansion(bool value);

  private:
  bool _internal_disable_constraint_expansion() const;
  void _internal_set_disable_constraint_expansion(bool value);

  public:
  // optional bool encode_complex_linear_constraint_with_integer = 223 [default = false];
  bool has_encode_complex_linear_constraint_with_integer() const;
  void clear_encode_complex_linear_constraint_with_integer() ;
  bool encode_complex_linear_constraint_with_integer() const;
  void set_encode_complex_linear_constraint_with_integer(bool value);

  private:
  bool _internal_encode_complex_linear_constraint_with_integer() const;
  void _internal_set_encode_complex_linear_constraint_with_integer(bool value);

  public:
  // optional bool max_sat_reverse_assumption_order = 52 [default = false];
  bool has_max_sat_reverse_assumption_order() const;
  void clear_max_sat_reverse_assumption_order() ;
  bool max_sat_reverse_assumption_order() const;
  void set_max_sat_reverse_assumption_order(bool value);

  private:
  bool _internal_max_sat_reverse_assumption_order() const;
  void _internal_set_max_sat_reverse_assumption_order(bool value);

  public:
  // optional bool use_strong_propagation_in_disjunctive = 230 [default = false];
  bool has_use_strong_propagation_in_disjunctive() const;
  void clear_use_strong_propagation_in_disjunctive() ;
  bool use_strong_propagation_in_disjunctive() const;
  void set_use_strong_propagation_in_disjunctive(bool value);

  private:
  bool _internal_use_strong_propagation_in_disjunctive() const;
  void _internal_set_use_strong_propagation_in_disjunctive(bool value);

  public:
  // optional bool use_dynamic_precedence_in_disjunctive = 263 [default = false];
  bool has_use_dynamic_precedence_in_disjunctive() const;
  void clear_use_dynamic_precedence_in_disjunctive() ;
  bool use_dynamic_precedence_in_disjunctive() const;
  void set_use_dynamic_precedence_in_disjunctive(bool value);

  private:
  bool _internal_use_dynamic_precedence_in_disjunctive() const;
  void _internal_set_use_dynamic_precedence_in_disjunctive(bool value);

  public:
  // optional bool use_dynamic_precedence_in_cumulative = 268 [default = false];
  bool has_use_dynamic_precedence_in_cumulative() const;
  void clear_use_dynamic_precedence_in_cumulative() ;
  bool use_dynamic_precedence_in_cumulative() const;
  void set_use_dynamic_precedence_in_cumulative(bool value);

  private:
  bool _internal_use_dynamic_precedence_in_cumulative() const;
  void _internal_set_use_dynamic_precedence_in_cumulative(bool value);

  public:
  // optional bool exploit_relaxation_solution = 161 [default = false];
  bool has_exploit_relaxation_solution() const;
  void clear_exploit_relaxation_solution() ;
  bool exploit_relaxation_solution() const;
  void set_exploit_relaxation_solution(bool value);

  private:
  bool _internal_exploit_relaxation_solution() const;
  void _internal_set_exploit_relaxation_solution(bool value);

  public:
  // optional bool use_probing_search = 176 [default = false];
  bool has_use_probing_search() const;
  void clear_use_probing_search() ;
  bool use_probing_search() const;
  void set_use_probing_search(bool value);

  private:
  bool _internal_use_probing_search() const;
  void _internal_set_use_probing_search(bool value);

  public:
  // optional bool use_objective_lb_search = 228 [default = false];
  bool has_use_objective_lb_search() const;
  void clear_use_objective_lb_search() ;
  bool use_objective_lb_search() const;
  void set_use_objective_lb_search(bool value);

  private:
  bool _internal_use_objective_lb_search() const;
  void _internal_set_use_objective_lb_search(bool value);

  public:
  // optional bool use_objective_shaving_search = 253 [default = false];
  bool has_use_objective_shaving_search() const;
  void clear_use_objective_shaving_search() ;
  bool use_objective_shaving_search() const;
  void set_use_objective_shaving_search(bool value);

  private:
  bool _internal_use_objective_shaving_search() const;
  void _internal_set_use_objective_shaving_search(bool value);

  public:
  // optional int32 num_workers = 206 [default = 0];
  bool has_num_workers() const;
  void clear_num_workers() ;
  ::int32_t num_workers() const;
  void set_num_workers(::int32_t value);

  private:
  ::int32_t _internal_num_workers() const;
  void _internal_set_num_workers(::int32_t value);

  public:
  // optional bool polish_lp_solution = 175 [default = false];
  bool has_polish_lp_solution() const;
  void clear_polish_lp_solution() ;
  bool polish_lp_solution() const;
  void set_polish_lp_solution(bool value);

  private:
  bool _internal_polish_lp_solution() const;
  void _internal_set_polish_lp_solution(bool value);

  public:
  // optional bool new_linear_propagation = 224 [default = false];
  bool has_new_linear_propagation() const;
  void clear_new_linear_propagation() ;
  bool new_linear_propagation() const;
  void set_new_linear_propagation(bool value);

  private:
  bool _internal_new_linear_propagation() const;
  void _internal_set_new_linear_propagation(bool value);

  public:
  // optional bool mip_scale_large_domain = 225 [default = false];
  bool has_mip_scale_large_domain() const;
  void clear_mip_scale_large_domain() ;
  bool mip_scale_large_domain() const;
  void set_mip_scale_large_domain(bool value);

  private:
  bool _internal_mip_scale_large_domain() const;
  void _internal_set_mip_scale_large_domain(bool value);

  public:
  // optional bool only_solve_ip = 222 [default = false];
  bool has_only_solve_ip() const;
  void clear_only_solve_ip() ;
  bool only_solve_ip() const;
  void set_only_solve_ip(bool value);

  private:
  bool _internal_only_solve_ip() const;
  void _internal_set_only_solve_ip(bool value);

  public:
  // optional int32 shared_tree_num_workers = 235 [default = 0];
  bool has_shared_tree_num_workers() const;
  void clear_shared_tree_num_workers() ;
  ::int32_t shared_tree_num_workers() const;
  void set_shared_tree_num_workers(::int32_t value);

  private:
  ::int32_t _internal_shared_tree_num_workers() const;
  void _internal_set_shared_tree_num_workers(::int32_t value);

  public:
  // optional .operations_research.sat.SatParameters.SharedTreeSplitStrategy shared_tree_split_strategy = 239 [default = SPLIT_STRATEGY_AUTO];
  bool has_shared_tree_split_strategy() const;
  void clear_shared_tree_split_strategy() ;
  ::operations_research::sat::SatParameters_SharedTreeSplitStrategy shared_tree_split_strategy() const;
  void set_shared_tree_split_strategy(::operations_research::sat::SatParameters_SharedTreeSplitStrategy value);

  private:
  ::operations_research::sat::SatParameters_SharedTreeSplitStrategy _internal_shared_tree_split_strategy() const;
  void _internal_set_shared_tree_split_strategy(::operations_research::sat::SatParameters_SharedTreeSplitStrategy value);

  public:
  // optional int32 num_violation_ls = 244 [default = 0];
  bool has_num_violation_ls() const;
  void clear_num_violation_ls() ;
  ::int32_t num_violation_ls() const;
  void set_num_violation_ls(::int32_t value);

  private:
  ::int32_t _internal_num_violation_ls() const;
  void _internal_set_num_violation_ls(::int32_t value);

  public:
  // optional double feasibility_jump_var_randomization_probability = 247 [default = 0];
  bool has_feasibility_jump_var_randomization_probability() const;
  void clear_feasibility_jump_var_randomization_probability() ;
  double feasibility_jump_var_randomization_probability() const;
  void set_feasibility_jump_var_randomization_probability(double value);

  private:
  double _internal_feasibility_jump_var_randomization_probability() const;
  void _internal_set_feasibility_jump_var_randomization_probability(double value);

  public:
  // optional .operations_research.sat.SatParameters.Polarity initial_polarity = 2 [default = POLARITY_FALSE];
  bool has_initial_polarity() const;
  void clear_initial_polarity() ;
  ::operations_research::sat::SatParameters_Polarity initial_polarity() const;
  void set_initial_polarity(::operations_research::sat::SatParameters_Polarity value);

  private:
  ::operations_research::sat::SatParameters_Polarity _internal_initial_polarity() const;
  void _internal_set_initial_polarity(::operations_research::sat::SatParameters_Polarity value);

  public:
  // optional .operations_research.sat.SatParameters.ConflictMinimizationAlgorithm minimization_algorithm = 4 [default = RECURSIVE];
  bool has_minimization_algorithm() const;
  void clear_minimization_algorithm() ;
  ::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm minimization_algorithm() const;
  void set_minimization_algorithm(::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm value);

  private:
  ::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm _internal_minimization_algorithm() const;
  void _internal_set_minimization_algorithm(::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm value);

  public:
  // optional double variable_activity_decay = 15 [default = 0.8];
  bool has_variable_activity_decay() const;
  void clear_variable_activity_decay() ;
  double variable_activity_decay() const;
  void set_variable_activity_decay(double value);

  private:
  double _internal_variable_activity_decay() const;
  void _internal_set_variable_activity_decay(double value);

  public:
  // optional double max_variable_activity_value = 16 [default = 1e+100];
  bool has_max_variable_activity_value() const;
  void clear_max_variable_activity_value() ;
  double max_variable_activity_value() const;
  void set_max_variable_activity_value(double value);

  private:
  double _internal_max_variable_activity_value() const;
  void _internal_set_max_variable_activity_value(double value);

  public:
  // optional double clause_activity_decay = 17 [default = 0.999];
  bool has_clause_activity_decay() const;
  void clear_clause_activity_decay() ;
  double clause_activity_decay() const;
  void set_clause_activity_decay(double value);

  private:
  double _internal_clause_activity_decay() const;
  void _internal_set_clause_activity_decay(double value);

  public:
  // optional int32 clause_cleanup_period = 11 [default = 10000];
  bool has_clause_cleanup_period() const;
  void clear_clause_cleanup_period() ;
  ::int32_t clause_cleanup_period() const;
  void set_clause_cleanup_period(::int32_t value);

  private:
  ::int32_t _internal_clause_cleanup_period() const;
  void _internal_set_clause_cleanup_period(::int32_t value);

  public:
  // optional int32 glucose_decay_increment_period = 24 [default = 5000];
  bool has_glucose_decay_increment_period() const;
  void clear_glucose_decay_increment_period() ;
  ::int32_t glucose_decay_increment_period() const;
  void set_glucose_decay_increment_period(::int32_t value);

  private:
  ::int32_t _internal_glucose_decay_increment_period() const;
  void _internal_set_glucose_decay_increment_period(::int32_t value);

  public:
  // optional double max_clause_activity_value = 18 [default = 1e+20];
  bool has_max_clause_activity_value() const;
  void clear_max_clause_activity_value() ;
  double max_clause_activity_value() const;
  void set_max_clause_activity_value(double value);

  private:
  double _internal_max_clause_activity_value() const;
  void _internal_set_max_clause_activity_value(double value);

  public:
  // optional double glucose_max_decay = 22 [default = 0.95];
  bool has_glucose_max_decay() const;
  void clear_glucose_max_decay() ;
  double glucose_max_decay() const;
  void set_glucose_max_decay(double value);

  private:
  double _internal_glucose_max_decay() const;
  void _internal_set_glucose_max_decay(double value);

  public:
  // optional double glucose_decay_increment = 23 [default = 0.01];
  bool has_glucose_decay_increment() const;
  void clear_glucose_decay_increment() ;
  double glucose_decay_increment() const;
  void set_glucose_decay_increment(double value);

  private:
  double _internal_glucose_decay_increment() const;
  void _internal_set_glucose_decay_increment(double value);

  public:
  // optional int32 restart_period = 30 [default = 50];
  bool has_restart_period() const;
  void clear_restart_period() ;
  ::int32_t restart_period() const;
  void set_restart_period(::int32_t value);

  private:
  ::int32_t _internal_restart_period() const;
  void _internal_set_restart_period(::int32_t value);

  public:
  // optional int32 random_seed = 31 [default = 1];
  bool has_random_seed() const;
  void clear_random_seed() ;
  ::int32_t random_seed() const;
  void set_random_seed(::int32_t value);

  private:
  ::int32_t _internal_random_seed() const;
  void _internal_set_random_seed(::int32_t value);

  public:
  // optional double max_time_in_seconds = 36 [default = inf];
  bool has_max_time_in_seconds() const;
  void clear_max_time_in_seconds() ;
  double max_time_in_seconds() const;
  void set_max_time_in_seconds(double value);

  private:
  double _internal_max_time_in_seconds() const;
  void _internal_set_max_time_in_seconds(double value);

  public:
  // optional int64 max_number_of_conflicts = 37 [default = 9223372036854775807];
  bool has_max_number_of_conflicts() const;
  void clear_max_number_of_conflicts() ;
  ::int64_t max_number_of_conflicts() const;
  void set_max_number_of_conflicts(::int64_t value);

  private:
  ::int64_t _internal_max_number_of_conflicts() const;
  void _internal_set_max_number_of_conflicts(::int64_t value);

  public:
  // optional int64 max_memory_in_mb = 40 [default = 10000];
  bool has_max_memory_in_mb() const;
  void clear_max_memory_in_mb() ;
  ::int64_t max_memory_in_mb() const;
  void set_max_memory_in_mb(::int64_t value);

  private:
  ::int64_t _internal_max_memory_in_mb() const;
  void _internal_set_max_memory_in_mb(::int64_t value);

  public:
  // optional .operations_research.sat.SatParameters.BinaryMinizationAlgorithm binary_minimization_algorithm = 34 [default = BINARY_MINIMIZATION_FIRST];
  bool has_binary_minimization_algorithm() const;
  void clear_binary_minimization_algorithm() ;
  ::operations_research::sat::SatParameters_BinaryMinizationAlgorithm binary_minimization_algorithm() const;
  void set_binary_minimization_algorithm(::operations_research::sat::SatParameters_BinaryMinizationAlgorithm value);

  private:
  ::operations_research::sat::SatParameters_BinaryMinizationAlgorithm _internal_binary_minimization_algorithm() const;
  void _internal_set_binary_minimization_algorithm(::operations_research::sat::SatParameters_BinaryMinizationAlgorithm value);

  public:
  // optional int32 pb_cleanup_increment = 46 [default = 200];
  bool has_pb_cleanup_increment() const;
  void clear_pb_cleanup_increment() ;
  ::int32_t pb_cleanup_increment() const;
  void set_pb_cleanup_increment(::int32_t value);

  private:
  ::int32_t _internal_pb_cleanup_increment() const;
  void _internal_set_pb_cleanup_increment(::int32_t value);

  public:
  // optional double pb_cleanup_ratio = 47 [default = 0.5];
  bool has_pb_cleanup_ratio() const;
  void clear_pb_cleanup_ratio() ;
  double pb_cleanup_ratio() const;
  void set_pb_cleanup_ratio(double value);

  private:
  double _internal_pb_cleanup_ratio() const;
  void _internal_set_pb_cleanup_ratio(double value);

  public:
  // optional int32 core_minimization_level = 50 [default = 2];
  bool has_core_minimization_level() const;
  void clear_core_minimization_level() ;
  ::int32_t core_minimization_level() const;
  void set_core_minimization_level(::int32_t value);

  private:
  ::int32_t _internal_core_minimization_level() const;
  void _internal_set_core_minimization_level(::int32_t value);

  public:
  // optional .operations_research.sat.SatParameters.MaxSatStratificationAlgorithm max_sat_stratification = 53 [default = STRATIFICATION_DESCENT];
  bool has_max_sat_stratification() const;
  void clear_max_sat_stratification() ;
  ::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm max_sat_stratification() const;
  void set_max_sat_stratification(::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm value);

  private:
  ::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm _internal_max_sat_stratification() const;
  void _internal_set_max_sat_stratification(::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm value);

  public:
  // optional int32 presolve_bve_threshold = 54 [default = 500];
  bool has_presolve_bve_threshold() const;
  void clear_presolve_bve_threshold() ;
  ::int32_t presolve_bve_threshold() const;
  void set_presolve_bve_threshold(::int32_t value);

  private:
  ::int32_t _internal_presolve_bve_threshold() const;
  void _internal_set_presolve_bve_threshold(::int32_t value);

  public:
  // optional int32 presolve_bve_clause_weight = 55 [default = 3];
  bool has_presolve_bve_clause_weight() const;
  void clear_presolve_bve_clause_weight() ;
  ::int32_t presolve_bve_clause_weight() const;
  void set_presolve_bve_clause_weight(::int32_t value);

  private:
  ::int32_t _internal_presolve_bve_clause_weight() const;
  void _internal_set_presolve_bve_clause_weight(::int32_t value);

  public:
  // optional double presolve_probing_deterministic_time_limit = 57 [default = 30];
  bool has_presolve_probing_deterministic_time_limit() const;
  void clear_presolve_probing_deterministic_time_limit() ;
  double presolve_probing_deterministic_time_limit() const;
  void set_presolve_probing_deterministic_time_limit(double value);

  private:
  double _internal_presolve_probing_deterministic_time_limit() const;
  void _internal_set_presolve_probing_deterministic_time_limit(double value);

  public:
  // optional int32 clause_cleanup_lbd_bound = 59 [default = 5];
  bool has_clause_cleanup_lbd_bound() const;
  void clear_clause_cleanup_lbd_bound() ;
  ::int32_t clause_cleanup_lbd_bound() const;
  void set_clause_cleanup_lbd_bound(::int32_t value);

  private:
  ::int32_t _internal_clause_cleanup_lbd_bound() const;
  void _internal_set_clause_cleanup_lbd_bound(::int32_t value);

  public:
  // optional int32 restart_running_window_size = 62 [default = 50];
  bool has_restart_running_window_size() const;
  void clear_restart_running_window_size() ;
  ::int32_t restart_running_window_size() const;
  void set_restart_running_window_size(::int32_t value);

  private:
  ::int32_t _internal_restart_running_window_size() const;
  void _internal_set_restart_running_window_size(::int32_t value);

  public:
  // optional double restart_dl_average_ratio = 63 [default = 1];
  bool has_restart_dl_average_ratio() const;
  void clear_restart_dl_average_ratio() ;
  double restart_dl_average_ratio() const;
  void set_restart_dl_average_ratio(double value);

  private:
  double _internal_restart_dl_average_ratio() const;
  void _internal_set_restart_dl_average_ratio(double value);

  public:
  // optional double blocking_restart_multiplier = 66 [default = 1.4];
  bool has_blocking_restart_multiplier() const;
  void clear_blocking_restart_multiplier() ;
  double blocking_restart_multiplier() const;
  void set_blocking_restart_multiplier(double value);

  private:
  double _internal_blocking_restart_multiplier() const;
  void _internal_set_blocking_restart_multiplier(double value);

  public:
  // optional double max_deterministic_time = 67 [default = inf];
  bool has_max_deterministic_time() const;
  void clear_max_deterministic_time() ;
  double max_deterministic_time() const;
  void set_max_deterministic_time(double value);

  private:
  double _internal_max_deterministic_time() const;
  void _internal_set_max_deterministic_time(double value);

  public:
  // optional int32 blocking_restart_window_size = 65 [default = 5000];
  bool has_blocking_restart_window_size() const;
  void clear_blocking_restart_window_size() ;
  ::int32_t blocking_restart_window_size() const;
  void set_blocking_restart_window_size(::int32_t value);

  private:
  ::int32_t _internal_blocking_restart_window_size() const;
  void _internal_set_blocking_restart_window_size(::int32_t value);

  public:
  // optional int32 presolve_bva_threshold = 73 [default = 1];
  bool has_presolve_bva_threshold() const;
  void clear_presolve_bva_threshold() ;
  ::int32_t presolve_bva_threshold() const;
  void set_presolve_bva_threshold(::int32_t value);

  private:
  ::int32_t _internal_presolve_bva_threshold() const;
  void _internal_set_presolve_bva_threshold(::int32_t value);

  public:
  // optional double restart_lbd_average_ratio = 71 [default = 1];
  bool has_restart_lbd_average_ratio() const;
  void clear_restart_lbd_average_ratio() ;
  double restart_lbd_average_ratio() const;
  void set_restart_lbd_average_ratio(double value);

  private:
  double _internal_restart_lbd_average_ratio() const;
  void _internal_set_restart_lbd_average_ratio(double value);

  public:
  // optional bool find_multiple_cores = 84 [default = true];
  bool has_find_multiple_cores() const;
  void clear_find_multiple_cores() ;
  bool find_multiple_cores() const;
  void set_find_multiple_cores(bool value);

  private:
  bool _internal_find_multiple_cores() const;
  void _internal_set_find_multiple_cores(bool value);

  public:
  // optional bool cover_optimization = 89 [default = true];
  bool has_cover_optimization() const;
  void clear_cover_optimization() ;
  bool cover_optimization() const;
  void set_cover_optimization(bool value);

  private:
  bool _internal_cover_optimization() const;
  void _internal_set_cover_optimization(bool value);

  public:
  // optional bool use_precedences_in_disjunctive_constraint = 74 [default = true];
  bool has_use_precedences_in_disjunctive_constraint() const;
  void clear_use_precedences_in_disjunctive_constraint() ;
  bool use_precedences_in_disjunctive_constraint() const;
  void set_use_precedences_in_disjunctive_constraint(bool value);

  private:
  bool _internal_use_precedences_in_disjunctive_constraint() const;
  void _internal_set_use_precedences_in_disjunctive_constraint(bool value);

  public:
  // optional bool use_disjunctive_constraint_in_cumulative = 80 [default = true];
  bool has_use_disjunctive_constraint_in_cumulative() const;
  void clear_use_disjunctive_constraint_in_cumulative() ;
  bool use_disjunctive_constraint_in_cumulative() const;
  void set_use_disjunctive_constraint_in_cumulative(bool value);

  private:
  bool _internal_use_disjunctive_constraint_in_cumulative() const;
  void _internal_set_use_disjunctive_constraint_in_cumulative(bool value);

  public:
  // optional bool use_phase_saving = 44 [default = true];
  bool has_use_phase_saving() const;
  void clear_use_phase_saving() ;
  bool use_phase_saving() const;
  void set_use_phase_saving(bool value);

  private:
  bool _internal_use_phase_saving() const;
  void _internal_set_use_phase_saving(bool value);

  public:
  // optional bool subsumption_during_conflict_analysis = 56 [default = true];
  bool has_subsumption_during_conflict_analysis() const;
  void clear_subsumption_during_conflict_analysis() ;
  bool subsumption_during_conflict_analysis() const;
  void set_subsumption_during_conflict_analysis(bool value);

  private:
  bool _internal_subsumption_during_conflict_analysis() const;
  void _internal_set_subsumption_during_conflict_analysis(bool value);

  public:
  // optional bool log_to_stdout = 186 [default = true];
  bool has_log_to_stdout() const;
  void clear_log_to_stdout() ;
  bool log_to_stdout() const;
  void set_log_to_stdout(bool value);

  private:
  bool _internal_log_to_stdout() const;
  void _internal_set_log_to_stdout(bool value);

  public:
  // optional bool count_assumption_levels_in_lbd = 49 [default = true];
  bool has_count_assumption_levels_in_lbd() const;
  void clear_count_assumption_levels_in_lbd() ;
  bool count_assumption_levels_in_lbd() const;
  void set_count_assumption_levels_in_lbd(bool value);

  private:
  bool _internal_count_assumption_levels_in_lbd() const;
  void _internal_set_count_assumption_levels_in_lbd(bool value);

  public:
  // optional bool presolve_blocked_clause = 88 [default = true];
  bool has_presolve_blocked_clause() const;
  void clear_presolve_blocked_clause() ;
  bool presolve_blocked_clause() const;
  void set_presolve_blocked_clause(bool value);

  private:
  bool _internal_presolve_blocked_clause() const;
  void _internal_set_presolve_blocked_clause(bool value);

  public:
  // optional bool presolve_use_bva = 72 [default = true];
  bool has_presolve_use_bva() const;
  void clear_presolve_use_bva() ;
  bool presolve_use_bva() const;
  void set_presolve_use_bva(bool value);

  private:
  bool _internal_presolve_use_bva() const;
  void _internal_set_presolve_use_bva(bool value);

  public:
  // optional bool cp_model_presolve = 86 [default = true];
  bool has_cp_model_presolve() const;
  void clear_cp_model_presolve() ;
  bool cp_model_presolve() const;
  void set_cp_model_presolve(bool value);

  private:
  bool _internal_cp_model_presolve() const;
  void _internal_set_cp_model_presolve(bool value);

  public:
  // optional bool cp_model_use_sat_presolve = 93 [default = true];
  bool has_cp_model_use_sat_presolve() const;
  void clear_cp_model_use_sat_presolve() ;
  bool cp_model_use_sat_presolve() const;
  void set_cp_model_use_sat_presolve(bool value);

  private:
  bool _internal_cp_model_use_sat_presolve() const;
  void _internal_set_cp_model_use_sat_presolve(bool value);

  public:
  // optional int32 linearization_level = 90 [default = 1];
  bool has_linearization_level() const;
  void clear_linearization_level() ;
  ::int32_t linearization_level() const;
  void set_linearization_level(::int32_t value);

  private:
  ::int32_t _internal_linearization_level() const;
  void _internal_set_linearization_level(::int32_t value);

  public:
  // optional int32 max_num_cuts = 91 [default = 10000];
  bool has_max_num_cuts() const;
  void clear_max_num_cuts() ;
  ::int32_t max_num_cuts() const;
  void set_max_num_cuts(::int32_t value);

  private:
  ::int32_t _internal_max_num_cuts() const;
  void _internal_set_max_num_cuts(::int32_t value);

  public:
  // optional int32 minimize_with_propagation_restart_period = 96 [default = 10];
  bool has_minimize_with_propagation_restart_period() const;
  void clear_minimize_with_propagation_restart_period() ;
  ::int32_t minimize_with_propagation_restart_period() const;
  void set_minimize_with_propagation_restart_period(::int32_t value);

  private:
  ::int32_t _internal_minimize_with_propagation_restart_period() const;
  void _internal_set_minimize_with_propagation_restart_period(::int32_t value);

  public:
  // optional int32 minimize_with_propagation_num_decisions = 97 [default = 1000];
  bool has_minimize_with_propagation_num_decisions() const;
  void clear_minimize_with_propagation_num_decisions() ;
  ::int32_t minimize_with_propagation_num_decisions() const;
  void set_minimize_with_propagation_num_decisions(::int32_t value);

  private:
  ::int32_t _internal_minimize_with_propagation_num_decisions() const;
  void _internal_set_minimize_with_propagation_num_decisions(::int32_t value);

  public:
  // optional int32 binary_search_num_conflicts = 99 [default = -1];
  bool has_binary_search_num_conflicts() const;
  void clear_binary_search_num_conflicts() ;
  ::int32_t binary_search_num_conflicts() const;
  void set_binary_search_num_conflicts(::int32_t value);

  private:
  ::int32_t _internal_binary_search_num_conflicts() const;
  void _internal_set_binary_search_num_conflicts(::int32_t value);

  public:
  // optional int32 boolean_encoding_level = 107 [default = 1];
  bool has_boolean_encoding_level() const;
  void clear_boolean_encoding_level() ;
  ::int32_t boolean_encoding_level() const;
  void set_boolean_encoding_level(::int32_t value);

  private:
  ::int32_t _internal_boolean_encoding_level() const;
  void _internal_set_boolean_encoding_level(::int32_t value);

  public:
  // optional int32 cp_model_probing_level = 110 [default = 2];
  bool has_cp_model_probing_level() const;
  void clear_cp_model_probing_level() ;
  ::int32_t cp_model_probing_level() const;
  void set_cp_model_probing_level(::int32_t value);

  private:
  ::int32_t _internal_cp_model_probing_level() const;
  void _internal_set_cp_model_probing_level(::int32_t value);

  public:
  // optional double min_orthogonality_for_lp_constraints = 115 [default = 0.05];
  bool has_min_orthogonality_for_lp_constraints() const;
  void clear_min_orthogonality_for_lp_constraints() ;
  double min_orthogonality_for_lp_constraints() const;
  void set_min_orthogonality_for_lp_constraints(double value);

  private:
  double _internal_min_orthogonality_for_lp_constraints() const;
  void _internal_set_min_orthogonality_for_lp_constraints(double value);

  public:
  // optional bool share_objective_bounds = 113 [default = true];
  bool has_share_objective_bounds() const;
  void clear_share_objective_bounds() ;
  bool share_objective_bounds() const;
  void set_share_objective_bounds(bool value);

  private:
  bool _internal_share_objective_bounds() const;
  void _internal_set_share_objective_bounds(bool value);

  public:
  // optional bool share_level_zero_bounds = 114 [default = true];
  bool has_share_level_zero_bounds() const;
  void clear_share_level_zero_bounds() ;
  bool share_level_zero_bounds() const;
  void set_share_level_zero_bounds(bool value);

  private:
  bool _internal_share_level_zero_bounds() const;
  void _internal_set_share_level_zero_bounds(bool value);

  public:
  // optional bool share_binary_clauses = 203 [default = true];
  bool has_share_binary_clauses() const;
  void clear_share_binary_clauses() ;
  bool share_binary_clauses() const;
  void set_share_binary_clauses(bool value);

  private:
  bool _internal_share_binary_clauses() const;
  void _internal_set_share_binary_clauses(bool value);

  public:
  // optional bool use_optimization_hints = 35 [default = true];
  bool has_use_optimization_hints() const;
  void clear_use_optimization_hints() ;
  bool use_optimization_hints() const;
  void set_use_optimization_hints(bool value);

  private:
  bool _internal_use_optimization_hints() const;
  void _internal_set_use_optimization_hints(bool value);

  public:
  // optional int32 max_integer_rounding_scaling = 119 [default = 600];
  bool has_max_integer_rounding_scaling() const;
  void clear_max_integer_rounding_scaling() ;
  ::int32_t max_integer_rounding_scaling() const;
  void set_max_integer_rounding_scaling(::int32_t value);

  private:
  ::int32_t _internal_max_integer_rounding_scaling() const;
  void _internal_set_max_integer_rounding_scaling(::int32_t value);

  public:
  // optional int32 max_consecutive_inactive_count = 121 [default = 100];
  bool has_max_consecutive_inactive_count() const;
  void clear_max_consecutive_inactive_count() ;
  ::int32_t max_consecutive_inactive_count() const;
  void set_max_consecutive_inactive_count(::int32_t value);

  private:
  ::int32_t _internal_max_consecutive_inactive_count() const;
  void _internal_set_max_consecutive_inactive_count(::int32_t value);

  public:
  // optional int32 new_constraints_batch_size = 122 [default = 50];
  bool has_new_constraints_batch_size() const;
  void clear_new_constraints_batch_size() ;
  ::int32_t new_constraints_batch_size() const;
  void set_new_constraints_batch_size(::int32_t value);

  private:
  ::int32_t _internal_new_constraints_batch_size() const;
  void _internal_set_new_constraints_batch_size(::int32_t value);

  public:
  // optional int64 pseudo_cost_reliability_threshold = 123 [default = 100];
  bool has_pseudo_cost_reliability_threshold() const;
  void clear_pseudo_cost_reliability_threshold() ;
  ::int64_t pseudo_cost_reliability_threshold() const;
  void set_pseudo_cost_reliability_threshold(::int64_t value);

  private:
  ::int64_t _internal_pseudo_cost_reliability_threshold() const;
  void _internal_set_pseudo_cost_reliability_threshold(::int64_t value);

  public:
  // optional double mip_max_bound = 124 [default = 10000000];
  bool has_mip_max_bound() const;
  void clear_mip_max_bound() ;
  double mip_max_bound() const;
  void set_mip_max_bound(double value);

  private:
  double _internal_mip_max_bound() const;
  void _internal_set_mip_max_bound(double value);

  public:
  // optional double mip_var_scaling = 125 [default = 1];
  bool has_mip_var_scaling() const;
  void clear_mip_var_scaling() ;
  double mip_var_scaling() const;
  void set_mip_var_scaling(double value);

  private:
  double _internal_mip_var_scaling() const;
  void _internal_set_mip_var_scaling(double value);

  public:
  // optional double mip_wanted_precision = 126 [default = 1e-06];
  bool has_mip_wanted_precision() const;
  void clear_mip_wanted_precision() ;
  double mip_wanted_precision() const;
  void set_mip_wanted_precision(double value);

  private:
  double _internal_mip_wanted_precision() const;
  void _internal_set_mip_wanted_precision(double value);

  public:
  // optional double mip_check_precision = 128 [default = 0.0001];
  bool has_mip_check_precision() const;
  void clear_mip_check_precision() ;
  double mip_check_precision() const;
  void set_mip_check_precision(double value);

  private:
  double _internal_mip_check_precision() const;
  void _internal_set_mip_check_precision(double value);

  public:
  // optional int32 mip_max_activity_exponent = 127 [default = 53];
  bool has_mip_max_activity_exponent() const;
  void clear_mip_max_activity_exponent() ;
  ::int32_t mip_max_activity_exponent() const;
  void set_mip_max_activity_exponent(::int32_t value);

  private:
  ::int32_t _internal_mip_max_activity_exponent() const;
  void _internal_set_mip_max_activity_exponent(::int32_t value);

  public:
  // optional bool add_clique_cuts = 172 [default = true];
  bool has_add_clique_cuts() const;
  void clear_add_clique_cuts() ;
  bool add_clique_cuts() const;
  void set_add_clique_cuts(bool value);

  private:
  bool _internal_add_clique_cuts() const;
  void _internal_set_add_clique_cuts(bool value);

  public:
  // optional bool add_lin_max_cuts = 152 [default = true];
  bool has_add_lin_max_cuts() const;
  void clear_add_lin_max_cuts() ;
  bool add_lin_max_cuts() const;
  void set_add_lin_max_cuts(bool value);

  private:
  bool _internal_add_lin_max_cuts() const;
  void _internal_set_add_lin_max_cuts(bool value);

  public:
  // optional bool add_lp_constraints_lazily = 112 [default = true];
  bool has_add_lp_constraints_lazily() const;
  void clear_add_lp_constraints_lazily() ;
  bool add_lp_constraints_lazily() const;
  void set_add_lp_constraints_lazily(bool value);

  private:
  bool _internal_add_lp_constraints_lazily() const;
  void _internal_set_add_lp_constraints_lazily(bool value);

  public:
  // optional bool exploit_integer_lp_solution = 94 [default = true];
  bool has_exploit_integer_lp_solution() const;
  void clear_exploit_integer_lp_solution() ;
  bool exploit_integer_lp_solution() const;
  void set_exploit_integer_lp_solution(bool value);

  private:
  bool _internal_exploit_integer_lp_solution() const;
  void _internal_set_exploit_integer_lp_solution(bool value);

  public:
  // optional int32 max_presolve_iterations = 138 [default = 3];
  bool has_max_presolve_iterations() const;
  void clear_max_presolve_iterations() ;
  ::int32_t max_presolve_iterations() const;
  void set_max_presolve_iterations(::int32_t value);

  private:
  ::int32_t _internal_max_presolve_iterations() const;
  void _internal_set_max_presolve_iterations(::int32_t value);

  public:
  // optional bool use_feasibility_pump = 164 [default = true];
  bool has_use_feasibility_pump() const;
  void clear_use_feasibility_pump() ;
  bool use_feasibility_pump() const;
  void set_use_feasibility_pump(bool value);

  private:
  bool _internal_use_feasibility_pump() const;
  void _internal_set_use_feasibility_pump(bool value);

  public:
  // optional bool use_exact_lp_reason = 109 [default = true];
  bool has_use_exact_lp_reason() const;
  void clear_use_exact_lp_reason() ;
  bool use_exact_lp_reason() const;
  void set_use_exact_lp_reason(bool value);

  private:
  bool _internal_use_exact_lp_reason() const;
  void _internal_set_use_exact_lp_reason(bool value);

  public:
  // optional bool catch_sigint_signal = 135 [default = true];
  bool has_catch_sigint_signal() const;
  void clear_catch_sigint_signal() ;
  bool catch_sigint_signal() const;
  void set_catch_sigint_signal(bool value);

  private:
  bool _internal_catch_sigint_signal() const;
  void _internal_set_catch_sigint_signal(bool value);

  public:
  // optional bool use_implied_bounds = 144 [default = true];
  bool has_use_implied_bounds() const;
  void clear_use_implied_bounds() ;
  bool use_implied_bounds() const;
  void set_use_implied_bounds(bool value);

  private:
  bool _internal_use_implied_bounds() const;
  void _internal_set_use_implied_bounds(bool value);

  public:
  // optional double merge_no_overlap_work_limit = 145 [default = 1000000000000];
  bool has_merge_no_overlap_work_limit() const;
  void clear_merge_no_overlap_work_limit() ;
  double merge_no_overlap_work_limit() const;
  void set_merge_no_overlap_work_limit(double value);

  private:
  double _internal_merge_no_overlap_work_limit() const;
  void _internal_set_merge_no_overlap_work_limit(double value);

  public:
  // optional bool feasibility_jump_enable_restarts = 250 [default = true];
  bool has_feasibility_jump_enable_restarts() const;
  void clear_feasibility_jump_enable_restarts() ;
  bool feasibility_jump_enable_restarts() const;
  void set_feasibility_jump_enable_restarts(bool value);

  private:
  bool _internal_feasibility_jump_enable_restarts() const;
  void _internal_set_feasibility_jump_enable_restarts(bool value);

  public:
  // optional bool instantiate_all_variables = 106 [default = true];
  bool has_instantiate_all_variables() const;
  void clear_instantiate_all_variables() ;
  bool instantiate_all_variables() const;
  void set_instantiate_all_variables(bool value);

  private:
  bool _internal_instantiate_all_variables() const;
  void _internal_set_instantiate_all_variables(bool value);

  public:
  // optional bool auto_detect_greater_than_at_least_one_of = 95 [default = true];
  bool has_auto_detect_greater_than_at_least_one_of() const;
  void clear_auto_detect_greater_than_at_least_one_of() ;
  bool auto_detect_greater_than_at_least_one_of() const;
  void set_auto_detect_greater_than_at_least_one_of(bool value);

  private:
  bool _internal_auto_detect_greater_than_at_least_one_of() const;
  void _internal_set_auto_detect_greater_than_at_least_one_of(bool value);

  public:
  // optional bool use_rins_lns = 129 [default = true];
  bool has_use_rins_lns() const;
  void clear_use_rins_lns() ;
  bool use_rins_lns() const;
  void set_use_rins_lns(bool value);

  private:
  bool _internal_use_rins_lns() const;
  void _internal_set_use_rins_lns(bool value);

  public:
  // optional int32 presolve_substitution_level = 147 [default = 1];
  bool has_presolve_substitution_level() const;
  void clear_presolve_substitution_level() ;
  ::int32_t presolve_substitution_level() const;
  void set_presolve_substitution_level(::int32_t value);

  private:
  ::int32_t _internal_presolve_substitution_level() const;
  void _internal_set_presolve_substitution_level(::int32_t value);

  public:
  // optional double merge_at_most_one_work_limit = 146 [default = 100000000];
  bool has_merge_at_most_one_work_limit() const;
  void clear_merge_at_most_one_work_limit() ;
  double merge_at_most_one_work_limit() const;
  void set_merge_at_most_one_work_limit(double value);

  private:
  double _internal_merge_at_most_one_work_limit() const;
  void _internal_set_merge_at_most_one_work_limit(double value);

  public:
  // optional int32 max_all_diff_cut_size = 148 [default = 64];
  bool has_max_all_diff_cut_size() const;
  void clear_max_all_diff_cut_size() ;
  ::int32_t max_all_diff_cut_size() const;
  void set_max_all_diff_cut_size(::int32_t value);

  private:
  ::int32_t _internal_max_all_diff_cut_size() const;
  void _internal_set_max_all_diff_cut_size(::int32_t value);

  public:
  // optional int32 hint_conflict_limit = 153 [default = 10];
  bool has_hint_conflict_limit() const;
  void clear_hint_conflict_limit() ;
  ::int32_t hint_conflict_limit() const;
  void set_hint_conflict_limit(::int32_t value);

  private:
  ::int32_t _internal_hint_conflict_limit() const;
  void _internal_set_hint_conflict_limit(::int32_t value);

  public:
  // optional int32 max_cut_rounds_at_level_zero = 154 [default = 1];
  bool has_max_cut_rounds_at_level_zero() const;
  void clear_max_cut_rounds_at_level_zero() ;
  ::int32_t max_cut_rounds_at_level_zero() const;
  void set_max_cut_rounds_at_level_zero(::int32_t value);

  private:
  ::int32_t _internal_max_cut_rounds_at_level_zero() const;
  void _internal_set_max_cut_rounds_at_level_zero(::int32_t value);

  public:
  // optional bool use_dual_scheduling_heuristics = 214 [default = true];
  bool has_use_dual_scheduling_heuristics() const;
  void clear_use_dual_scheduling_heuristics() ;
  bool use_dual_scheduling_heuristics() const;
  void set_use_dual_scheduling_heuristics(bool value);

  private:
  bool _internal_use_dual_scheduling_heuristics() const;
  void _internal_set_use_dual_scheduling_heuristics(bool value);

  public:
  // optional bool add_cg_cuts = 117 [default = true];
  bool has_add_cg_cuts() const;
  void clear_add_cg_cuts() ;
  bool add_cg_cuts() const;
  void set_add_cg_cuts(bool value);

  private:
  bool _internal_add_cg_cuts() const;
  void _internal_set_add_cg_cuts(bool value);

  public:
  // optional bool add_mir_cuts = 120 [default = true];
  bool has_add_mir_cuts() const;
  void clear_add_mir_cuts() ;
  bool add_mir_cuts() const;
  void set_add_mir_cuts(bool value);

  private:
  bool _internal_add_mir_cuts() const;
  void _internal_set_add_mir_cuts(bool value);

  public:
  // optional bool add_zero_half_cuts = 169 [default = true];
  bool has_add_zero_half_cuts() const;
  void clear_add_zero_half_cuts() ;
  bool add_zero_half_cuts() const;
  void set_add_zero_half_cuts(bool value);

  private:
  bool _internal_add_zero_half_cuts() const;
  void _internal_set_add_zero_half_cuts(bool value);

  public:
  // optional double cut_max_active_count_value = 155 [default = 10000000000];
  bool has_cut_max_active_count_value() const;
  void clear_cut_max_active_count_value() ;
  double cut_max_active_count_value() const;
  void set_cut_max_active_count_value(double value);

  private:
  double _internal_cut_max_active_count_value() const;
  void _internal_set_cut_max_active_count_value(double value);

  public:
  // optional double cut_active_count_decay = 156 [default = 0.8];
  bool has_cut_active_count_decay() const;
  void clear_cut_active_count_decay() ;
  double cut_active_count_decay() const;
  void set_cut_active_count_decay(double value);

  private:
  double _internal_cut_active_count_decay() const;
  void _internal_set_cut_active_count_decay(double value);

  public:
  // optional double absolute_gap_limit = 159 [default = 0.0001];
  bool has_absolute_gap_limit() const;
  void clear_absolute_gap_limit() ;
  double absolute_gap_limit() const;
  void set_absolute_gap_limit(double value);

  private:
  double _internal_absolute_gap_limit() const;
  void _internal_set_absolute_gap_limit(double value);

  public:
  // optional int32 cut_cleanup_target = 157 [default = 1000];
  bool has_cut_cleanup_target() const;
  void clear_cut_cleanup_target() ;
  ::int32_t cut_cleanup_target() const;
  void set_cut_cleanup_target(::int32_t value);

  private:
  ::int32_t _internal_cut_cleanup_target() const;
  void _internal_set_cut_cleanup_target(::int32_t value);

  public:
  // optional .operations_research.sat.SatParameters.FPRoundingMethod fp_rounding = 165 [default = PROPAGATION_ASSISTED];
  bool has_fp_rounding() const;
  void clear_fp_rounding() ;
  ::operations_research::sat::SatParameters_FPRoundingMethod fp_rounding() const;
  void set_fp_rounding(::operations_research::sat::SatParameters_FPRoundingMethod value);

  private:
  ::operations_research::sat::SatParameters_FPRoundingMethod _internal_fp_rounding() const;
  void _internal_set_fp_rounding(::operations_research::sat::SatParameters_FPRoundingMethod value);

  public:
  // optional int32 polarity_rephase_increment = 168 [default = 1000];
  bool has_polarity_rephase_increment() const;
  void clear_polarity_rephase_increment() ;
  ::int32_t polarity_rephase_increment() const;
  void set_polarity_rephase_increment(::int32_t value);

  private:
  ::int32_t _internal_polarity_rephase_increment() const;
  void _internal_set_polarity_rephase_increment(::int32_t value);

  public:
  // optional bool exploit_all_lp_solution = 116 [default = true];
  bool has_exploit_all_lp_solution() const;
  void clear_exploit_all_lp_solution() ;
  bool exploit_all_lp_solution() const;
  void set_exploit_all_lp_solution(bool value);

  private:
  bool _internal_exploit_all_lp_solution() const;
  void _internal_set_exploit_all_lp_solution(bool value);

  public:
  // optional bool exploit_objective = 131 [default = true];
  bool has_exploit_objective() const;
  void clear_exploit_objective() ;
  bool exploit_objective() const;
  void set_exploit_objective(bool value);

  private:
  bool _internal_exploit_objective() const;
  void _internal_set_exploit_objective(bool value);

  public:
  // optional bool use_shaving_in_probing_search = 204 [default = true];
  bool has_use_shaving_in_probing_search() const;
  void clear_use_shaving_in_probing_search() ;
  bool use_shaving_in_probing_search() const;
  void set_use_shaving_in_probing_search(bool value);

  private:
  bool _internal_use_shaving_in_probing_search() const;
  void _internal_set_use_shaving_in_probing_search(bool value);

  public:
  // optional bool use_feasibility_jump = 265 [default = true];
  bool has_use_feasibility_jump() const;
  void clear_use_feasibility_jump() ;
  bool use_feasibility_jump() const;
  void set_use_feasibility_jump(bool value);

  private:
  bool _internal_use_feasibility_jump() const;
  void _internal_set_use_feasibility_jump(bool value);

  public:
  // optional bool convert_intervals = 177 [default = true];
  bool has_convert_intervals() const;
  void clear_convert_intervals() ;
  bool convert_intervals() const;
  void set_convert_intervals(bool value);

  private:
  bool _internal_convert_intervals() const;
  void _internal_set_convert_intervals(bool value);

  public:
  // optional bool mip_automatically_scale_variables = 166 [default = true];
  bool has_mip_automatically_scale_variables() const;
  void clear_mip_automatically_scale_variables() ;
  bool mip_automatically_scale_variables() const;
  void set_mip_automatically_scale_variables(bool value);

  private:
  bool _internal_mip_automatically_scale_variables() const;
  void _internal_set_mip_automatically_scale_variables(bool value);

  public:
  // optional bool mip_compute_true_objective_bound = 198 [default = true];
  bool has_mip_compute_true_objective_bound() const;
  void clear_mip_compute_true_objective_bound() ;
  bool mip_compute_true_objective_bound() const;
  void set_mip_compute_true_objective_bound(bool value);

  private:
  bool _internal_mip_compute_true_objective_bound() const;
  void _internal_set_mip_compute_true_objective_bound(bool value);

  public:
  // optional int32 symmetry_level = 183 [default = 2];
  bool has_symmetry_level() const;
  void clear_symmetry_level() ;
  ::int32_t symmetry_level() const;
  void set_symmetry_level(::int32_t value);

  private:
  ::int32_t _internal_symmetry_level() const;
  void _internal_set_symmetry_level(::int32_t value);

  public:
  // optional double clause_cleanup_ratio = 190 [default = 0.5];
  bool has_clause_cleanup_ratio() const;
  void clear_clause_cleanup_ratio() ;
  double clause_cleanup_ratio() const;
  void set_clause_cleanup_ratio(double value);

  private:
  double _internal_clause_cleanup_ratio() const;
  void _internal_set_clause_cleanup_ratio(double value);

  public:
  // optional int32 max_domain_size_when_encoding_eq_neq_constraints = 191 [default = 16];
  bool has_max_domain_size_when_encoding_eq_neq_constraints() const;
  void clear_max_domain_size_when_encoding_eq_neq_constraints() ;
  ::int32_t max_domain_size_when_encoding_eq_neq_constraints() const;
  void set_max_domain_size_when_encoding_eq_neq_constraints(::int32_t value);

  private:
  ::int32_t _internal_max_domain_size_when_encoding_eq_neq_constraints() const;
  void _internal_set_max_domain_size_when_encoding_eq_neq_constraints(::int32_t value);

  public:
  // optional int32 solution_pool_size = 193 [default = 3];
  bool has_solution_pool_size() const;
  void clear_solution_pool_size() ;
  ::int32_t solution_pool_size() const;
  void set_solution_pool_size(::int32_t value);

  private:
  ::int32_t _internal_solution_pool_size() const;
  void _internal_set_solution_pool_size(::int32_t value);

  public:
  // optional double mip_max_valid_magnitude = 199 [default = 1e+30];
  bool has_mip_max_valid_magnitude() const;
  void clear_mip_max_valid_magnitude() ;
  double mip_max_valid_magnitude() const;
  void set_mip_max_valid_magnitude(double value);

  private:
  double _internal_mip_max_valid_magnitude() const;
  void _internal_set_mip_max_valid_magnitude(double value);

  public:
  // optional int64 presolve_inclusion_work_limit = 201 [default = 100000000];
  bool has_presolve_inclusion_work_limit() const;
  void clear_presolve_inclusion_work_limit() ;
  ::int64_t presolve_inclusion_work_limit() const;
  void set_presolve_inclusion_work_limit(::int64_t value);

  private:
  ::int64_t _internal_presolve_inclusion_work_limit() const;
  void _internal_set_presolve_inclusion_work_limit(::int64_t value);

  public:
  // optional int32 cut_level = 196 [default = 1];
  bool has_cut_level() const;
  void clear_cut_level() ;
  ::int32_t cut_level() const;
  void set_cut_level(::int32_t value);

  private:
  ::int32_t _internal_cut_level() const;
  void _internal_set_cut_level(::int32_t value);

  public:
  // optional int32 min_num_lns_workers = 211 [default = 2];
  bool has_min_num_lns_workers() const;
  void clear_min_num_lns_workers() ;
  ::int32_t min_num_lns_workers() const;
  void set_min_num_lns_workers(::int32_t value);

  private:
  ::int32_t _internal_min_num_lns_workers() const;
  void _internal_set_min_num_lns_workers(::int32_t value);

  public:
  // optional double shaving_search_deterministic_time = 205 [default = 0.001];
  bool has_shaving_search_deterministic_time() const;
  void clear_shaving_search_deterministic_time() ;
  double shaving_search_deterministic_time() const;
  void set_shaving_search_deterministic_time(double value);

  private:
  double _internal_shaving_search_deterministic_time() const;
  void _internal_set_shaving_search_deterministic_time(double value);

  public:
  // optional bool expand_reservoir_constraints = 182 [default = true];
  bool has_expand_reservoir_constraints() const;
  void clear_expand_reservoir_constraints() ;
  bool expand_reservoir_constraints() const;
  void set_expand_reservoir_constraints(bool value);

  private:
  bool _internal_expand_reservoir_constraints() const;
  void _internal_set_expand_reservoir_constraints(bool value);

  public:
  // optional bool ignore_names = 202 [default = true];
  bool has_ignore_names() const;
  void clear_ignore_names() ;
  bool ignore_names() const;
  void set_ignore_names(bool value);

  private:
  bool _internal_ignore_names() const;
  void _internal_set_ignore_names(bool value);

  public:
  // optional bool infer_all_diffs = 233 [default = true];
  bool has_infer_all_diffs() const;
  void clear_infer_all_diffs() ;
  bool infer_all_diffs() const;
  void set_infer_all_diffs(bool value);

  private:
  bool _internal_infer_all_diffs() const;
  void _internal_set_infer_all_diffs(bool value);

  public:
  // optional bool find_big_linear_overlap = 234 [default = true];
  bool has_find_big_linear_overlap() const;
  void clear_find_big_linear_overlap() ;
  bool find_big_linear_overlap() const;
  void set_find_big_linear_overlap(bool value);

  private:
  bool _internal_find_big_linear_overlap() const;
  void _internal_set_find_big_linear_overlap(bool value);

  public:
  // optional int32 table_compression_level = 217 [default = 2];
  bool has_table_compression_level() const;
  void clear_table_compression_level() ;
  ::int32_t table_compression_level() const;
  void set_table_compression_level(::int32_t value);

  private:
  ::int32_t _internal_table_compression_level() const;
  void _internal_set_table_compression_level(::int32_t value);

  public:
  // optional double propagation_loop_detection_factor = 221 [default = 10];
  bool has_propagation_loop_detection_factor() const;
  void clear_propagation_loop_detection_factor() ;
  double propagation_loop_detection_factor() const;
  void set_propagation_loop_detection_factor(double value);

  private:
  double _internal_propagation_loop_detection_factor() const;
  void _internal_set_propagation_loop_detection_factor(double value);

  public:
  // optional double probing_deterministic_time_limit = 226 [default = 1];
  bool has_probing_deterministic_time_limit() const;
  void clear_probing_deterministic_time_limit() ;
  double probing_deterministic_time_limit() const;
  void set_probing_deterministic_time_limit(double value);

  private:
  double _internal_probing_deterministic_time_limit() const;
  void _internal_set_probing_deterministic_time_limit(double value);

  public:
  // optional int32 root_lp_iterations = 227 [default = 2000];
  bool has_root_lp_iterations() const;
  void clear_root_lp_iterations() ;
  ::int32_t root_lp_iterations() const;
  void set_root_lp_iterations(::int32_t value);

  private:
  ::int32_t _internal_root_lp_iterations() const;
  void _internal_set_root_lp_iterations(::int32_t value);

  public:
  // optional int32 max_size_to_create_precedence_literals_in_disjunctive = 229 [default = 60];
  bool has_max_size_to_create_precedence_literals_in_disjunctive() const;
  void clear_max_size_to_create_precedence_literals_in_disjunctive() ;
  ::int32_t max_size_to_create_precedence_literals_in_disjunctive() const;
  void set_max_size_to_create_precedence_literals_in_disjunctive(::int32_t value);

  private:
  ::int32_t _internal_max_size_to_create_precedence_literals_in_disjunctive() const;
  void _internal_set_max_size_to_create_precedence_literals_in_disjunctive(::int32_t value);

  public:
  // optional double mip_drop_tolerance = 232 [default = 1e-16];
  bool has_mip_drop_tolerance() const;
  void clear_mip_drop_tolerance() ;
  double mip_drop_tolerance() const;
  void set_mip_drop_tolerance(double value);

  private:
  double _internal_mip_drop_tolerance() const;
  void _internal_set_mip_drop_tolerance(double value);

  public:
  // optional double shared_tree_worker_objective_split_probability = 237 [default = 0.5];
  bool has_shared_tree_worker_objective_split_probability() const;
  void clear_shared_tree_worker_objective_split_probability() ;
  double shared_tree_worker_objective_split_probability() const;
  void set_shared_tree_worker_objective_split_probability(double value);

  private:
  double _internal_shared_tree_worker_objective_split_probability() const;
  void _internal_set_shared_tree_worker_objective_split_probability(double value);

  public:
  // optional double feasibility_jump_decay = 242 [default = 0.95];
  bool has_feasibility_jump_decay() const;
  void clear_feasibility_jump_decay() ;
  double feasibility_jump_decay() const;
  void set_feasibility_jump_decay(double value);

  private:
  double _internal_feasibility_jump_decay() const;
  void _internal_set_feasibility_jump_decay(double value);

  public:
  // optional int32 shared_tree_max_nodes_per_worker = 238 [default = 128];
  bool has_shared_tree_max_nodes_per_worker() const;
  void clear_shared_tree_max_nodes_per_worker() ;
  ::int32_t shared_tree_max_nodes_per_worker() const;
  void set_shared_tree_max_nodes_per_worker(::int32_t value);

  private:
  ::int32_t _internal_shared_tree_max_nodes_per_worker() const;
  void _internal_set_shared_tree_max_nodes_per_worker(::int32_t value);

  public:
  // optional int32 violation_ls_perturbation_period = 249 [default = 100];
  bool has_violation_ls_perturbation_period() const;
  void clear_violation_ls_perturbation_period() ;
  ::int32_t violation_ls_perturbation_period() const;
  void set_violation_ls_perturbation_period(::int32_t value);

  private:
  ::int32_t _internal_violation_ls_perturbation_period() const;
  void _internal_set_violation_ls_perturbation_period(::int32_t value);

  public:
  // optional double feasibility_jump_var_perburbation_range_ratio = 248 [default = 0.2];
  bool has_feasibility_jump_var_perburbation_range_ratio() const;
  void clear_feasibility_jump_var_perburbation_range_ratio() ;
  double feasibility_jump_var_perburbation_range_ratio() const;
  void set_feasibility_jump_var_perburbation_range_ratio(double value);

  private:
  double _internal_feasibility_jump_var_perburbation_range_ratio() const;
  void _internal_set_feasibility_jump_var_perburbation_range_ratio(double value);

  public:
  // optional int32 linear_split_size = 256 [default = 100];
  bool has_linear_split_size() const;
  void clear_linear_split_size() ;
  ::int32_t linear_split_size() const;
  void set_linear_split_size(::int32_t value);

  private:
  ::int32_t _internal_linear_split_size() const;
  void _internal_set_linear_split_size(::int32_t value);

  public:
  // optional int32 feasibility_jump_linearization_level = 257 [default = 2];
  bool has_feasibility_jump_linearization_level() const;
  void clear_feasibility_jump_linearization_level() ;
  ::int32_t feasibility_jump_linearization_level() const;
  void set_feasibility_jump_linearization_level(::int32_t value);

  private:
  ::int32_t _internal_feasibility_jump_linearization_level() const;
  void _internal_set_feasibility_jump_linearization_level(::int32_t value);

  public:
  // optional double violation_ls_compound_move_probability = 259 [default = 0.5];
  bool has_violation_ls_compound_move_probability() const;
  void clear_violation_ls_compound_move_probability() ;
  double violation_ls_compound_move_probability() const;
  void set_violation_ls_compound_move_probability(double value);

  private:
  double _internal_violation_ls_compound_move_probability() const;
  void _internal_set_violation_ls_compound_move_probability(double value);

  public:
  // optional int32 feasibility_jump_restart_factor = 258 [default = 1];
  bool has_feasibility_jump_restart_factor() const;
  void clear_feasibility_jump_restart_factor() ;
  ::int32_t feasibility_jump_restart_factor() const;
  void set_feasibility_jump_restart_factor(::int32_t value);

  private:
  ::int32_t _internal_feasibility_jump_restart_factor() const;
  void _internal_set_feasibility_jump_restart_factor(::int32_t value);

  public:
  // optional int32 max_num_intervals_for_timetable_edge_finding = 260 [default = 100];
  bool has_max_num_intervals_for_timetable_edge_finding() const;
  void clear_max_num_intervals_for_timetable_edge_finding() ;
  ::int32_t max_num_intervals_for_timetable_edge_finding() const;
  void set_max_num_intervals_for_timetable_edge_finding(::int32_t value);

  private:
  ::int32_t _internal_max_num_intervals_for_timetable_edge_finding() const;
  void _internal_set_max_num_intervals_for_timetable_edge_finding(::int32_t value);

  public:
  // optional int32 mip_presolve_level = 261 [default = 2];
  bool has_mip_presolve_level() const;
  void clear_mip_presolve_level() ;
  ::int32_t mip_presolve_level() const;
  void set_mip_presolve_level(::int32_t value);

  private:
  ::int32_t _internal_mip_presolve_level() const;
  void _internal_set_mip_presolve_level(::int32_t value);

  public:
  // optional int32 feasibility_jump_max_expanded_constraint_size = 264 [default = 100];
  bool has_feasibility_jump_max_expanded_constraint_size() const;
  void clear_feasibility_jump_max_expanded_constraint_size() ;
  ::int32_t feasibility_jump_max_expanded_constraint_size() const;
  void set_feasibility_jump_max_expanded_constraint_size(::int32_t value);

  private:
  ::int32_t _internal_feasibility_jump_max_expanded_constraint_size() const;
  void _internal_set_feasibility_jump_max_expanded_constraint_size(::int32_t value);

  public:
  // optional double lp_primal_tolerance = 266 [default = 1e-07];
  bool has_lp_primal_tolerance() const;
  void clear_lp_primal_tolerance() ;
  double lp_primal_tolerance() const;
  void set_lp_primal_tolerance(double value);

  private:
  double _internal_lp_primal_tolerance() const;
  void _internal_set_lp_primal_tolerance(double value);

  public:
  // optional double lp_dual_tolerance = 267 [default = 1e-07];
  bool has_lp_dual_tolerance() const;
  void clear_lp_dual_tolerance() ;
  double lp_dual_tolerance() const;
  void set_lp_dual_tolerance(double value);

  private:
  double _internal_lp_dual_tolerance() const;
  void _internal_set_lp_dual_tolerance(double value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.SatParameters)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 227, 13,
      353, 35>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<7> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> restart_algorithms_;
    ::google::protobuf::RepeatedPtrField<std::string> subsolvers_;
    ::google::protobuf::RepeatedPtrField<std::string> ignore_subsolvers_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::SatParameters > subsolver_params_;
    ::google::protobuf::RepeatedPtrField<std::string> extra_subsolvers_;
    static const ::google::protobuf::internal::LazyString _i_give_permission_to_break_this_code_default_default_restart_algorithms_;
    ::google::protobuf::internal::ArenaStringPtr default_restart_algorithms_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr log_prefix_;
    int preferred_variable_order_;
    ::int32_t clause_cleanup_target_;
    double random_branches_ratio_;
    double random_polarity_ratio_;
    int max_sat_assumption_order_;
    int clause_cleanup_protection_;
    int clause_cleanup_ordering_;
    ::int32_t num_conflicts_before_strategy_changes_;
    double strategy_change_increase_ratio_;
    double initial_variables_activity_;
    int search_branching_;
    bool use_erwa_heuristic_;
    bool also_bump_variables_in_conflict_reasons_;
    bool use_blocking_restart_;
    bool permute_variable_randomly_;
    ::int64_t search_random_variable_pool_size_;
    ::int32_t num_search_workers_;
    bool log_to_response_;
    bool use_pb_resolution_;
    bool minimize_reduction_during_pb_resolution_;
    bool use_sat_inprocessing_;
    ::int64_t probing_period_at_root_;
    ::int32_t interleave_batch_size_;
    bool permute_presolve_constraint_order_;
    bool use_absl_random_;
    bool log_search_progress_;
    bool log_subsolver_statistics_;
    bool use_overload_checker_in_cumulative_;
    bool use_timetable_edge_finding_in_cumulative_;
    bool use_hard_precedences_in_cumulative_;
    bool exploit_all_precedences_;
    bool optimize_with_core_;
    bool optimize_with_lb_tree_search_;
    bool optimize_with_max_hs_;
    bool test_feasibility_jump_;
    bool use_lns_only_;
    bool use_lb_relax_lns_;
    bool diversify_lns_params_;
    bool randomize_search_;
    ::int32_t debug_max_num_presolve_operations_;
    bool use_shared_tree_search_;
    bool enumerate_all_solutions_;
    bool keep_all_feasible_solutions_in_presolve_;
    bool fill_tightened_domains_in_response_;
    bool push_all_tasks_toward_start_;
    bool use_optional_variables_;
    bool use_branching_in_lp_;
    bool use_combined_no_overlap_;
    double relative_gap_limit_;
    bool presolve_extract_integer_enforcement_;
    bool interleave_search_;
    bool debug_postsolve_with_full_solver_;
    bool debug_crash_on_bad_hint_;
    bool add_objective_cut_;
    bool repair_hint_;
    bool fix_variables_to_their_hinted_value_;
    bool exploit_best_solution_;
    bool fill_additional_solutions_in_response_;
    bool stop_after_first_solution_;
    bool stop_after_presolve_;
    bool stop_after_root_propagation_;
    bool use_timetabling_in_no_overlap_2d_;
    bool use_energetic_reasoning_in_no_overlap_2d_;
    bool use_pairwise_reasoning_in_no_overlap_2d_;
    bool only_add_cuts_at_level_zero_;
    bool detect_table_with_cost_;
    bool expand_alldiff_constraints_;
    bool disable_constraint_expansion_;
    bool encode_complex_linear_constraint_with_integer_;
    bool max_sat_reverse_assumption_order_;
    bool use_strong_propagation_in_disjunctive_;
    bool use_dynamic_precedence_in_disjunctive_;
    bool use_dynamic_precedence_in_cumulative_;
    bool exploit_relaxation_solution_;
    bool use_probing_search_;
    bool use_objective_lb_search_;
    bool use_objective_shaving_search_;
    ::int32_t num_workers_;
    bool polish_lp_solution_;
    bool new_linear_propagation_;
    bool mip_scale_large_domain_;
    bool only_solve_ip_;
    ::int32_t shared_tree_num_workers_;
    int shared_tree_split_strategy_;
    ::int32_t num_violation_ls_;
    double feasibility_jump_var_randomization_probability_;
    int initial_polarity_;
    int minimization_algorithm_;
    double variable_activity_decay_;
    double max_variable_activity_value_;
    double clause_activity_decay_;
    ::int32_t clause_cleanup_period_;
    ::int32_t glucose_decay_increment_period_;
    double max_clause_activity_value_;
    double glucose_max_decay_;
    double glucose_decay_increment_;
    ::int32_t restart_period_;
    ::int32_t random_seed_;
    double max_time_in_seconds_;
    ::int64_t max_number_of_conflicts_;
    ::int64_t max_memory_in_mb_;
    int binary_minimization_algorithm_;
    ::int32_t pb_cleanup_increment_;
    double pb_cleanup_ratio_;
    ::int32_t core_minimization_level_;
    int max_sat_stratification_;
    ::int32_t presolve_bve_threshold_;
    ::int32_t presolve_bve_clause_weight_;
    double presolve_probing_deterministic_time_limit_;
    ::int32_t clause_cleanup_lbd_bound_;
    ::int32_t restart_running_window_size_;
    double restart_dl_average_ratio_;
    double blocking_restart_multiplier_;
    double max_deterministic_time_;
    ::int32_t blocking_restart_window_size_;
    ::int32_t presolve_bva_threshold_;
    double restart_lbd_average_ratio_;
    bool find_multiple_cores_;
    bool cover_optimization_;
    bool use_precedences_in_disjunctive_constraint_;
    bool use_disjunctive_constraint_in_cumulative_;
    bool use_phase_saving_;
    bool subsumption_during_conflict_analysis_;
    bool log_to_stdout_;
    bool count_assumption_levels_in_lbd_;
    bool presolve_blocked_clause_;
    bool presolve_use_bva_;
    bool cp_model_presolve_;
    bool cp_model_use_sat_presolve_;
    ::int32_t linearization_level_;
    ::int32_t max_num_cuts_;
    ::int32_t minimize_with_propagation_restart_period_;
    ::int32_t minimize_with_propagation_num_decisions_;
    ::int32_t binary_search_num_conflicts_;
    ::int32_t boolean_encoding_level_;
    ::int32_t cp_model_probing_level_;
    double min_orthogonality_for_lp_constraints_;
    bool share_objective_bounds_;
    bool share_level_zero_bounds_;
    bool share_binary_clauses_;
    bool use_optimization_hints_;
    ::int32_t max_integer_rounding_scaling_;
    ::int32_t max_consecutive_inactive_count_;
    ::int32_t new_constraints_batch_size_;
    ::int64_t pseudo_cost_reliability_threshold_;
    double mip_max_bound_;
    double mip_var_scaling_;
    double mip_wanted_precision_;
    double mip_check_precision_;
    ::int32_t mip_max_activity_exponent_;
    bool add_clique_cuts_;
    bool add_lin_max_cuts_;
    bool add_lp_constraints_lazily_;
    bool exploit_integer_lp_solution_;
    ::int32_t max_presolve_iterations_;
    bool use_feasibility_pump_;
    bool use_exact_lp_reason_;
    bool catch_sigint_signal_;
    bool use_implied_bounds_;
    double merge_no_overlap_work_limit_;
    bool feasibility_jump_enable_restarts_;
    bool instantiate_all_variables_;
    bool auto_detect_greater_than_at_least_one_of_;
    bool use_rins_lns_;
    ::int32_t presolve_substitution_level_;
    double merge_at_most_one_work_limit_;
    ::int32_t max_all_diff_cut_size_;
    ::int32_t hint_conflict_limit_;
    ::int32_t max_cut_rounds_at_level_zero_;
    bool use_dual_scheduling_heuristics_;
    bool add_cg_cuts_;
    bool add_mir_cuts_;
    bool add_zero_half_cuts_;
    double cut_max_active_count_value_;
    double cut_active_count_decay_;
    double absolute_gap_limit_;
    ::int32_t cut_cleanup_target_;
    int fp_rounding_;
    ::int32_t polarity_rephase_increment_;
    bool exploit_all_lp_solution_;
    bool exploit_objective_;
    bool use_shaving_in_probing_search_;
    bool use_feasibility_jump_;
    bool convert_intervals_;
    bool mip_automatically_scale_variables_;
    bool mip_compute_true_objective_bound_;
    ::int32_t symmetry_level_;
    double clause_cleanup_ratio_;
    ::int32_t max_domain_size_when_encoding_eq_neq_constraints_;
    ::int32_t solution_pool_size_;
    double mip_max_valid_magnitude_;
    ::int64_t presolve_inclusion_work_limit_;
    ::int32_t cut_level_;
    ::int32_t min_num_lns_workers_;
    double shaving_search_deterministic_time_;
    bool expand_reservoir_constraints_;
    bool ignore_names_;
    bool infer_all_diffs_;
    bool find_big_linear_overlap_;
    ::int32_t table_compression_level_;
    double propagation_loop_detection_factor_;
    double probing_deterministic_time_limit_;
    ::int32_t root_lp_iterations_;
    ::int32_t max_size_to_create_precedence_literals_in_disjunctive_;
    double mip_drop_tolerance_;
    double shared_tree_worker_objective_split_probability_;
    double feasibility_jump_decay_;
    ::int32_t shared_tree_max_nodes_per_worker_;
    ::int32_t violation_ls_perturbation_period_;
    double feasibility_jump_var_perburbation_range_ratio_;
    ::int32_t linear_split_size_;
    ::int32_t feasibility_jump_linearization_level_;
    double violation_ls_compound_move_probability_;
    ::int32_t feasibility_jump_restart_factor_;
    ::int32_t max_num_intervals_for_timetable_edge_finding_;
    ::int32_t mip_presolve_level_;
    ::int32_t feasibility_jump_max_expanded_constraint_size_;
    double lp_primal_tolerance_;
    double lp_dual_tolerance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fsat_5fparameters_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SatParameters

// optional string name = 171 [default = ""];
inline bool SatParameters::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SatParameters::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SatParameters::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SatParameters::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.name)
}
inline std::string* SatParameters::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SatParameters.name)
  return _s;
}
inline const std::string& SatParameters::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void SatParameters::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SatParameters::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SatParameters::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.sat.SatParameters.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SatParameters::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.SatParameters.name)
}

// optional .operations_research.sat.SatParameters.VariableOrder preferred_variable_order = 1 [default = IN_ORDER];
inline bool SatParameters::has_preferred_variable_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SatParameters::clear_preferred_variable_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.preferred_variable_order_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::operations_research::sat::SatParameters_VariableOrder SatParameters::preferred_variable_order() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.preferred_variable_order)
  return _internal_preferred_variable_order();
}
inline void SatParameters::set_preferred_variable_order(::operations_research::sat::SatParameters_VariableOrder value) {
  _internal_set_preferred_variable_order(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.preferred_variable_order)
}
inline ::operations_research::sat::SatParameters_VariableOrder SatParameters::_internal_preferred_variable_order() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_VariableOrder>(_impl_.preferred_variable_order_);
}
inline void SatParameters::_internal_set_preferred_variable_order(::operations_research::sat::SatParameters_VariableOrder value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_VariableOrder_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.preferred_variable_order_ = value;
}

// optional .operations_research.sat.SatParameters.Polarity initial_polarity = 2 [default = POLARITY_FALSE];
inline bool SatParameters::has_initial_polarity() const {
  bool value = (_impl_._has_bits_[2] & 0x02000000u) != 0;
  return value;
}
inline void SatParameters::clear_initial_polarity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initial_polarity_ = 1;
  _impl_._has_bits_[2] &= ~0x02000000u;
}
inline ::operations_research::sat::SatParameters_Polarity SatParameters::initial_polarity() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.initial_polarity)
  return _internal_initial_polarity();
}
inline void SatParameters::set_initial_polarity(::operations_research::sat::SatParameters_Polarity value) {
  _internal_set_initial_polarity(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.initial_polarity)
}
inline ::operations_research::sat::SatParameters_Polarity SatParameters::_internal_initial_polarity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_Polarity>(_impl_.initial_polarity_);
}
inline void SatParameters::_internal_set_initial_polarity(::operations_research::sat::SatParameters_Polarity value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_Polarity_IsValid(value));
  _impl_._has_bits_[2] |= 0x02000000u;
  _impl_.initial_polarity_ = value;
}

// optional bool use_phase_saving = 44 [default = true];
inline bool SatParameters::has_use_phase_saving() const {
  bool value = (_impl_._has_bits_[3] & 0x10000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_phase_saving() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_phase_saving_ = true;
  _impl_._has_bits_[3] &= ~0x10000000u;
}
inline bool SatParameters::use_phase_saving() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_phase_saving)
  return _internal_use_phase_saving();
}
inline void SatParameters::set_use_phase_saving(bool value) {
  _internal_set_use_phase_saving(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_phase_saving)
}
inline bool SatParameters::_internal_use_phase_saving() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_phase_saving_;
}
inline void SatParameters::_internal_set_use_phase_saving(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x10000000u;
  _impl_.use_phase_saving_ = value;
}

// optional int32 polarity_rephase_increment = 168 [default = 1000];
inline bool SatParameters::has_polarity_rephase_increment() const {
  bool value = (_impl_._has_bits_[5] & 0x00200000u) != 0;
  return value;
}
inline void SatParameters::clear_polarity_rephase_increment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.polarity_rephase_increment_ = 1000;
  _impl_._has_bits_[5] &= ~0x00200000u;
}
inline ::int32_t SatParameters::polarity_rephase_increment() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.polarity_rephase_increment)
  return _internal_polarity_rephase_increment();
}
inline void SatParameters::set_polarity_rephase_increment(::int32_t value) {
  _internal_set_polarity_rephase_increment(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.polarity_rephase_increment)
}
inline ::int32_t SatParameters::_internal_polarity_rephase_increment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.polarity_rephase_increment_;
}
inline void SatParameters::_internal_set_polarity_rephase_increment(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00200000u;
  _impl_.polarity_rephase_increment_ = value;
}

// optional double random_polarity_ratio = 45 [default = 0];
inline bool SatParameters::has_random_polarity_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SatParameters::clear_random_polarity_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.random_polarity_ratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double SatParameters::random_polarity_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.random_polarity_ratio)
  return _internal_random_polarity_ratio();
}
inline void SatParameters::set_random_polarity_ratio(double value) {
  _internal_set_random_polarity_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.random_polarity_ratio)
}
inline double SatParameters::_internal_random_polarity_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.random_polarity_ratio_;
}
inline void SatParameters::_internal_set_random_polarity_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.random_polarity_ratio_ = value;
}

// optional double random_branches_ratio = 32 [default = 0];
inline bool SatParameters::has_random_branches_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SatParameters::clear_random_branches_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.random_branches_ratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double SatParameters::random_branches_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.random_branches_ratio)
  return _internal_random_branches_ratio();
}
inline void SatParameters::set_random_branches_ratio(double value) {
  _internal_set_random_branches_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.random_branches_ratio)
}
inline double SatParameters::_internal_random_branches_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.random_branches_ratio_;
}
inline void SatParameters::_internal_set_random_branches_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.random_branches_ratio_ = value;
}

// optional bool use_erwa_heuristic = 75 [default = false];
inline bool SatParameters::has_use_erwa_heuristic() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void SatParameters::clear_use_erwa_heuristic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_erwa_heuristic_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool SatParameters::use_erwa_heuristic() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_erwa_heuristic)
  return _internal_use_erwa_heuristic();
}
inline void SatParameters::set_use_erwa_heuristic(bool value) {
  _internal_set_use_erwa_heuristic(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_erwa_heuristic)
}
inline bool SatParameters::_internal_use_erwa_heuristic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_erwa_heuristic_;
}
inline void SatParameters::_internal_set_use_erwa_heuristic(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.use_erwa_heuristic_ = value;
}

// optional double initial_variables_activity = 76 [default = 0];
inline bool SatParameters::has_initial_variables_activity() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void SatParameters::clear_initial_variables_activity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initial_variables_activity_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline double SatParameters::initial_variables_activity() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.initial_variables_activity)
  return _internal_initial_variables_activity();
}
inline void SatParameters::set_initial_variables_activity(double value) {
  _internal_set_initial_variables_activity(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.initial_variables_activity)
}
inline double SatParameters::_internal_initial_variables_activity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.initial_variables_activity_;
}
inline void SatParameters::_internal_set_initial_variables_activity(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.initial_variables_activity_ = value;
}

// optional bool also_bump_variables_in_conflict_reasons = 77 [default = false];
inline bool SatParameters::has_also_bump_variables_in_conflict_reasons() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void SatParameters::clear_also_bump_variables_in_conflict_reasons() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.also_bump_variables_in_conflict_reasons_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool SatParameters::also_bump_variables_in_conflict_reasons() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.also_bump_variables_in_conflict_reasons)
  return _internal_also_bump_variables_in_conflict_reasons();
}
inline void SatParameters::set_also_bump_variables_in_conflict_reasons(bool value) {
  _internal_set_also_bump_variables_in_conflict_reasons(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.also_bump_variables_in_conflict_reasons)
}
inline bool SatParameters::_internal_also_bump_variables_in_conflict_reasons() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.also_bump_variables_in_conflict_reasons_;
}
inline void SatParameters::_internal_set_also_bump_variables_in_conflict_reasons(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.also_bump_variables_in_conflict_reasons_ = value;
}

// optional .operations_research.sat.SatParameters.ConflictMinimizationAlgorithm minimization_algorithm = 4 [default = RECURSIVE];
inline bool SatParameters::has_minimization_algorithm() const {
  bool value = (_impl_._has_bits_[2] & 0x04000000u) != 0;
  return value;
}
inline void SatParameters::clear_minimization_algorithm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minimization_algorithm_ = 2;
  _impl_._has_bits_[2] &= ~0x04000000u;
}
inline ::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm SatParameters::minimization_algorithm() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.minimization_algorithm)
  return _internal_minimization_algorithm();
}
inline void SatParameters::set_minimization_algorithm(::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm value) {
  _internal_set_minimization_algorithm(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.minimization_algorithm)
}
inline ::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm SatParameters::_internal_minimization_algorithm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm>(_impl_.minimization_algorithm_);
}
inline void SatParameters::_internal_set_minimization_algorithm(::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm_IsValid(value));
  _impl_._has_bits_[2] |= 0x04000000u;
  _impl_.minimization_algorithm_ = value;
}

// optional .operations_research.sat.SatParameters.BinaryMinizationAlgorithm binary_minimization_algorithm = 34 [default = BINARY_MINIMIZATION_FIRST];
inline bool SatParameters::has_binary_minimization_algorithm() const {
  bool value = (_impl_._has_bits_[3] & 0x00000100u) != 0;
  return value;
}
inline void SatParameters::clear_binary_minimization_algorithm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_minimization_algorithm_ = 1;
  _impl_._has_bits_[3] &= ~0x00000100u;
}
inline ::operations_research::sat::SatParameters_BinaryMinizationAlgorithm SatParameters::binary_minimization_algorithm() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.binary_minimization_algorithm)
  return _internal_binary_minimization_algorithm();
}
inline void SatParameters::set_binary_minimization_algorithm(::operations_research::sat::SatParameters_BinaryMinizationAlgorithm value) {
  _internal_set_binary_minimization_algorithm(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.binary_minimization_algorithm)
}
inline ::operations_research::sat::SatParameters_BinaryMinizationAlgorithm SatParameters::_internal_binary_minimization_algorithm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_BinaryMinizationAlgorithm>(_impl_.binary_minimization_algorithm_);
}
inline void SatParameters::_internal_set_binary_minimization_algorithm(::operations_research::sat::SatParameters_BinaryMinizationAlgorithm value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_BinaryMinizationAlgorithm_IsValid(value));
  _impl_._has_bits_[3] |= 0x00000100u;
  _impl_.binary_minimization_algorithm_ = value;
}

// optional bool subsumption_during_conflict_analysis = 56 [default = true];
inline bool SatParameters::has_subsumption_during_conflict_analysis() const {
  bool value = (_impl_._has_bits_[3] & 0x20000000u) != 0;
  return value;
}
inline void SatParameters::clear_subsumption_during_conflict_analysis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subsumption_during_conflict_analysis_ = true;
  _impl_._has_bits_[3] &= ~0x20000000u;
}
inline bool SatParameters::subsumption_during_conflict_analysis() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.subsumption_during_conflict_analysis)
  return _internal_subsumption_during_conflict_analysis();
}
inline void SatParameters::set_subsumption_during_conflict_analysis(bool value) {
  _internal_set_subsumption_during_conflict_analysis(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.subsumption_during_conflict_analysis)
}
inline bool SatParameters::_internal_subsumption_during_conflict_analysis() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subsumption_during_conflict_analysis_;
}
inline void SatParameters::_internal_set_subsumption_during_conflict_analysis(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x20000000u;
  _impl_.subsumption_during_conflict_analysis_ = value;
}

// optional int32 clause_cleanup_period = 11 [default = 10000];
inline bool SatParameters::has_clause_cleanup_period() const {
  bool value = (_impl_._has_bits_[2] & 0x40000000u) != 0;
  return value;
}
inline void SatParameters::clear_clause_cleanup_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clause_cleanup_period_ = 10000;
  _impl_._has_bits_[2] &= ~0x40000000u;
}
inline ::int32_t SatParameters::clause_cleanup_period() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.clause_cleanup_period)
  return _internal_clause_cleanup_period();
}
inline void SatParameters::set_clause_cleanup_period(::int32_t value) {
  _internal_set_clause_cleanup_period(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.clause_cleanup_period)
}
inline ::int32_t SatParameters::_internal_clause_cleanup_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clause_cleanup_period_;
}
inline void SatParameters::_internal_set_clause_cleanup_period(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x40000000u;
  _impl_.clause_cleanup_period_ = value;
}

// optional int32 clause_cleanup_target = 13 [default = 0];
inline bool SatParameters::has_clause_cleanup_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SatParameters::clear_clause_cleanup_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clause_cleanup_target_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SatParameters::clause_cleanup_target() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.clause_cleanup_target)
  return _internal_clause_cleanup_target();
}
inline void SatParameters::set_clause_cleanup_target(::int32_t value) {
  _internal_set_clause_cleanup_target(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.clause_cleanup_target)
}
inline ::int32_t SatParameters::_internal_clause_cleanup_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clause_cleanup_target_;
}
inline void SatParameters::_internal_set_clause_cleanup_target(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.clause_cleanup_target_ = value;
}

// optional double clause_cleanup_ratio = 190 [default = 0.5];
inline bool SatParameters::has_clause_cleanup_ratio() const {
  bool value = (_impl_._has_bits_[5] & 0x40000000u) != 0;
  return value;
}
inline void SatParameters::clear_clause_cleanup_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clause_cleanup_ratio_ = 0.5;
  _impl_._has_bits_[5] &= ~0x40000000u;
}
inline double SatParameters::clause_cleanup_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.clause_cleanup_ratio)
  return _internal_clause_cleanup_ratio();
}
inline void SatParameters::set_clause_cleanup_ratio(double value) {
  _internal_set_clause_cleanup_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.clause_cleanup_ratio)
}
inline double SatParameters::_internal_clause_cleanup_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clause_cleanup_ratio_;
}
inline void SatParameters::_internal_set_clause_cleanup_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x40000000u;
  _impl_.clause_cleanup_ratio_ = value;
}

// optional .operations_research.sat.SatParameters.ClauseProtection clause_cleanup_protection = 58 [default = PROTECTION_NONE];
inline bool SatParameters::has_clause_cleanup_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void SatParameters::clear_clause_cleanup_protection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clause_cleanup_protection_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::operations_research::sat::SatParameters_ClauseProtection SatParameters::clause_cleanup_protection() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.clause_cleanup_protection)
  return _internal_clause_cleanup_protection();
}
inline void SatParameters::set_clause_cleanup_protection(::operations_research::sat::SatParameters_ClauseProtection value) {
  _internal_set_clause_cleanup_protection(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.clause_cleanup_protection)
}
inline ::operations_research::sat::SatParameters_ClauseProtection SatParameters::_internal_clause_cleanup_protection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_ClauseProtection>(_impl_.clause_cleanup_protection_);
}
inline void SatParameters::_internal_set_clause_cleanup_protection(::operations_research::sat::SatParameters_ClauseProtection value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_ClauseProtection_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.clause_cleanup_protection_ = value;
}

// optional int32 clause_cleanup_lbd_bound = 59 [default = 5];
inline bool SatParameters::has_clause_cleanup_lbd_bound() const {
  bool value = (_impl_._has_bits_[3] & 0x00010000u) != 0;
  return value;
}
inline void SatParameters::clear_clause_cleanup_lbd_bound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clause_cleanup_lbd_bound_ = 5;
  _impl_._has_bits_[3] &= ~0x00010000u;
}
inline ::int32_t SatParameters::clause_cleanup_lbd_bound() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.clause_cleanup_lbd_bound)
  return _internal_clause_cleanup_lbd_bound();
}
inline void SatParameters::set_clause_cleanup_lbd_bound(::int32_t value) {
  _internal_set_clause_cleanup_lbd_bound(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.clause_cleanup_lbd_bound)
}
inline ::int32_t SatParameters::_internal_clause_cleanup_lbd_bound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clause_cleanup_lbd_bound_;
}
inline void SatParameters::_internal_set_clause_cleanup_lbd_bound(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00010000u;
  _impl_.clause_cleanup_lbd_bound_ = value;
}

// optional .operations_research.sat.SatParameters.ClauseOrdering clause_cleanup_ordering = 60 [default = CLAUSE_ACTIVITY];
inline bool SatParameters::has_clause_cleanup_ordering() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void SatParameters::clear_clause_cleanup_ordering() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clause_cleanup_ordering_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::operations_research::sat::SatParameters_ClauseOrdering SatParameters::clause_cleanup_ordering() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.clause_cleanup_ordering)
  return _internal_clause_cleanup_ordering();
}
inline void SatParameters::set_clause_cleanup_ordering(::operations_research::sat::SatParameters_ClauseOrdering value) {
  _internal_set_clause_cleanup_ordering(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.clause_cleanup_ordering)
}
inline ::operations_research::sat::SatParameters_ClauseOrdering SatParameters::_internal_clause_cleanup_ordering() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_ClauseOrdering>(_impl_.clause_cleanup_ordering_);
}
inline void SatParameters::_internal_set_clause_cleanup_ordering(::operations_research::sat::SatParameters_ClauseOrdering value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_ClauseOrdering_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.clause_cleanup_ordering_ = value;
}

// optional int32 pb_cleanup_increment = 46 [default = 200];
inline bool SatParameters::has_pb_cleanup_increment() const {
  bool value = (_impl_._has_bits_[3] & 0x00000200u) != 0;
  return value;
}
inline void SatParameters::clear_pb_cleanup_increment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pb_cleanup_increment_ = 200;
  _impl_._has_bits_[3] &= ~0x00000200u;
}
inline ::int32_t SatParameters::pb_cleanup_increment() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.pb_cleanup_increment)
  return _internal_pb_cleanup_increment();
}
inline void SatParameters::set_pb_cleanup_increment(::int32_t value) {
  _internal_set_pb_cleanup_increment(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.pb_cleanup_increment)
}
inline ::int32_t SatParameters::_internal_pb_cleanup_increment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pb_cleanup_increment_;
}
inline void SatParameters::_internal_set_pb_cleanup_increment(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000200u;
  _impl_.pb_cleanup_increment_ = value;
}

// optional double pb_cleanup_ratio = 47 [default = 0.5];
inline bool SatParameters::has_pb_cleanup_ratio() const {
  bool value = (_impl_._has_bits_[3] & 0x00000400u) != 0;
  return value;
}
inline void SatParameters::clear_pb_cleanup_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pb_cleanup_ratio_ = 0.5;
  _impl_._has_bits_[3] &= ~0x00000400u;
}
inline double SatParameters::pb_cleanup_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.pb_cleanup_ratio)
  return _internal_pb_cleanup_ratio();
}
inline void SatParameters::set_pb_cleanup_ratio(double value) {
  _internal_set_pb_cleanup_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.pb_cleanup_ratio)
}
inline double SatParameters::_internal_pb_cleanup_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pb_cleanup_ratio_;
}
inline void SatParameters::_internal_set_pb_cleanup_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000400u;
  _impl_.pb_cleanup_ratio_ = value;
}

// optional int32 minimize_with_propagation_restart_period = 96 [default = 10];
inline bool SatParameters::has_minimize_with_propagation_restart_period() const {
  bool value = (_impl_._has_bits_[4] & 0x00000040u) != 0;
  return value;
}
inline void SatParameters::clear_minimize_with_propagation_restart_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minimize_with_propagation_restart_period_ = 10;
  _impl_._has_bits_[4] &= ~0x00000040u;
}
inline ::int32_t SatParameters::minimize_with_propagation_restart_period() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.minimize_with_propagation_restart_period)
  return _internal_minimize_with_propagation_restart_period();
}
inline void SatParameters::set_minimize_with_propagation_restart_period(::int32_t value) {
  _internal_set_minimize_with_propagation_restart_period(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.minimize_with_propagation_restart_period)
}
inline ::int32_t SatParameters::_internal_minimize_with_propagation_restart_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minimize_with_propagation_restart_period_;
}
inline void SatParameters::_internal_set_minimize_with_propagation_restart_period(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000040u;
  _impl_.minimize_with_propagation_restart_period_ = value;
}

// optional int32 minimize_with_propagation_num_decisions = 97 [default = 1000];
inline bool SatParameters::has_minimize_with_propagation_num_decisions() const {
  bool value = (_impl_._has_bits_[4] & 0x00000080u) != 0;
  return value;
}
inline void SatParameters::clear_minimize_with_propagation_num_decisions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minimize_with_propagation_num_decisions_ = 1000;
  _impl_._has_bits_[4] &= ~0x00000080u;
}
inline ::int32_t SatParameters::minimize_with_propagation_num_decisions() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.minimize_with_propagation_num_decisions)
  return _internal_minimize_with_propagation_num_decisions();
}
inline void SatParameters::set_minimize_with_propagation_num_decisions(::int32_t value) {
  _internal_set_minimize_with_propagation_num_decisions(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.minimize_with_propagation_num_decisions)
}
inline ::int32_t SatParameters::_internal_minimize_with_propagation_num_decisions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minimize_with_propagation_num_decisions_;
}
inline void SatParameters::_internal_set_minimize_with_propagation_num_decisions(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000080u;
  _impl_.minimize_with_propagation_num_decisions_ = value;
}

// optional double variable_activity_decay = 15 [default = 0.8];
inline bool SatParameters::has_variable_activity_decay() const {
  bool value = (_impl_._has_bits_[2] & 0x08000000u) != 0;
  return value;
}
inline void SatParameters::clear_variable_activity_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variable_activity_decay_ = 0.8;
  _impl_._has_bits_[2] &= ~0x08000000u;
}
inline double SatParameters::variable_activity_decay() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.variable_activity_decay)
  return _internal_variable_activity_decay();
}
inline void SatParameters::set_variable_activity_decay(double value) {
  _internal_set_variable_activity_decay(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.variable_activity_decay)
}
inline double SatParameters::_internal_variable_activity_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variable_activity_decay_;
}
inline void SatParameters::_internal_set_variable_activity_decay(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x08000000u;
  _impl_.variable_activity_decay_ = value;
}

// optional double max_variable_activity_value = 16 [default = 1e+100];
inline bool SatParameters::has_max_variable_activity_value() const {
  bool value = (_impl_._has_bits_[2] & 0x10000000u) != 0;
  return value;
}
inline void SatParameters::clear_max_variable_activity_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_variable_activity_value_ = 1e+100;
  _impl_._has_bits_[2] &= ~0x10000000u;
}
inline double SatParameters::max_variable_activity_value() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_variable_activity_value)
  return _internal_max_variable_activity_value();
}
inline void SatParameters::set_max_variable_activity_value(double value) {
  _internal_set_max_variable_activity_value(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_variable_activity_value)
}
inline double SatParameters::_internal_max_variable_activity_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_variable_activity_value_;
}
inline void SatParameters::_internal_set_max_variable_activity_value(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x10000000u;
  _impl_.max_variable_activity_value_ = value;
}

// optional double glucose_max_decay = 22 [default = 0.95];
inline bool SatParameters::has_glucose_max_decay() const {
  bool value = (_impl_._has_bits_[3] & 0x00000002u) != 0;
  return value;
}
inline void SatParameters::clear_glucose_max_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.glucose_max_decay_ = 0.95;
  _impl_._has_bits_[3] &= ~0x00000002u;
}
inline double SatParameters::glucose_max_decay() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.glucose_max_decay)
  return _internal_glucose_max_decay();
}
inline void SatParameters::set_glucose_max_decay(double value) {
  _internal_set_glucose_max_decay(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.glucose_max_decay)
}
inline double SatParameters::_internal_glucose_max_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.glucose_max_decay_;
}
inline void SatParameters::_internal_set_glucose_max_decay(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000002u;
  _impl_.glucose_max_decay_ = value;
}

// optional double glucose_decay_increment = 23 [default = 0.01];
inline bool SatParameters::has_glucose_decay_increment() const {
  bool value = (_impl_._has_bits_[3] & 0x00000004u) != 0;
  return value;
}
inline void SatParameters::clear_glucose_decay_increment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.glucose_decay_increment_ = 0.01;
  _impl_._has_bits_[3] &= ~0x00000004u;
}
inline double SatParameters::glucose_decay_increment() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.glucose_decay_increment)
  return _internal_glucose_decay_increment();
}
inline void SatParameters::set_glucose_decay_increment(double value) {
  _internal_set_glucose_decay_increment(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.glucose_decay_increment)
}
inline double SatParameters::_internal_glucose_decay_increment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.glucose_decay_increment_;
}
inline void SatParameters::_internal_set_glucose_decay_increment(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000004u;
  _impl_.glucose_decay_increment_ = value;
}

// optional int32 glucose_decay_increment_period = 24 [default = 5000];
inline bool SatParameters::has_glucose_decay_increment_period() const {
  bool value = (_impl_._has_bits_[2] & 0x80000000u) != 0;
  return value;
}
inline void SatParameters::clear_glucose_decay_increment_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.glucose_decay_increment_period_ = 5000;
  _impl_._has_bits_[2] &= ~0x80000000u;
}
inline ::int32_t SatParameters::glucose_decay_increment_period() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.glucose_decay_increment_period)
  return _internal_glucose_decay_increment_period();
}
inline void SatParameters::set_glucose_decay_increment_period(::int32_t value) {
  _internal_set_glucose_decay_increment_period(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.glucose_decay_increment_period)
}
inline ::int32_t SatParameters::_internal_glucose_decay_increment_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.glucose_decay_increment_period_;
}
inline void SatParameters::_internal_set_glucose_decay_increment_period(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x80000000u;
  _impl_.glucose_decay_increment_period_ = value;
}

// optional double clause_activity_decay = 17 [default = 0.999];
inline bool SatParameters::has_clause_activity_decay() const {
  bool value = (_impl_._has_bits_[2] & 0x20000000u) != 0;
  return value;
}
inline void SatParameters::clear_clause_activity_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clause_activity_decay_ = 0.999;
  _impl_._has_bits_[2] &= ~0x20000000u;
}
inline double SatParameters::clause_activity_decay() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.clause_activity_decay)
  return _internal_clause_activity_decay();
}
inline void SatParameters::set_clause_activity_decay(double value) {
  _internal_set_clause_activity_decay(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.clause_activity_decay)
}
inline double SatParameters::_internal_clause_activity_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clause_activity_decay_;
}
inline void SatParameters::_internal_set_clause_activity_decay(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x20000000u;
  _impl_.clause_activity_decay_ = value;
}

// optional double max_clause_activity_value = 18 [default = 1e+20];
inline bool SatParameters::has_max_clause_activity_value() const {
  bool value = (_impl_._has_bits_[3] & 0x00000001u) != 0;
  return value;
}
inline void SatParameters::clear_max_clause_activity_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_clause_activity_value_ = 1e+20;
  _impl_._has_bits_[3] &= ~0x00000001u;
}
inline double SatParameters::max_clause_activity_value() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_clause_activity_value)
  return _internal_max_clause_activity_value();
}
inline void SatParameters::set_max_clause_activity_value(double value) {
  _internal_set_max_clause_activity_value(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_clause_activity_value)
}
inline double SatParameters::_internal_max_clause_activity_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_clause_activity_value_;
}
inline void SatParameters::_internal_set_max_clause_activity_value(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000001u;
  _impl_.max_clause_activity_value_ = value;
}

// repeated .operations_research.sat.SatParameters.RestartAlgorithm restart_algorithms = 61;
inline int SatParameters::_internal_restart_algorithms_size() const {
  return _internal_restart_algorithms().size();
}
inline int SatParameters::restart_algorithms_size() const {
  return _internal_restart_algorithms_size();
}
inline void SatParameters::clear_restart_algorithms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.restart_algorithms_.Clear();
}
inline ::operations_research::sat::SatParameters_RestartAlgorithm SatParameters::restart_algorithms(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.restart_algorithms)
  return static_cast<::operations_research::sat::SatParameters_RestartAlgorithm>(_internal_restart_algorithms().Get(index));
}
inline void SatParameters::set_restart_algorithms(int index, ::operations_research::sat::SatParameters_RestartAlgorithm value) {
  assert(::operations_research::sat::SatParameters_RestartAlgorithm_IsValid(value));
  _internal_mutable_restart_algorithms()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.restart_algorithms)
}
inline void SatParameters::add_restart_algorithms(::operations_research::sat::SatParameters_RestartAlgorithm value) {
  assert(::operations_research::sat::SatParameters_RestartAlgorithm_IsValid(value));
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_restart_algorithms()->Add(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.SatParameters.restart_algorithms)
}
inline const ::google::protobuf::RepeatedField<int>& SatParameters::restart_algorithms() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SatParameters.restart_algorithms)
  return _internal_restart_algorithms();
}
inline ::google::protobuf::RepeatedField<int>* SatParameters::mutable_restart_algorithms()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SatParameters.restart_algorithms)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_restart_algorithms();
}
inline const ::google::protobuf::RepeatedField<int>& SatParameters::_internal_restart_algorithms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.restart_algorithms_;
}
inline ::google::protobuf::RepeatedField<int>* SatParameters::_internal_mutable_restart_algorithms() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.restart_algorithms_;
}

// optional string default_restart_algorithms = 70 [default = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"];
inline bool SatParameters::has_default_restart_algorithms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SatParameters::clear_default_restart_algorithms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.default_restart_algorithms_.ClearToDefault(::operations_research::sat::SatParameters::Impl_::_i_give_permission_to_break_this_code_default_default_restart_algorithms_, GetArena());
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SatParameters::default_restart_algorithms() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.default_restart_algorithms)
  if (_impl_.default_restart_algorithms_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_default_restart_algorithms_.get();
  }
  return _internal_default_restart_algorithms();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SatParameters::set_default_restart_algorithms(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.default_restart_algorithms_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.default_restart_algorithms)
}
inline std::string* SatParameters::mutable_default_restart_algorithms() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_restart_algorithms();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SatParameters.default_restart_algorithms)
  return _s;
}
inline const std::string& SatParameters::_internal_default_restart_algorithms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.default_restart_algorithms_.Get();
}
inline void SatParameters::_internal_set_default_restart_algorithms(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.default_restart_algorithms_.Set(value, GetArena());
}
inline std::string* SatParameters::_internal_mutable_default_restart_algorithms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.default_restart_algorithms_.Mutable(::operations_research::sat::SatParameters::Impl_::_i_give_permission_to_break_this_code_default_default_restart_algorithms_, GetArena());
}
inline std::string* SatParameters::release_default_restart_algorithms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.sat.SatParameters.default_restart_algorithms)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  return _impl_.default_restart_algorithms_.Release();
}
inline void SatParameters::set_allocated_default_restart_algorithms(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.default_restart_algorithms_.SetAllocated(value, GetArena());
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.SatParameters.default_restart_algorithms)
}

// optional int32 restart_period = 30 [default = 50];
inline bool SatParameters::has_restart_period() const {
  bool value = (_impl_._has_bits_[3] & 0x00000008u) != 0;
  return value;
}
inline void SatParameters::clear_restart_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.restart_period_ = 50;
  _impl_._has_bits_[3] &= ~0x00000008u;
}
inline ::int32_t SatParameters::restart_period() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.restart_period)
  return _internal_restart_period();
}
inline void SatParameters::set_restart_period(::int32_t value) {
  _internal_set_restart_period(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.restart_period)
}
inline ::int32_t SatParameters::_internal_restart_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.restart_period_;
}
inline void SatParameters::_internal_set_restart_period(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000008u;
  _impl_.restart_period_ = value;
}

// optional int32 restart_running_window_size = 62 [default = 50];
inline bool SatParameters::has_restart_running_window_size() const {
  bool value = (_impl_._has_bits_[3] & 0x00020000u) != 0;
  return value;
}
inline void SatParameters::clear_restart_running_window_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.restart_running_window_size_ = 50;
  _impl_._has_bits_[3] &= ~0x00020000u;
}
inline ::int32_t SatParameters::restart_running_window_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.restart_running_window_size)
  return _internal_restart_running_window_size();
}
inline void SatParameters::set_restart_running_window_size(::int32_t value) {
  _internal_set_restart_running_window_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.restart_running_window_size)
}
inline ::int32_t SatParameters::_internal_restart_running_window_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.restart_running_window_size_;
}
inline void SatParameters::_internal_set_restart_running_window_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00020000u;
  _impl_.restart_running_window_size_ = value;
}

// optional double restart_dl_average_ratio = 63 [default = 1];
inline bool SatParameters::has_restart_dl_average_ratio() const {
  bool value = (_impl_._has_bits_[3] & 0x00040000u) != 0;
  return value;
}
inline void SatParameters::clear_restart_dl_average_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.restart_dl_average_ratio_ = 1;
  _impl_._has_bits_[3] &= ~0x00040000u;
}
inline double SatParameters::restart_dl_average_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.restart_dl_average_ratio)
  return _internal_restart_dl_average_ratio();
}
inline void SatParameters::set_restart_dl_average_ratio(double value) {
  _internal_set_restart_dl_average_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.restart_dl_average_ratio)
}
inline double SatParameters::_internal_restart_dl_average_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.restart_dl_average_ratio_;
}
inline void SatParameters::_internal_set_restart_dl_average_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00040000u;
  _impl_.restart_dl_average_ratio_ = value;
}

// optional double restart_lbd_average_ratio = 71 [default = 1];
inline bool SatParameters::has_restart_lbd_average_ratio() const {
  bool value = (_impl_._has_bits_[3] & 0x00800000u) != 0;
  return value;
}
inline void SatParameters::clear_restart_lbd_average_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.restart_lbd_average_ratio_ = 1;
  _impl_._has_bits_[3] &= ~0x00800000u;
}
inline double SatParameters::restart_lbd_average_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.restart_lbd_average_ratio)
  return _internal_restart_lbd_average_ratio();
}
inline void SatParameters::set_restart_lbd_average_ratio(double value) {
  _internal_set_restart_lbd_average_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.restart_lbd_average_ratio)
}
inline double SatParameters::_internal_restart_lbd_average_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.restart_lbd_average_ratio_;
}
inline void SatParameters::_internal_set_restart_lbd_average_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00800000u;
  _impl_.restart_lbd_average_ratio_ = value;
}

// optional bool use_blocking_restart = 64 [default = false];
inline bool SatParameters::has_use_blocking_restart() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void SatParameters::clear_use_blocking_restart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_blocking_restart_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool SatParameters::use_blocking_restart() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_blocking_restart)
  return _internal_use_blocking_restart();
}
inline void SatParameters::set_use_blocking_restart(bool value) {
  _internal_set_use_blocking_restart(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_blocking_restart)
}
inline bool SatParameters::_internal_use_blocking_restart() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_blocking_restart_;
}
inline void SatParameters::_internal_set_use_blocking_restart(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.use_blocking_restart_ = value;
}

// optional int32 blocking_restart_window_size = 65 [default = 5000];
inline bool SatParameters::has_blocking_restart_window_size() const {
  bool value = (_impl_._has_bits_[3] & 0x00200000u) != 0;
  return value;
}
inline void SatParameters::clear_blocking_restart_window_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blocking_restart_window_size_ = 5000;
  _impl_._has_bits_[3] &= ~0x00200000u;
}
inline ::int32_t SatParameters::blocking_restart_window_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.blocking_restart_window_size)
  return _internal_blocking_restart_window_size();
}
inline void SatParameters::set_blocking_restart_window_size(::int32_t value) {
  _internal_set_blocking_restart_window_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.blocking_restart_window_size)
}
inline ::int32_t SatParameters::_internal_blocking_restart_window_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blocking_restart_window_size_;
}
inline void SatParameters::_internal_set_blocking_restart_window_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00200000u;
  _impl_.blocking_restart_window_size_ = value;
}

// optional double blocking_restart_multiplier = 66 [default = 1.4];
inline bool SatParameters::has_blocking_restart_multiplier() const {
  bool value = (_impl_._has_bits_[3] & 0x00080000u) != 0;
  return value;
}
inline void SatParameters::clear_blocking_restart_multiplier() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blocking_restart_multiplier_ = 1.4;
  _impl_._has_bits_[3] &= ~0x00080000u;
}
inline double SatParameters::blocking_restart_multiplier() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.blocking_restart_multiplier)
  return _internal_blocking_restart_multiplier();
}
inline void SatParameters::set_blocking_restart_multiplier(double value) {
  _internal_set_blocking_restart_multiplier(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.blocking_restart_multiplier)
}
inline double SatParameters::_internal_blocking_restart_multiplier() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blocking_restart_multiplier_;
}
inline void SatParameters::_internal_set_blocking_restart_multiplier(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00080000u;
  _impl_.blocking_restart_multiplier_ = value;
}

// optional int32 num_conflicts_before_strategy_changes = 68 [default = 0];
inline bool SatParameters::has_num_conflicts_before_strategy_changes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void SatParameters::clear_num_conflicts_before_strategy_changes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_conflicts_before_strategy_changes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t SatParameters::num_conflicts_before_strategy_changes() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.num_conflicts_before_strategy_changes)
  return _internal_num_conflicts_before_strategy_changes();
}
inline void SatParameters::set_num_conflicts_before_strategy_changes(::int32_t value) {
  _internal_set_num_conflicts_before_strategy_changes(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.num_conflicts_before_strategy_changes)
}
inline ::int32_t SatParameters::_internal_num_conflicts_before_strategy_changes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_conflicts_before_strategy_changes_;
}
inline void SatParameters::_internal_set_num_conflicts_before_strategy_changes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.num_conflicts_before_strategy_changes_ = value;
}

// optional double strategy_change_increase_ratio = 69 [default = 0];
inline bool SatParameters::has_strategy_change_increase_ratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void SatParameters::clear_strategy_change_increase_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.strategy_change_increase_ratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline double SatParameters::strategy_change_increase_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.strategy_change_increase_ratio)
  return _internal_strategy_change_increase_ratio();
}
inline void SatParameters::set_strategy_change_increase_ratio(double value) {
  _internal_set_strategy_change_increase_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.strategy_change_increase_ratio)
}
inline double SatParameters::_internal_strategy_change_increase_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.strategy_change_increase_ratio_;
}
inline void SatParameters::_internal_set_strategy_change_increase_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.strategy_change_increase_ratio_ = value;
}

// optional double max_time_in_seconds = 36 [default = inf];
inline bool SatParameters::has_max_time_in_seconds() const {
  bool value = (_impl_._has_bits_[3] & 0x00000020u) != 0;
  return value;
}
inline void SatParameters::clear_max_time_in_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_time_in_seconds_ = std::numeric_limits<double>::infinity();
  _impl_._has_bits_[3] &= ~0x00000020u;
}
inline double SatParameters::max_time_in_seconds() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_time_in_seconds)
  return _internal_max_time_in_seconds();
}
inline void SatParameters::set_max_time_in_seconds(double value) {
  _internal_set_max_time_in_seconds(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_time_in_seconds)
}
inline double SatParameters::_internal_max_time_in_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_time_in_seconds_;
}
inline void SatParameters::_internal_set_max_time_in_seconds(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000020u;
  _impl_.max_time_in_seconds_ = value;
}

// optional double max_deterministic_time = 67 [default = inf];
inline bool SatParameters::has_max_deterministic_time() const {
  bool value = (_impl_._has_bits_[3] & 0x00100000u) != 0;
  return value;
}
inline void SatParameters::clear_max_deterministic_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_deterministic_time_ = std::numeric_limits<double>::infinity();
  _impl_._has_bits_[3] &= ~0x00100000u;
}
inline double SatParameters::max_deterministic_time() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_deterministic_time)
  return _internal_max_deterministic_time();
}
inline void SatParameters::set_max_deterministic_time(double value) {
  _internal_set_max_deterministic_time(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_deterministic_time)
}
inline double SatParameters::_internal_max_deterministic_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_deterministic_time_;
}
inline void SatParameters::_internal_set_max_deterministic_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00100000u;
  _impl_.max_deterministic_time_ = value;
}

// optional int64 max_number_of_conflicts = 37 [default = 9223372036854775807];
inline bool SatParameters::has_max_number_of_conflicts() const {
  bool value = (_impl_._has_bits_[3] & 0x00000040u) != 0;
  return value;
}
inline void SatParameters::clear_max_number_of_conflicts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_number_of_conflicts_ = ::int64_t{9223372036854775807};
  _impl_._has_bits_[3] &= ~0x00000040u;
}
inline ::int64_t SatParameters::max_number_of_conflicts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_number_of_conflicts)
  return _internal_max_number_of_conflicts();
}
inline void SatParameters::set_max_number_of_conflicts(::int64_t value) {
  _internal_set_max_number_of_conflicts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_number_of_conflicts)
}
inline ::int64_t SatParameters::_internal_max_number_of_conflicts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_number_of_conflicts_;
}
inline void SatParameters::_internal_set_max_number_of_conflicts(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000040u;
  _impl_.max_number_of_conflicts_ = value;
}

// optional int64 max_memory_in_mb = 40 [default = 10000];
inline bool SatParameters::has_max_memory_in_mb() const {
  bool value = (_impl_._has_bits_[3] & 0x00000080u) != 0;
  return value;
}
inline void SatParameters::clear_max_memory_in_mb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_memory_in_mb_ = ::int64_t{10000};
  _impl_._has_bits_[3] &= ~0x00000080u;
}
inline ::int64_t SatParameters::max_memory_in_mb() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_memory_in_mb)
  return _internal_max_memory_in_mb();
}
inline void SatParameters::set_max_memory_in_mb(::int64_t value) {
  _internal_set_max_memory_in_mb(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_memory_in_mb)
}
inline ::int64_t SatParameters::_internal_max_memory_in_mb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_memory_in_mb_;
}
inline void SatParameters::_internal_set_max_memory_in_mb(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000080u;
  _impl_.max_memory_in_mb_ = value;
}

// optional double absolute_gap_limit = 159 [default = 0.0001];
inline bool SatParameters::has_absolute_gap_limit() const {
  bool value = (_impl_._has_bits_[5] & 0x00040000u) != 0;
  return value;
}
inline void SatParameters::clear_absolute_gap_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absolute_gap_limit_ = 0.0001;
  _impl_._has_bits_[5] &= ~0x00040000u;
}
inline double SatParameters::absolute_gap_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.absolute_gap_limit)
  return _internal_absolute_gap_limit();
}
inline void SatParameters::set_absolute_gap_limit(double value) {
  _internal_set_absolute_gap_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.absolute_gap_limit)
}
inline double SatParameters::_internal_absolute_gap_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absolute_gap_limit_;
}
inline void SatParameters::_internal_set_absolute_gap_limit(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00040000u;
  _impl_.absolute_gap_limit_ = value;
}

// optional double relative_gap_limit = 160 [default = 0];
inline bool SatParameters::has_relative_gap_limit() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline void SatParameters::clear_relative_gap_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relative_gap_limit_ = 0;
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline double SatParameters::relative_gap_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.relative_gap_limit)
  return _internal_relative_gap_limit();
}
inline void SatParameters::set_relative_gap_limit(double value) {
  _internal_set_relative_gap_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.relative_gap_limit)
}
inline double SatParameters::_internal_relative_gap_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relative_gap_limit_;
}
inline void SatParameters::_internal_set_relative_gap_limit(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00080000u;
  _impl_.relative_gap_limit_ = value;
}

// optional int32 random_seed = 31 [default = 1];
inline bool SatParameters::has_random_seed() const {
  bool value = (_impl_._has_bits_[3] & 0x00000010u) != 0;
  return value;
}
inline void SatParameters::clear_random_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.random_seed_ = 1;
  _impl_._has_bits_[3] &= ~0x00000010u;
}
inline ::int32_t SatParameters::random_seed() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.random_seed)
  return _internal_random_seed();
}
inline void SatParameters::set_random_seed(::int32_t value) {
  _internal_set_random_seed(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.random_seed)
}
inline ::int32_t SatParameters::_internal_random_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.random_seed_;
}
inline void SatParameters::_internal_set_random_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000010u;
  _impl_.random_seed_ = value;
}

// optional bool permute_variable_randomly = 178 [default = false];
inline bool SatParameters::has_permute_variable_randomly() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void SatParameters::clear_permute_variable_randomly() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.permute_variable_randomly_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool SatParameters::permute_variable_randomly() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.permute_variable_randomly)
  return _internal_permute_variable_randomly();
}
inline void SatParameters::set_permute_variable_randomly(bool value) {
  _internal_set_permute_variable_randomly(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.permute_variable_randomly)
}
inline bool SatParameters::_internal_permute_variable_randomly() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.permute_variable_randomly_;
}
inline void SatParameters::_internal_set_permute_variable_randomly(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.permute_variable_randomly_ = value;
}

// optional bool permute_presolve_constraint_order = 179 [default = false];
inline bool SatParameters::has_permute_presolve_constraint_order() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void SatParameters::clear_permute_presolve_constraint_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.permute_presolve_constraint_order_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool SatParameters::permute_presolve_constraint_order() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.permute_presolve_constraint_order)
  return _internal_permute_presolve_constraint_order();
}
inline void SatParameters::set_permute_presolve_constraint_order(bool value) {
  _internal_set_permute_presolve_constraint_order(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.permute_presolve_constraint_order)
}
inline bool SatParameters::_internal_permute_presolve_constraint_order() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.permute_presolve_constraint_order_;
}
inline void SatParameters::_internal_set_permute_presolve_constraint_order(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.permute_presolve_constraint_order_ = value;
}

// optional bool use_absl_random = 180 [default = false];
inline bool SatParameters::has_use_absl_random() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_absl_random() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_absl_random_ = false;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline bool SatParameters::use_absl_random() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_absl_random)
  return _internal_use_absl_random();
}
inline void SatParameters::set_use_absl_random(bool value) {
  _internal_set_use_absl_random(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_absl_random)
}
inline bool SatParameters::_internal_use_absl_random() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_absl_random_;
}
inline void SatParameters::_internal_set_use_absl_random(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.use_absl_random_ = value;
}

// optional bool log_search_progress = 41 [default = false];
inline bool SatParameters::has_log_search_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void SatParameters::clear_log_search_progress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_search_progress_ = false;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline bool SatParameters::log_search_progress() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.log_search_progress)
  return _internal_log_search_progress();
}
inline void SatParameters::set_log_search_progress(bool value) {
  _internal_set_log_search_progress(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.log_search_progress)
}
inline bool SatParameters::_internal_log_search_progress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_search_progress_;
}
inline void SatParameters::_internal_set_log_search_progress(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.log_search_progress_ = value;
}

// optional bool log_subsolver_statistics = 189 [default = false];
inline bool SatParameters::has_log_subsolver_statistics() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline void SatParameters::clear_log_subsolver_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_subsolver_statistics_ = false;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline bool SatParameters::log_subsolver_statistics() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.log_subsolver_statistics)
  return _internal_log_subsolver_statistics();
}
inline void SatParameters::set_log_subsolver_statistics(bool value) {
  _internal_set_log_subsolver_statistics(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.log_subsolver_statistics)
}
inline bool SatParameters::_internal_log_subsolver_statistics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_subsolver_statistics_;
}
inline void SatParameters::_internal_set_log_subsolver_statistics(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.log_subsolver_statistics_ = value;
}

// optional string log_prefix = 185 [default = ""];
inline bool SatParameters::has_log_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SatParameters::clear_log_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SatParameters::log_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.log_prefix)
  return _internal_log_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SatParameters::set_log_prefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.log_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.log_prefix)
}
inline std::string* SatParameters::mutable_log_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_prefix();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SatParameters.log_prefix)
  return _s;
}
inline const std::string& SatParameters::_internal_log_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_prefix_.Get();
}
inline void SatParameters::_internal_set_log_prefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.log_prefix_.Set(value, GetArena());
}
inline std::string* SatParameters::_internal_mutable_log_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.log_prefix_.Mutable( GetArena());
}
inline std::string* SatParameters::release_log_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:operations_research.sat.SatParameters.log_prefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.log_prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.log_prefix_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SatParameters::set_allocated_log_prefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.log_prefix_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.log_prefix_.IsDefault()) {
          _impl_.log_prefix_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.SatParameters.log_prefix)
}

// optional bool log_to_stdout = 186 [default = true];
inline bool SatParameters::has_log_to_stdout() const {
  bool value = (_impl_._has_bits_[3] & 0x40000000u) != 0;
  return value;
}
inline void SatParameters::clear_log_to_stdout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_to_stdout_ = true;
  _impl_._has_bits_[3] &= ~0x40000000u;
}
inline bool SatParameters::log_to_stdout() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.log_to_stdout)
  return _internal_log_to_stdout();
}
inline void SatParameters::set_log_to_stdout(bool value) {
  _internal_set_log_to_stdout(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.log_to_stdout)
}
inline bool SatParameters::_internal_log_to_stdout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_to_stdout_;
}
inline void SatParameters::_internal_set_log_to_stdout(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x40000000u;
  _impl_.log_to_stdout_ = value;
}

// optional bool log_to_response = 187 [default = false];
inline bool SatParameters::has_log_to_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void SatParameters::clear_log_to_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_to_response_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool SatParameters::log_to_response() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.log_to_response)
  return _internal_log_to_response();
}
inline void SatParameters::set_log_to_response(bool value) {
  _internal_set_log_to_response(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.log_to_response)
}
inline bool SatParameters::_internal_log_to_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_to_response_;
}
inline void SatParameters::_internal_set_log_to_response(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.log_to_response_ = value;
}

// optional bool use_pb_resolution = 43 [default = false];
inline bool SatParameters::has_use_pb_resolution() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void SatParameters::clear_use_pb_resolution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_pb_resolution_ = false;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline bool SatParameters::use_pb_resolution() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_pb_resolution)
  return _internal_use_pb_resolution();
}
inline void SatParameters::set_use_pb_resolution(bool value) {
  _internal_set_use_pb_resolution(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_pb_resolution)
}
inline bool SatParameters::_internal_use_pb_resolution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_pb_resolution_;
}
inline void SatParameters::_internal_set_use_pb_resolution(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.use_pb_resolution_ = value;
}

// optional bool minimize_reduction_during_pb_resolution = 48 [default = false];
inline bool SatParameters::has_minimize_reduction_during_pb_resolution() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void SatParameters::clear_minimize_reduction_during_pb_resolution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minimize_reduction_during_pb_resolution_ = false;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline bool SatParameters::minimize_reduction_during_pb_resolution() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.minimize_reduction_during_pb_resolution)
  return _internal_minimize_reduction_during_pb_resolution();
}
inline void SatParameters::set_minimize_reduction_during_pb_resolution(bool value) {
  _internal_set_minimize_reduction_during_pb_resolution(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.minimize_reduction_during_pb_resolution)
}
inline bool SatParameters::_internal_minimize_reduction_during_pb_resolution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minimize_reduction_during_pb_resolution_;
}
inline void SatParameters::_internal_set_minimize_reduction_during_pb_resolution(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.minimize_reduction_during_pb_resolution_ = value;
}

// optional bool count_assumption_levels_in_lbd = 49 [default = true];
inline bool SatParameters::has_count_assumption_levels_in_lbd() const {
  bool value = (_impl_._has_bits_[3] & 0x80000000u) != 0;
  return value;
}
inline void SatParameters::clear_count_assumption_levels_in_lbd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_assumption_levels_in_lbd_ = true;
  _impl_._has_bits_[3] &= ~0x80000000u;
}
inline bool SatParameters::count_assumption_levels_in_lbd() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.count_assumption_levels_in_lbd)
  return _internal_count_assumption_levels_in_lbd();
}
inline void SatParameters::set_count_assumption_levels_in_lbd(bool value) {
  _internal_set_count_assumption_levels_in_lbd(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.count_assumption_levels_in_lbd)
}
inline bool SatParameters::_internal_count_assumption_levels_in_lbd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_assumption_levels_in_lbd_;
}
inline void SatParameters::_internal_set_count_assumption_levels_in_lbd(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x80000000u;
  _impl_.count_assumption_levels_in_lbd_ = value;
}

// optional int32 presolve_bve_threshold = 54 [default = 500];
inline bool SatParameters::has_presolve_bve_threshold() const {
  bool value = (_impl_._has_bits_[3] & 0x00002000u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_bve_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_bve_threshold_ = 500;
  _impl_._has_bits_[3] &= ~0x00002000u;
}
inline ::int32_t SatParameters::presolve_bve_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_bve_threshold)
  return _internal_presolve_bve_threshold();
}
inline void SatParameters::set_presolve_bve_threshold(::int32_t value) {
  _internal_set_presolve_bve_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_bve_threshold)
}
inline ::int32_t SatParameters::_internal_presolve_bve_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_bve_threshold_;
}
inline void SatParameters::_internal_set_presolve_bve_threshold(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00002000u;
  _impl_.presolve_bve_threshold_ = value;
}

// optional int32 presolve_bve_clause_weight = 55 [default = 3];
inline bool SatParameters::has_presolve_bve_clause_weight() const {
  bool value = (_impl_._has_bits_[3] & 0x00004000u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_bve_clause_weight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_bve_clause_weight_ = 3;
  _impl_._has_bits_[3] &= ~0x00004000u;
}
inline ::int32_t SatParameters::presolve_bve_clause_weight() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_bve_clause_weight)
  return _internal_presolve_bve_clause_weight();
}
inline void SatParameters::set_presolve_bve_clause_weight(::int32_t value) {
  _internal_set_presolve_bve_clause_weight(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_bve_clause_weight)
}
inline ::int32_t SatParameters::_internal_presolve_bve_clause_weight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_bve_clause_weight_;
}
inline void SatParameters::_internal_set_presolve_bve_clause_weight(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00004000u;
  _impl_.presolve_bve_clause_weight_ = value;
}

// optional double probing_deterministic_time_limit = 226 [default = 1];
inline bool SatParameters::has_probing_deterministic_time_limit() const {
  bool value = (_impl_._has_bits_[6] & 0x00001000u) != 0;
  return value;
}
inline void SatParameters::clear_probing_deterministic_time_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.probing_deterministic_time_limit_ = 1;
  _impl_._has_bits_[6] &= ~0x00001000u;
}
inline double SatParameters::probing_deterministic_time_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.probing_deterministic_time_limit)
  return _internal_probing_deterministic_time_limit();
}
inline void SatParameters::set_probing_deterministic_time_limit(double value) {
  _internal_set_probing_deterministic_time_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.probing_deterministic_time_limit)
}
inline double SatParameters::_internal_probing_deterministic_time_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.probing_deterministic_time_limit_;
}
inline void SatParameters::_internal_set_probing_deterministic_time_limit(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00001000u;
  _impl_.probing_deterministic_time_limit_ = value;
}

// optional double presolve_probing_deterministic_time_limit = 57 [default = 30];
inline bool SatParameters::has_presolve_probing_deterministic_time_limit() const {
  bool value = (_impl_._has_bits_[3] & 0x00008000u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_probing_deterministic_time_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_probing_deterministic_time_limit_ = 30;
  _impl_._has_bits_[3] &= ~0x00008000u;
}
inline double SatParameters::presolve_probing_deterministic_time_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_probing_deterministic_time_limit)
  return _internal_presolve_probing_deterministic_time_limit();
}
inline void SatParameters::set_presolve_probing_deterministic_time_limit(double value) {
  _internal_set_presolve_probing_deterministic_time_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_probing_deterministic_time_limit)
}
inline double SatParameters::_internal_presolve_probing_deterministic_time_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_probing_deterministic_time_limit_;
}
inline void SatParameters::_internal_set_presolve_probing_deterministic_time_limit(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00008000u;
  _impl_.presolve_probing_deterministic_time_limit_ = value;
}

// optional bool presolve_blocked_clause = 88 [default = true];
inline bool SatParameters::has_presolve_blocked_clause() const {
  bool value = (_impl_._has_bits_[4] & 0x00000001u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_blocked_clause() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_blocked_clause_ = true;
  _impl_._has_bits_[4] &= ~0x00000001u;
}
inline bool SatParameters::presolve_blocked_clause() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_blocked_clause)
  return _internal_presolve_blocked_clause();
}
inline void SatParameters::set_presolve_blocked_clause(bool value) {
  _internal_set_presolve_blocked_clause(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_blocked_clause)
}
inline bool SatParameters::_internal_presolve_blocked_clause() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_blocked_clause_;
}
inline void SatParameters::_internal_set_presolve_blocked_clause(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000001u;
  _impl_.presolve_blocked_clause_ = value;
}

// optional bool presolve_use_bva = 72 [default = true];
inline bool SatParameters::has_presolve_use_bva() const {
  bool value = (_impl_._has_bits_[4] & 0x00000002u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_use_bva() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_use_bva_ = true;
  _impl_._has_bits_[4] &= ~0x00000002u;
}
inline bool SatParameters::presolve_use_bva() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_use_bva)
  return _internal_presolve_use_bva();
}
inline void SatParameters::set_presolve_use_bva(bool value) {
  _internal_set_presolve_use_bva(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_use_bva)
}
inline bool SatParameters::_internal_presolve_use_bva() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_use_bva_;
}
inline void SatParameters::_internal_set_presolve_use_bva(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000002u;
  _impl_.presolve_use_bva_ = value;
}

// optional int32 presolve_bva_threshold = 73 [default = 1];
inline bool SatParameters::has_presolve_bva_threshold() const {
  bool value = (_impl_._has_bits_[3] & 0x00400000u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_bva_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_bva_threshold_ = 1;
  _impl_._has_bits_[3] &= ~0x00400000u;
}
inline ::int32_t SatParameters::presolve_bva_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_bva_threshold)
  return _internal_presolve_bva_threshold();
}
inline void SatParameters::set_presolve_bva_threshold(::int32_t value) {
  _internal_set_presolve_bva_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_bva_threshold)
}
inline ::int32_t SatParameters::_internal_presolve_bva_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_bva_threshold_;
}
inline void SatParameters::_internal_set_presolve_bva_threshold(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00400000u;
  _impl_.presolve_bva_threshold_ = value;
}

// optional int32 max_presolve_iterations = 138 [default = 3];
inline bool SatParameters::has_max_presolve_iterations() const {
  bool value = (_impl_._has_bits_[4] & 0x20000000u) != 0;
  return value;
}
inline void SatParameters::clear_max_presolve_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_presolve_iterations_ = 3;
  _impl_._has_bits_[4] &= ~0x20000000u;
}
inline ::int32_t SatParameters::max_presolve_iterations() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_presolve_iterations)
  return _internal_max_presolve_iterations();
}
inline void SatParameters::set_max_presolve_iterations(::int32_t value) {
  _internal_set_max_presolve_iterations(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_presolve_iterations)
}
inline ::int32_t SatParameters::_internal_max_presolve_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_presolve_iterations_;
}
inline void SatParameters::_internal_set_max_presolve_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x20000000u;
  _impl_.max_presolve_iterations_ = value;
}

// optional bool cp_model_presolve = 86 [default = true];
inline bool SatParameters::has_cp_model_presolve() const {
  bool value = (_impl_._has_bits_[4] & 0x00000004u) != 0;
  return value;
}
inline void SatParameters::clear_cp_model_presolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cp_model_presolve_ = true;
  _impl_._has_bits_[4] &= ~0x00000004u;
}
inline bool SatParameters::cp_model_presolve() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.cp_model_presolve)
  return _internal_cp_model_presolve();
}
inline void SatParameters::set_cp_model_presolve(bool value) {
  _internal_set_cp_model_presolve(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.cp_model_presolve)
}
inline bool SatParameters::_internal_cp_model_presolve() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cp_model_presolve_;
}
inline void SatParameters::_internal_set_cp_model_presolve(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000004u;
  _impl_.cp_model_presolve_ = value;
}

// optional int32 cp_model_probing_level = 110 [default = 2];
inline bool SatParameters::has_cp_model_probing_level() const {
  bool value = (_impl_._has_bits_[4] & 0x00000400u) != 0;
  return value;
}
inline void SatParameters::clear_cp_model_probing_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cp_model_probing_level_ = 2;
  _impl_._has_bits_[4] &= ~0x00000400u;
}
inline ::int32_t SatParameters::cp_model_probing_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.cp_model_probing_level)
  return _internal_cp_model_probing_level();
}
inline void SatParameters::set_cp_model_probing_level(::int32_t value) {
  _internal_set_cp_model_probing_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.cp_model_probing_level)
}
inline ::int32_t SatParameters::_internal_cp_model_probing_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cp_model_probing_level_;
}
inline void SatParameters::_internal_set_cp_model_probing_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000400u;
  _impl_.cp_model_probing_level_ = value;
}

// optional bool cp_model_use_sat_presolve = 93 [default = true];
inline bool SatParameters::has_cp_model_use_sat_presolve() const {
  bool value = (_impl_._has_bits_[4] & 0x00000008u) != 0;
  return value;
}
inline void SatParameters::clear_cp_model_use_sat_presolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cp_model_use_sat_presolve_ = true;
  _impl_._has_bits_[4] &= ~0x00000008u;
}
inline bool SatParameters::cp_model_use_sat_presolve() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.cp_model_use_sat_presolve)
  return _internal_cp_model_use_sat_presolve();
}
inline void SatParameters::set_cp_model_use_sat_presolve(bool value) {
  _internal_set_cp_model_use_sat_presolve(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.cp_model_use_sat_presolve)
}
inline bool SatParameters::_internal_cp_model_use_sat_presolve() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cp_model_use_sat_presolve_;
}
inline void SatParameters::_internal_set_cp_model_use_sat_presolve(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000008u;
  _impl_.cp_model_use_sat_presolve_ = value;
}

// optional bool use_sat_inprocessing = 163 [default = false];
inline bool SatParameters::has_use_sat_inprocessing() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void SatParameters::clear_use_sat_inprocessing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_sat_inprocessing_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool SatParameters::use_sat_inprocessing() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_sat_inprocessing)
  return _internal_use_sat_inprocessing();
}
inline void SatParameters::set_use_sat_inprocessing(bool value) {
  _internal_set_use_sat_inprocessing(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_sat_inprocessing)
}
inline bool SatParameters::_internal_use_sat_inprocessing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_sat_inprocessing_;
}
inline void SatParameters::_internal_set_use_sat_inprocessing(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.use_sat_inprocessing_ = value;
}

// optional bool detect_table_with_cost = 216 [default = false];
inline bool SatParameters::has_detect_table_with_cost() const {
  bool value = (_impl_._has_bits_[2] & 0x00000010u) != 0;
  return value;
}
inline void SatParameters::clear_detect_table_with_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.detect_table_with_cost_ = false;
  _impl_._has_bits_[2] &= ~0x00000010u;
}
inline bool SatParameters::detect_table_with_cost() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.detect_table_with_cost)
  return _internal_detect_table_with_cost();
}
inline void SatParameters::set_detect_table_with_cost(bool value) {
  _internal_set_detect_table_with_cost(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.detect_table_with_cost)
}
inline bool SatParameters::_internal_detect_table_with_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.detect_table_with_cost_;
}
inline void SatParameters::_internal_set_detect_table_with_cost(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000010u;
  _impl_.detect_table_with_cost_ = value;
}

// optional int32 table_compression_level = 217 [default = 2];
inline bool SatParameters::has_table_compression_level() const {
  bool value = (_impl_._has_bits_[6] & 0x00000400u) != 0;
  return value;
}
inline void SatParameters::clear_table_compression_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.table_compression_level_ = 2;
  _impl_._has_bits_[6] &= ~0x00000400u;
}
inline ::int32_t SatParameters::table_compression_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.table_compression_level)
  return _internal_table_compression_level();
}
inline void SatParameters::set_table_compression_level(::int32_t value) {
  _internal_set_table_compression_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.table_compression_level)
}
inline ::int32_t SatParameters::_internal_table_compression_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.table_compression_level_;
}
inline void SatParameters::_internal_set_table_compression_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000400u;
  _impl_.table_compression_level_ = value;
}

// optional bool expand_alldiff_constraints = 170 [default = false];
inline bool SatParameters::has_expand_alldiff_constraints() const {
  bool value = (_impl_._has_bits_[2] & 0x00000020u) != 0;
  return value;
}
inline void SatParameters::clear_expand_alldiff_constraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expand_alldiff_constraints_ = false;
  _impl_._has_bits_[2] &= ~0x00000020u;
}
inline bool SatParameters::expand_alldiff_constraints() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.expand_alldiff_constraints)
  return _internal_expand_alldiff_constraints();
}
inline void SatParameters::set_expand_alldiff_constraints(bool value) {
  _internal_set_expand_alldiff_constraints(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.expand_alldiff_constraints)
}
inline bool SatParameters::_internal_expand_alldiff_constraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expand_alldiff_constraints_;
}
inline void SatParameters::_internal_set_expand_alldiff_constraints(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000020u;
  _impl_.expand_alldiff_constraints_ = value;
}

// optional bool expand_reservoir_constraints = 182 [default = true];
inline bool SatParameters::has_expand_reservoir_constraints() const {
  bool value = (_impl_._has_bits_[6] & 0x00000040u) != 0;
  return value;
}
inline void SatParameters::clear_expand_reservoir_constraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expand_reservoir_constraints_ = true;
  _impl_._has_bits_[6] &= ~0x00000040u;
}
inline bool SatParameters::expand_reservoir_constraints() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.expand_reservoir_constraints)
  return _internal_expand_reservoir_constraints();
}
inline void SatParameters::set_expand_reservoir_constraints(bool value) {
  _internal_set_expand_reservoir_constraints(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.expand_reservoir_constraints)
}
inline bool SatParameters::_internal_expand_reservoir_constraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expand_reservoir_constraints_;
}
inline void SatParameters::_internal_set_expand_reservoir_constraints(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000040u;
  _impl_.expand_reservoir_constraints_ = value;
}

// optional bool disable_constraint_expansion = 181 [default = false];
inline bool SatParameters::has_disable_constraint_expansion() const {
  bool value = (_impl_._has_bits_[2] & 0x00000040u) != 0;
  return value;
}
inline void SatParameters::clear_disable_constraint_expansion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disable_constraint_expansion_ = false;
  _impl_._has_bits_[2] &= ~0x00000040u;
}
inline bool SatParameters::disable_constraint_expansion() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.disable_constraint_expansion)
  return _internal_disable_constraint_expansion();
}
inline void SatParameters::set_disable_constraint_expansion(bool value) {
  _internal_set_disable_constraint_expansion(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.disable_constraint_expansion)
}
inline bool SatParameters::_internal_disable_constraint_expansion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_constraint_expansion_;
}
inline void SatParameters::_internal_set_disable_constraint_expansion(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000040u;
  _impl_.disable_constraint_expansion_ = value;
}

// optional bool encode_complex_linear_constraint_with_integer = 223 [default = false];
inline bool SatParameters::has_encode_complex_linear_constraint_with_integer() const {
  bool value = (_impl_._has_bits_[2] & 0x00000080u) != 0;
  return value;
}
inline void SatParameters::clear_encode_complex_linear_constraint_with_integer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encode_complex_linear_constraint_with_integer_ = false;
  _impl_._has_bits_[2] &= ~0x00000080u;
}
inline bool SatParameters::encode_complex_linear_constraint_with_integer() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.encode_complex_linear_constraint_with_integer)
  return _internal_encode_complex_linear_constraint_with_integer();
}
inline void SatParameters::set_encode_complex_linear_constraint_with_integer(bool value) {
  _internal_set_encode_complex_linear_constraint_with_integer(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.encode_complex_linear_constraint_with_integer)
}
inline bool SatParameters::_internal_encode_complex_linear_constraint_with_integer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encode_complex_linear_constraint_with_integer_;
}
inline void SatParameters::_internal_set_encode_complex_linear_constraint_with_integer(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000080u;
  _impl_.encode_complex_linear_constraint_with_integer_ = value;
}

// optional double merge_no_overlap_work_limit = 145 [default = 1000000000000];
inline bool SatParameters::has_merge_no_overlap_work_limit() const {
  bool value = (_impl_._has_bits_[5] & 0x00000004u) != 0;
  return value;
}
inline void SatParameters::clear_merge_no_overlap_work_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.merge_no_overlap_work_limit_ = 1000000000000;
  _impl_._has_bits_[5] &= ~0x00000004u;
}
inline double SatParameters::merge_no_overlap_work_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.merge_no_overlap_work_limit)
  return _internal_merge_no_overlap_work_limit();
}
inline void SatParameters::set_merge_no_overlap_work_limit(double value) {
  _internal_set_merge_no_overlap_work_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.merge_no_overlap_work_limit)
}
inline double SatParameters::_internal_merge_no_overlap_work_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.merge_no_overlap_work_limit_;
}
inline void SatParameters::_internal_set_merge_no_overlap_work_limit(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000004u;
  _impl_.merge_no_overlap_work_limit_ = value;
}

// optional double merge_at_most_one_work_limit = 146 [default = 100000000];
inline bool SatParameters::has_merge_at_most_one_work_limit() const {
  bool value = (_impl_._has_bits_[5] & 0x00000100u) != 0;
  return value;
}
inline void SatParameters::clear_merge_at_most_one_work_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.merge_at_most_one_work_limit_ = 100000000;
  _impl_._has_bits_[5] &= ~0x00000100u;
}
inline double SatParameters::merge_at_most_one_work_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.merge_at_most_one_work_limit)
  return _internal_merge_at_most_one_work_limit();
}
inline void SatParameters::set_merge_at_most_one_work_limit(double value) {
  _internal_set_merge_at_most_one_work_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.merge_at_most_one_work_limit)
}
inline double SatParameters::_internal_merge_at_most_one_work_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.merge_at_most_one_work_limit_;
}
inline void SatParameters::_internal_set_merge_at_most_one_work_limit(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000100u;
  _impl_.merge_at_most_one_work_limit_ = value;
}

// optional int32 presolve_substitution_level = 147 [default = 1];
inline bool SatParameters::has_presolve_substitution_level() const {
  bool value = (_impl_._has_bits_[5] & 0x00000080u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_substitution_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_substitution_level_ = 1;
  _impl_._has_bits_[5] &= ~0x00000080u;
}
inline ::int32_t SatParameters::presolve_substitution_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_substitution_level)
  return _internal_presolve_substitution_level();
}
inline void SatParameters::set_presolve_substitution_level(::int32_t value) {
  _internal_set_presolve_substitution_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_substitution_level)
}
inline ::int32_t SatParameters::_internal_presolve_substitution_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_substitution_level_;
}
inline void SatParameters::_internal_set_presolve_substitution_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000080u;
  _impl_.presolve_substitution_level_ = value;
}

// optional bool presolve_extract_integer_enforcement = 174 [default = false];
inline bool SatParameters::has_presolve_extract_integer_enforcement() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_extract_integer_enforcement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_extract_integer_enforcement_ = false;
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline bool SatParameters::presolve_extract_integer_enforcement() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_extract_integer_enforcement)
  return _internal_presolve_extract_integer_enforcement();
}
inline void SatParameters::set_presolve_extract_integer_enforcement(bool value) {
  _internal_set_presolve_extract_integer_enforcement(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_extract_integer_enforcement)
}
inline bool SatParameters::_internal_presolve_extract_integer_enforcement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_extract_integer_enforcement_;
}
inline void SatParameters::_internal_set_presolve_extract_integer_enforcement(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00100000u;
  _impl_.presolve_extract_integer_enforcement_ = value;
}

// optional int64 presolve_inclusion_work_limit = 201 [default = 100000000];
inline bool SatParameters::has_presolve_inclusion_work_limit() const {
  bool value = (_impl_._has_bits_[6] & 0x00000004u) != 0;
  return value;
}
inline void SatParameters::clear_presolve_inclusion_work_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.presolve_inclusion_work_limit_ = ::int64_t{100000000};
  _impl_._has_bits_[6] &= ~0x00000004u;
}
inline ::int64_t SatParameters::presolve_inclusion_work_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.presolve_inclusion_work_limit)
  return _internal_presolve_inclusion_work_limit();
}
inline void SatParameters::set_presolve_inclusion_work_limit(::int64_t value) {
  _internal_set_presolve_inclusion_work_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.presolve_inclusion_work_limit)
}
inline ::int64_t SatParameters::_internal_presolve_inclusion_work_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.presolve_inclusion_work_limit_;
}
inline void SatParameters::_internal_set_presolve_inclusion_work_limit(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000004u;
  _impl_.presolve_inclusion_work_limit_ = value;
}

// optional bool ignore_names = 202 [default = true];
inline bool SatParameters::has_ignore_names() const {
  bool value = (_impl_._has_bits_[6] & 0x00000080u) != 0;
  return value;
}
inline void SatParameters::clear_ignore_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_names_ = true;
  _impl_._has_bits_[6] &= ~0x00000080u;
}
inline bool SatParameters::ignore_names() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.ignore_names)
  return _internal_ignore_names();
}
inline void SatParameters::set_ignore_names(bool value) {
  _internal_set_ignore_names(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.ignore_names)
}
inline bool SatParameters::_internal_ignore_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_names_;
}
inline void SatParameters::_internal_set_ignore_names(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000080u;
  _impl_.ignore_names_ = value;
}

// optional bool infer_all_diffs = 233 [default = true];
inline bool SatParameters::has_infer_all_diffs() const {
  bool value = (_impl_._has_bits_[6] & 0x00000100u) != 0;
  return value;
}
inline void SatParameters::clear_infer_all_diffs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.infer_all_diffs_ = true;
  _impl_._has_bits_[6] &= ~0x00000100u;
}
inline bool SatParameters::infer_all_diffs() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.infer_all_diffs)
  return _internal_infer_all_diffs();
}
inline void SatParameters::set_infer_all_diffs(bool value) {
  _internal_set_infer_all_diffs(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.infer_all_diffs)
}
inline bool SatParameters::_internal_infer_all_diffs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.infer_all_diffs_;
}
inline void SatParameters::_internal_set_infer_all_diffs(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000100u;
  _impl_.infer_all_diffs_ = value;
}

// optional bool find_big_linear_overlap = 234 [default = true];
inline bool SatParameters::has_find_big_linear_overlap() const {
  bool value = (_impl_._has_bits_[6] & 0x00000200u) != 0;
  return value;
}
inline void SatParameters::clear_find_big_linear_overlap() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.find_big_linear_overlap_ = true;
  _impl_._has_bits_[6] &= ~0x00000200u;
}
inline bool SatParameters::find_big_linear_overlap() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.find_big_linear_overlap)
  return _internal_find_big_linear_overlap();
}
inline void SatParameters::set_find_big_linear_overlap(bool value) {
  _internal_set_find_big_linear_overlap(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.find_big_linear_overlap)
}
inline bool SatParameters::_internal_find_big_linear_overlap() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.find_big_linear_overlap_;
}
inline void SatParameters::_internal_set_find_big_linear_overlap(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000200u;
  _impl_.find_big_linear_overlap_ = value;
}

// optional int32 num_workers = 206 [default = 0];
inline bool SatParameters::has_num_workers() const {
  bool value = (_impl_._has_bits_[2] & 0x00010000u) != 0;
  return value;
}
inline void SatParameters::clear_num_workers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_workers_ = 0;
  _impl_._has_bits_[2] &= ~0x00010000u;
}
inline ::int32_t SatParameters::num_workers() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.num_workers)
  return _internal_num_workers();
}
inline void SatParameters::set_num_workers(::int32_t value) {
  _internal_set_num_workers(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.num_workers)
}
inline ::int32_t SatParameters::_internal_num_workers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_workers_;
}
inline void SatParameters::_internal_set_num_workers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00010000u;
  _impl_.num_workers_ = value;
}

// optional int32 num_search_workers = 100 [default = 0];
inline bool SatParameters::has_num_search_workers() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void SatParameters::clear_num_search_workers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_search_workers_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::int32_t SatParameters::num_search_workers() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.num_search_workers)
  return _internal_num_search_workers();
}
inline void SatParameters::set_num_search_workers(::int32_t value) {
  _internal_set_num_search_workers(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.num_search_workers)
}
inline ::int32_t SatParameters::_internal_num_search_workers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_search_workers_;
}
inline void SatParameters::_internal_set_num_search_workers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.num_search_workers_ = value;
}

// optional int32 min_num_lns_workers = 211 [default = 2];
inline bool SatParameters::has_min_num_lns_workers() const {
  bool value = (_impl_._has_bits_[6] & 0x00000010u) != 0;
  return value;
}
inline void SatParameters::clear_min_num_lns_workers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_num_lns_workers_ = 2;
  _impl_._has_bits_[6] &= ~0x00000010u;
}
inline ::int32_t SatParameters::min_num_lns_workers() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.min_num_lns_workers)
  return _internal_min_num_lns_workers();
}
inline void SatParameters::set_min_num_lns_workers(::int32_t value) {
  _internal_set_min_num_lns_workers(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.min_num_lns_workers)
}
inline ::int32_t SatParameters::_internal_min_num_lns_workers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_num_lns_workers_;
}
inline void SatParameters::_internal_set_min_num_lns_workers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000010u;
  _impl_.min_num_lns_workers_ = value;
}

// repeated string subsolvers = 207;
inline int SatParameters::_internal_subsolvers_size() const {
  return _internal_subsolvers().size();
}
inline int SatParameters::subsolvers_size() const {
  return _internal_subsolvers_size();
}
inline void SatParameters::clear_subsolvers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subsolvers_.Clear();
}
inline std::string* SatParameters::add_subsolvers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_subsolvers()->Add();
  // @@protoc_insertion_point(field_add_mutable:operations_research.sat.SatParameters.subsolvers)
  return _s;
}
inline const std::string& SatParameters::subsolvers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.subsolvers)
  return _internal_subsolvers().Get(index);
}
inline std::string* SatParameters::mutable_subsolvers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SatParameters.subsolvers)
  return _internal_mutable_subsolvers()->Mutable(index);
}
inline void SatParameters::set_subsolvers(int index, const std::string& value) {
  _internal_mutable_subsolvers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::set_subsolvers(int index, std::string&& value) {
  _internal_mutable_subsolvers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::set_subsolvers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subsolvers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::set_subsolvers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_subsolvers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::set_subsolvers(int index, absl::string_view value) {
  _internal_mutable_subsolvers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::add_subsolvers(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_subsolvers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::add_subsolvers(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_subsolvers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::add_subsolvers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_subsolvers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::add_subsolvers(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_subsolvers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:operations_research.sat.SatParameters.subsolvers)
}
inline void SatParameters::add_subsolvers(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_subsolvers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:operations_research.sat.SatParameters.subsolvers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SatParameters::subsolvers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SatParameters.subsolvers)
  return _internal_subsolvers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SatParameters::mutable_subsolvers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SatParameters.subsolvers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_subsolvers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SatParameters::_internal_subsolvers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subsolvers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SatParameters::_internal_mutable_subsolvers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.subsolvers_;
}

// repeated string extra_subsolvers = 219;
inline int SatParameters::_internal_extra_subsolvers_size() const {
  return _internal_extra_subsolvers().size();
}
inline int SatParameters::extra_subsolvers_size() const {
  return _internal_extra_subsolvers_size();
}
inline void SatParameters::clear_extra_subsolvers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extra_subsolvers_.Clear();
}
inline std::string* SatParameters::add_extra_subsolvers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_extra_subsolvers()->Add();
  // @@protoc_insertion_point(field_add_mutable:operations_research.sat.SatParameters.extra_subsolvers)
  return _s;
}
inline const std::string& SatParameters::extra_subsolvers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.extra_subsolvers)
  return _internal_extra_subsolvers().Get(index);
}
inline std::string* SatParameters::mutable_extra_subsolvers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SatParameters.extra_subsolvers)
  return _internal_mutable_extra_subsolvers()->Mutable(index);
}
inline void SatParameters::set_extra_subsolvers(int index, const std::string& value) {
  _internal_mutable_extra_subsolvers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::set_extra_subsolvers(int index, std::string&& value) {
  _internal_mutable_extra_subsolvers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::set_extra_subsolvers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_extra_subsolvers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::set_extra_subsolvers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_extra_subsolvers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::set_extra_subsolvers(int index, absl::string_view value) {
  _internal_mutable_extra_subsolvers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::add_extra_subsolvers(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extra_subsolvers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::add_extra_subsolvers(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extra_subsolvers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::add_extra_subsolvers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extra_subsolvers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::add_extra_subsolvers(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extra_subsolvers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:operations_research.sat.SatParameters.extra_subsolvers)
}
inline void SatParameters::add_extra_subsolvers(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_extra_subsolvers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:operations_research.sat.SatParameters.extra_subsolvers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SatParameters::extra_subsolvers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SatParameters.extra_subsolvers)
  return _internal_extra_subsolvers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SatParameters::mutable_extra_subsolvers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SatParameters.extra_subsolvers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extra_subsolvers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SatParameters::_internal_extra_subsolvers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extra_subsolvers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SatParameters::_internal_mutable_extra_subsolvers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extra_subsolvers_;
}

// repeated string ignore_subsolvers = 209;
inline int SatParameters::_internal_ignore_subsolvers_size() const {
  return _internal_ignore_subsolvers().size();
}
inline int SatParameters::ignore_subsolvers_size() const {
  return _internal_ignore_subsolvers_size();
}
inline void SatParameters::clear_ignore_subsolvers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_subsolvers_.Clear();
}
inline std::string* SatParameters::add_ignore_subsolvers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_ignore_subsolvers()->Add();
  // @@protoc_insertion_point(field_add_mutable:operations_research.sat.SatParameters.ignore_subsolvers)
  return _s;
}
inline const std::string& SatParameters::ignore_subsolvers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.ignore_subsolvers)
  return _internal_ignore_subsolvers().Get(index);
}
inline std::string* SatParameters::mutable_ignore_subsolvers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SatParameters.ignore_subsolvers)
  return _internal_mutable_ignore_subsolvers()->Mutable(index);
}
inline void SatParameters::set_ignore_subsolvers(int index, const std::string& value) {
  _internal_mutable_ignore_subsolvers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::set_ignore_subsolvers(int index, std::string&& value) {
  _internal_mutable_ignore_subsolvers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::set_ignore_subsolvers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_ignore_subsolvers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::set_ignore_subsolvers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_ignore_subsolvers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::set_ignore_subsolvers(int index, absl::string_view value) {
  _internal_mutable_ignore_subsolvers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::add_ignore_subsolvers(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ignore_subsolvers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::add_ignore_subsolvers(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ignore_subsolvers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::add_ignore_subsolvers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ignore_subsolvers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::add_ignore_subsolvers(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ignore_subsolvers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline void SatParameters::add_ignore_subsolvers(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ignore_subsolvers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:operations_research.sat.SatParameters.ignore_subsolvers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SatParameters::ignore_subsolvers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SatParameters.ignore_subsolvers)
  return _internal_ignore_subsolvers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SatParameters::mutable_ignore_subsolvers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SatParameters.ignore_subsolvers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ignore_subsolvers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SatParameters::_internal_ignore_subsolvers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_subsolvers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SatParameters::_internal_mutable_ignore_subsolvers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ignore_subsolvers_;
}

// repeated .operations_research.sat.SatParameters subsolver_params = 210;
inline int SatParameters::_internal_subsolver_params_size() const {
  return _internal_subsolver_params().size();
}
inline int SatParameters::subsolver_params_size() const {
  return _internal_subsolver_params_size();
}
inline void SatParameters::clear_subsolver_params() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subsolver_params_.Clear();
}
inline ::operations_research::sat::SatParameters* SatParameters::mutable_subsolver_params(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SatParameters.subsolver_params)
  return _internal_mutable_subsolver_params()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::SatParameters>* SatParameters::mutable_subsolver_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SatParameters.subsolver_params)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_subsolver_params();
}
inline const ::operations_research::sat::SatParameters& SatParameters::subsolver_params(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.subsolver_params)
  return _internal_subsolver_params().Get(index);
}
inline ::operations_research::sat::SatParameters* SatParameters::add_subsolver_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::operations_research::sat::SatParameters* _add = _internal_mutable_subsolver_params()->Add();
  // @@protoc_insertion_point(field_add:operations_research.sat.SatParameters.subsolver_params)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::SatParameters>& SatParameters::subsolver_params() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SatParameters.subsolver_params)
  return _internal_subsolver_params();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::SatParameters>&
SatParameters::_internal_subsolver_params() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subsolver_params_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::SatParameters>*
SatParameters::_internal_mutable_subsolver_params() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.subsolver_params_;
}

// optional bool interleave_search = 136 [default = false];
inline bool SatParameters::has_interleave_search() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline void SatParameters::clear_interleave_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interleave_search_ = false;
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline bool SatParameters::interleave_search() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.interleave_search)
  return _internal_interleave_search();
}
inline void SatParameters::set_interleave_search(bool value) {
  _internal_set_interleave_search(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.interleave_search)
}
inline bool SatParameters::_internal_interleave_search() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interleave_search_;
}
inline void SatParameters::_internal_set_interleave_search(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00200000u;
  _impl_.interleave_search_ = value;
}

// optional int32 interleave_batch_size = 134 [default = 0];
inline bool SatParameters::has_interleave_batch_size() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void SatParameters::clear_interleave_batch_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interleave_batch_size_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline ::int32_t SatParameters::interleave_batch_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.interleave_batch_size)
  return _internal_interleave_batch_size();
}
inline void SatParameters::set_interleave_batch_size(::int32_t value) {
  _internal_set_interleave_batch_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.interleave_batch_size)
}
inline ::int32_t SatParameters::_internal_interleave_batch_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interleave_batch_size_;
}
inline void SatParameters::_internal_set_interleave_batch_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.interleave_batch_size_ = value;
}

// optional bool share_objective_bounds = 113 [default = true];
inline bool SatParameters::has_share_objective_bounds() const {
  bool value = (_impl_._has_bits_[4] & 0x00001000u) != 0;
  return value;
}
inline void SatParameters::clear_share_objective_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.share_objective_bounds_ = true;
  _impl_._has_bits_[4] &= ~0x00001000u;
}
inline bool SatParameters::share_objective_bounds() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.share_objective_bounds)
  return _internal_share_objective_bounds();
}
inline void SatParameters::set_share_objective_bounds(bool value) {
  _internal_set_share_objective_bounds(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.share_objective_bounds)
}
inline bool SatParameters::_internal_share_objective_bounds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.share_objective_bounds_;
}
inline void SatParameters::_internal_set_share_objective_bounds(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00001000u;
  _impl_.share_objective_bounds_ = value;
}

// optional bool share_level_zero_bounds = 114 [default = true];
inline bool SatParameters::has_share_level_zero_bounds() const {
  bool value = (_impl_._has_bits_[4] & 0x00002000u) != 0;
  return value;
}
inline void SatParameters::clear_share_level_zero_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.share_level_zero_bounds_ = true;
  _impl_._has_bits_[4] &= ~0x00002000u;
}
inline bool SatParameters::share_level_zero_bounds() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.share_level_zero_bounds)
  return _internal_share_level_zero_bounds();
}
inline void SatParameters::set_share_level_zero_bounds(bool value) {
  _internal_set_share_level_zero_bounds(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.share_level_zero_bounds)
}
inline bool SatParameters::_internal_share_level_zero_bounds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.share_level_zero_bounds_;
}
inline void SatParameters::_internal_set_share_level_zero_bounds(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00002000u;
  _impl_.share_level_zero_bounds_ = value;
}

// optional bool share_binary_clauses = 203 [default = true];
inline bool SatParameters::has_share_binary_clauses() const {
  bool value = (_impl_._has_bits_[4] & 0x00004000u) != 0;
  return value;
}
inline void SatParameters::clear_share_binary_clauses() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.share_binary_clauses_ = true;
  _impl_._has_bits_[4] &= ~0x00004000u;
}
inline bool SatParameters::share_binary_clauses() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.share_binary_clauses)
  return _internal_share_binary_clauses();
}
inline void SatParameters::set_share_binary_clauses(bool value) {
  _internal_set_share_binary_clauses(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.share_binary_clauses)
}
inline bool SatParameters::_internal_share_binary_clauses() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.share_binary_clauses_;
}
inline void SatParameters::_internal_set_share_binary_clauses(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00004000u;
  _impl_.share_binary_clauses_ = value;
}

// optional bool debug_postsolve_with_full_solver = 162 [default = false];
inline bool SatParameters::has_debug_postsolve_with_full_solver() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline void SatParameters::clear_debug_postsolve_with_full_solver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.debug_postsolve_with_full_solver_ = false;
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline bool SatParameters::debug_postsolve_with_full_solver() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.debug_postsolve_with_full_solver)
  return _internal_debug_postsolve_with_full_solver();
}
inline void SatParameters::set_debug_postsolve_with_full_solver(bool value) {
  _internal_set_debug_postsolve_with_full_solver(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.debug_postsolve_with_full_solver)
}
inline bool SatParameters::_internal_debug_postsolve_with_full_solver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.debug_postsolve_with_full_solver_;
}
inline void SatParameters::_internal_set_debug_postsolve_with_full_solver(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00400000u;
  _impl_.debug_postsolve_with_full_solver_ = value;
}

// optional int32 debug_max_num_presolve_operations = 151 [default = 0];
inline bool SatParameters::has_debug_max_num_presolve_operations() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline void SatParameters::clear_debug_max_num_presolve_operations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.debug_max_num_presolve_operations_ = 0;
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline ::int32_t SatParameters::debug_max_num_presolve_operations() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.debug_max_num_presolve_operations)
  return _internal_debug_max_num_presolve_operations();
}
inline void SatParameters::set_debug_max_num_presolve_operations(::int32_t value) {
  _internal_set_debug_max_num_presolve_operations(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.debug_max_num_presolve_operations)
}
inline ::int32_t SatParameters::_internal_debug_max_num_presolve_operations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.debug_max_num_presolve_operations_;
}
inline void SatParameters::_internal_set_debug_max_num_presolve_operations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.debug_max_num_presolve_operations_ = value;
}

// optional bool debug_crash_on_bad_hint = 195 [default = false];
inline bool SatParameters::has_debug_crash_on_bad_hint() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline void SatParameters::clear_debug_crash_on_bad_hint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.debug_crash_on_bad_hint_ = false;
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline bool SatParameters::debug_crash_on_bad_hint() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.debug_crash_on_bad_hint)
  return _internal_debug_crash_on_bad_hint();
}
inline void SatParameters::set_debug_crash_on_bad_hint(bool value) {
  _internal_set_debug_crash_on_bad_hint(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.debug_crash_on_bad_hint)
}
inline bool SatParameters::_internal_debug_crash_on_bad_hint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.debug_crash_on_bad_hint_;
}
inline void SatParameters::_internal_set_debug_crash_on_bad_hint(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00800000u;
  _impl_.debug_crash_on_bad_hint_ = value;
}

// optional bool use_optimization_hints = 35 [default = true];
inline bool SatParameters::has_use_optimization_hints() const {
  bool value = (_impl_._has_bits_[4] & 0x00008000u) != 0;
  return value;
}
inline void SatParameters::clear_use_optimization_hints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_optimization_hints_ = true;
  _impl_._has_bits_[4] &= ~0x00008000u;
}
inline bool SatParameters::use_optimization_hints() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_optimization_hints)
  return _internal_use_optimization_hints();
}
inline void SatParameters::set_use_optimization_hints(bool value) {
  _internal_set_use_optimization_hints(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_optimization_hints)
}
inline bool SatParameters::_internal_use_optimization_hints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_optimization_hints_;
}
inline void SatParameters::_internal_set_use_optimization_hints(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00008000u;
  _impl_.use_optimization_hints_ = value;
}

// optional int32 core_minimization_level = 50 [default = 2];
inline bool SatParameters::has_core_minimization_level() const {
  bool value = (_impl_._has_bits_[3] & 0x00000800u) != 0;
  return value;
}
inline void SatParameters::clear_core_minimization_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.core_minimization_level_ = 2;
  _impl_._has_bits_[3] &= ~0x00000800u;
}
inline ::int32_t SatParameters::core_minimization_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.core_minimization_level)
  return _internal_core_minimization_level();
}
inline void SatParameters::set_core_minimization_level(::int32_t value) {
  _internal_set_core_minimization_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.core_minimization_level)
}
inline ::int32_t SatParameters::_internal_core_minimization_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.core_minimization_level_;
}
inline void SatParameters::_internal_set_core_minimization_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x00000800u;
  _impl_.core_minimization_level_ = value;
}

// optional bool find_multiple_cores = 84 [default = true];
inline bool SatParameters::has_find_multiple_cores() const {
  bool value = (_impl_._has_bits_[3] & 0x01000000u) != 0;
  return value;
}
inline void SatParameters::clear_find_multiple_cores() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.find_multiple_cores_ = true;
  _impl_._has_bits_[3] &= ~0x01000000u;
}
inline bool SatParameters::find_multiple_cores() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.find_multiple_cores)
  return _internal_find_multiple_cores();
}
inline void SatParameters::set_find_multiple_cores(bool value) {
  _internal_set_find_multiple_cores(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.find_multiple_cores)
}
inline bool SatParameters::_internal_find_multiple_cores() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.find_multiple_cores_;
}
inline void SatParameters::_internal_set_find_multiple_cores(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x01000000u;
  _impl_.find_multiple_cores_ = value;
}

// optional bool cover_optimization = 89 [default = true];
inline bool SatParameters::has_cover_optimization() const {
  bool value = (_impl_._has_bits_[3] & 0x02000000u) != 0;
  return value;
}
inline void SatParameters::clear_cover_optimization() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cover_optimization_ = true;
  _impl_._has_bits_[3] &= ~0x02000000u;
}
inline bool SatParameters::cover_optimization() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.cover_optimization)
  return _internal_cover_optimization();
}
inline void SatParameters::set_cover_optimization(bool value) {
  _internal_set_cover_optimization(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.cover_optimization)
}
inline bool SatParameters::_internal_cover_optimization() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cover_optimization_;
}
inline void SatParameters::_internal_set_cover_optimization(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x02000000u;
  _impl_.cover_optimization_ = value;
}

// optional .operations_research.sat.SatParameters.MaxSatAssumptionOrder max_sat_assumption_order = 51 [default = DEFAULT_ASSUMPTION_ORDER];
inline bool SatParameters::has_max_sat_assumption_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SatParameters::clear_max_sat_assumption_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_sat_assumption_order_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::operations_research::sat::SatParameters_MaxSatAssumptionOrder SatParameters::max_sat_assumption_order() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_sat_assumption_order)
  return _internal_max_sat_assumption_order();
}
inline void SatParameters::set_max_sat_assumption_order(::operations_research::sat::SatParameters_MaxSatAssumptionOrder value) {
  _internal_set_max_sat_assumption_order(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_sat_assumption_order)
}
inline ::operations_research::sat::SatParameters_MaxSatAssumptionOrder SatParameters::_internal_max_sat_assumption_order() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_MaxSatAssumptionOrder>(_impl_.max_sat_assumption_order_);
}
inline void SatParameters::_internal_set_max_sat_assumption_order(::operations_research::sat::SatParameters_MaxSatAssumptionOrder value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_MaxSatAssumptionOrder_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.max_sat_assumption_order_ = value;
}

// optional bool max_sat_reverse_assumption_order = 52 [default = false];
inline bool SatParameters::has_max_sat_reverse_assumption_order() const {
  bool value = (_impl_._has_bits_[2] & 0x00000100u) != 0;
  return value;
}
inline void SatParameters::clear_max_sat_reverse_assumption_order() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_sat_reverse_assumption_order_ = false;
  _impl_._has_bits_[2] &= ~0x00000100u;
}
inline bool SatParameters::max_sat_reverse_assumption_order() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_sat_reverse_assumption_order)
  return _internal_max_sat_reverse_assumption_order();
}
inline void SatParameters::set_max_sat_reverse_assumption_order(bool value) {
  _internal_set_max_sat_reverse_assumption_order(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_sat_reverse_assumption_order)
}
inline bool SatParameters::_internal_max_sat_reverse_assumption_order() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_sat_reverse_assumption_order_;
}
inline void SatParameters::_internal_set_max_sat_reverse_assumption_order(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000100u;
  _impl_.max_sat_reverse_assumption_order_ = value;
}

// optional .operations_research.sat.SatParameters.MaxSatStratificationAlgorithm max_sat_stratification = 53 [default = STRATIFICATION_DESCENT];
inline bool SatParameters::has_max_sat_stratification() const {
  bool value = (_impl_._has_bits_[3] & 0x00001000u) != 0;
  return value;
}
inline void SatParameters::clear_max_sat_stratification() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_sat_stratification_ = 1;
  _impl_._has_bits_[3] &= ~0x00001000u;
}
inline ::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm SatParameters::max_sat_stratification() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_sat_stratification)
  return _internal_max_sat_stratification();
}
inline void SatParameters::set_max_sat_stratification(::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm value) {
  _internal_set_max_sat_stratification(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_sat_stratification)
}
inline ::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm SatParameters::_internal_max_sat_stratification() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm>(_impl_.max_sat_stratification_);
}
inline void SatParameters::_internal_set_max_sat_stratification(::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm_IsValid(value));
  _impl_._has_bits_[3] |= 0x00001000u;
  _impl_.max_sat_stratification_ = value;
}

// optional double propagation_loop_detection_factor = 221 [default = 10];
inline bool SatParameters::has_propagation_loop_detection_factor() const {
  bool value = (_impl_._has_bits_[6] & 0x00000800u) != 0;
  return value;
}
inline void SatParameters::clear_propagation_loop_detection_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.propagation_loop_detection_factor_ = 10;
  _impl_._has_bits_[6] &= ~0x00000800u;
}
inline double SatParameters::propagation_loop_detection_factor() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.propagation_loop_detection_factor)
  return _internal_propagation_loop_detection_factor();
}
inline void SatParameters::set_propagation_loop_detection_factor(double value) {
  _internal_set_propagation_loop_detection_factor(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.propagation_loop_detection_factor)
}
inline double SatParameters::_internal_propagation_loop_detection_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.propagation_loop_detection_factor_;
}
inline void SatParameters::_internal_set_propagation_loop_detection_factor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000800u;
  _impl_.propagation_loop_detection_factor_ = value;
}

// optional bool use_precedences_in_disjunctive_constraint = 74 [default = true];
inline bool SatParameters::has_use_precedences_in_disjunctive_constraint() const {
  bool value = (_impl_._has_bits_[3] & 0x04000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_precedences_in_disjunctive_constraint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_precedences_in_disjunctive_constraint_ = true;
  _impl_._has_bits_[3] &= ~0x04000000u;
}
inline bool SatParameters::use_precedences_in_disjunctive_constraint() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_precedences_in_disjunctive_constraint)
  return _internal_use_precedences_in_disjunctive_constraint();
}
inline void SatParameters::set_use_precedences_in_disjunctive_constraint(bool value) {
  _internal_set_use_precedences_in_disjunctive_constraint(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_precedences_in_disjunctive_constraint)
}
inline bool SatParameters::_internal_use_precedences_in_disjunctive_constraint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_precedences_in_disjunctive_constraint_;
}
inline void SatParameters::_internal_set_use_precedences_in_disjunctive_constraint(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x04000000u;
  _impl_.use_precedences_in_disjunctive_constraint_ = value;
}

// optional int32 max_size_to_create_precedence_literals_in_disjunctive = 229 [default = 60];
inline bool SatParameters::has_max_size_to_create_precedence_literals_in_disjunctive() const {
  bool value = (_impl_._has_bits_[6] & 0x00004000u) != 0;
  return value;
}
inline void SatParameters::clear_max_size_to_create_precedence_literals_in_disjunctive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_size_to_create_precedence_literals_in_disjunctive_ = 60;
  _impl_._has_bits_[6] &= ~0x00004000u;
}
inline ::int32_t SatParameters::max_size_to_create_precedence_literals_in_disjunctive() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_size_to_create_precedence_literals_in_disjunctive)
  return _internal_max_size_to_create_precedence_literals_in_disjunctive();
}
inline void SatParameters::set_max_size_to_create_precedence_literals_in_disjunctive(::int32_t value) {
  _internal_set_max_size_to_create_precedence_literals_in_disjunctive(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_size_to_create_precedence_literals_in_disjunctive)
}
inline ::int32_t SatParameters::_internal_max_size_to_create_precedence_literals_in_disjunctive() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_size_to_create_precedence_literals_in_disjunctive_;
}
inline void SatParameters::_internal_set_max_size_to_create_precedence_literals_in_disjunctive(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00004000u;
  _impl_.max_size_to_create_precedence_literals_in_disjunctive_ = value;
}

// optional bool use_strong_propagation_in_disjunctive = 230 [default = false];
inline bool SatParameters::has_use_strong_propagation_in_disjunctive() const {
  bool value = (_impl_._has_bits_[2] & 0x00000200u) != 0;
  return value;
}
inline void SatParameters::clear_use_strong_propagation_in_disjunctive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_strong_propagation_in_disjunctive_ = false;
  _impl_._has_bits_[2] &= ~0x00000200u;
}
inline bool SatParameters::use_strong_propagation_in_disjunctive() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_strong_propagation_in_disjunctive)
  return _internal_use_strong_propagation_in_disjunctive();
}
inline void SatParameters::set_use_strong_propagation_in_disjunctive(bool value) {
  _internal_set_use_strong_propagation_in_disjunctive(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_strong_propagation_in_disjunctive)
}
inline bool SatParameters::_internal_use_strong_propagation_in_disjunctive() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_strong_propagation_in_disjunctive_;
}
inline void SatParameters::_internal_set_use_strong_propagation_in_disjunctive(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000200u;
  _impl_.use_strong_propagation_in_disjunctive_ = value;
}

// optional bool use_dynamic_precedence_in_disjunctive = 263 [default = false];
inline bool SatParameters::has_use_dynamic_precedence_in_disjunctive() const {
  bool value = (_impl_._has_bits_[2] & 0x00000400u) != 0;
  return value;
}
inline void SatParameters::clear_use_dynamic_precedence_in_disjunctive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_dynamic_precedence_in_disjunctive_ = false;
  _impl_._has_bits_[2] &= ~0x00000400u;
}
inline bool SatParameters::use_dynamic_precedence_in_disjunctive() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_dynamic_precedence_in_disjunctive)
  return _internal_use_dynamic_precedence_in_disjunctive();
}
inline void SatParameters::set_use_dynamic_precedence_in_disjunctive(bool value) {
  _internal_set_use_dynamic_precedence_in_disjunctive(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_dynamic_precedence_in_disjunctive)
}
inline bool SatParameters::_internal_use_dynamic_precedence_in_disjunctive() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_dynamic_precedence_in_disjunctive_;
}
inline void SatParameters::_internal_set_use_dynamic_precedence_in_disjunctive(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000400u;
  _impl_.use_dynamic_precedence_in_disjunctive_ = value;
}

// optional bool use_dynamic_precedence_in_cumulative = 268 [default = false];
inline bool SatParameters::has_use_dynamic_precedence_in_cumulative() const {
  bool value = (_impl_._has_bits_[2] & 0x00000800u) != 0;
  return value;
}
inline void SatParameters::clear_use_dynamic_precedence_in_cumulative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_dynamic_precedence_in_cumulative_ = false;
  _impl_._has_bits_[2] &= ~0x00000800u;
}
inline bool SatParameters::use_dynamic_precedence_in_cumulative() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_dynamic_precedence_in_cumulative)
  return _internal_use_dynamic_precedence_in_cumulative();
}
inline void SatParameters::set_use_dynamic_precedence_in_cumulative(bool value) {
  _internal_set_use_dynamic_precedence_in_cumulative(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_dynamic_precedence_in_cumulative)
}
inline bool SatParameters::_internal_use_dynamic_precedence_in_cumulative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_dynamic_precedence_in_cumulative_;
}
inline void SatParameters::_internal_set_use_dynamic_precedence_in_cumulative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000800u;
  _impl_.use_dynamic_precedence_in_cumulative_ = value;
}

// optional bool use_overload_checker_in_cumulative = 78 [default = false];
inline bool SatParameters::has_use_overload_checker_in_cumulative() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_overload_checker_in_cumulative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_overload_checker_in_cumulative_ = false;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline bool SatParameters::use_overload_checker_in_cumulative() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_overload_checker_in_cumulative)
  return _internal_use_overload_checker_in_cumulative();
}
inline void SatParameters::set_use_overload_checker_in_cumulative(bool value) {
  _internal_set_use_overload_checker_in_cumulative(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_overload_checker_in_cumulative)
}
inline bool SatParameters::_internal_use_overload_checker_in_cumulative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_overload_checker_in_cumulative_;
}
inline void SatParameters::_internal_set_use_overload_checker_in_cumulative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.use_overload_checker_in_cumulative_ = value;
}

// optional bool use_timetable_edge_finding_in_cumulative = 79 [default = false];
inline bool SatParameters::has_use_timetable_edge_finding_in_cumulative() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_timetable_edge_finding_in_cumulative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_timetable_edge_finding_in_cumulative_ = false;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline bool SatParameters::use_timetable_edge_finding_in_cumulative() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_timetable_edge_finding_in_cumulative)
  return _internal_use_timetable_edge_finding_in_cumulative();
}
inline void SatParameters::set_use_timetable_edge_finding_in_cumulative(bool value) {
  _internal_set_use_timetable_edge_finding_in_cumulative(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_timetable_edge_finding_in_cumulative)
}
inline bool SatParameters::_internal_use_timetable_edge_finding_in_cumulative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_timetable_edge_finding_in_cumulative_;
}
inline void SatParameters::_internal_set_use_timetable_edge_finding_in_cumulative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.use_timetable_edge_finding_in_cumulative_ = value;
}

// optional int32 max_num_intervals_for_timetable_edge_finding = 260 [default = 100];
inline bool SatParameters::has_max_num_intervals_for_timetable_edge_finding() const {
  bool value = (_impl_._has_bits_[6] & 0x02000000u) != 0;
  return value;
}
inline void SatParameters::clear_max_num_intervals_for_timetable_edge_finding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_num_intervals_for_timetable_edge_finding_ = 100;
  _impl_._has_bits_[6] &= ~0x02000000u;
}
inline ::int32_t SatParameters::max_num_intervals_for_timetable_edge_finding() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_num_intervals_for_timetable_edge_finding)
  return _internal_max_num_intervals_for_timetable_edge_finding();
}
inline void SatParameters::set_max_num_intervals_for_timetable_edge_finding(::int32_t value) {
  _internal_set_max_num_intervals_for_timetable_edge_finding(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_num_intervals_for_timetable_edge_finding)
}
inline ::int32_t SatParameters::_internal_max_num_intervals_for_timetable_edge_finding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_num_intervals_for_timetable_edge_finding_;
}
inline void SatParameters::_internal_set_max_num_intervals_for_timetable_edge_finding(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x02000000u;
  _impl_.max_num_intervals_for_timetable_edge_finding_ = value;
}

// optional bool use_hard_precedences_in_cumulative = 215 [default = false];
inline bool SatParameters::has_use_hard_precedences_in_cumulative() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline void SatParameters::clear_use_hard_precedences_in_cumulative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_hard_precedences_in_cumulative_ = false;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline bool SatParameters::use_hard_precedences_in_cumulative() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_hard_precedences_in_cumulative)
  return _internal_use_hard_precedences_in_cumulative();
}
inline void SatParameters::set_use_hard_precedences_in_cumulative(bool value) {
  _internal_set_use_hard_precedences_in_cumulative(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_hard_precedences_in_cumulative)
}
inline bool SatParameters::_internal_use_hard_precedences_in_cumulative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_hard_precedences_in_cumulative_;
}
inline void SatParameters::_internal_set_use_hard_precedences_in_cumulative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.use_hard_precedences_in_cumulative_ = value;
}

// optional bool exploit_all_precedences = 220 [default = false];
inline bool SatParameters::has_exploit_all_precedences() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline void SatParameters::clear_exploit_all_precedences() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exploit_all_precedences_ = false;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline bool SatParameters::exploit_all_precedences() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.exploit_all_precedences)
  return _internal_exploit_all_precedences();
}
inline void SatParameters::set_exploit_all_precedences(bool value) {
  _internal_set_exploit_all_precedences(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.exploit_all_precedences)
}
inline bool SatParameters::_internal_exploit_all_precedences() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exploit_all_precedences_;
}
inline void SatParameters::_internal_set_exploit_all_precedences(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.exploit_all_precedences_ = value;
}

// optional bool use_disjunctive_constraint_in_cumulative = 80 [default = true];
inline bool SatParameters::has_use_disjunctive_constraint_in_cumulative() const {
  bool value = (_impl_._has_bits_[3] & 0x08000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_disjunctive_constraint_in_cumulative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_disjunctive_constraint_in_cumulative_ = true;
  _impl_._has_bits_[3] &= ~0x08000000u;
}
inline bool SatParameters::use_disjunctive_constraint_in_cumulative() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_disjunctive_constraint_in_cumulative)
  return _internal_use_disjunctive_constraint_in_cumulative();
}
inline void SatParameters::set_use_disjunctive_constraint_in_cumulative(bool value) {
  _internal_set_use_disjunctive_constraint_in_cumulative(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_disjunctive_constraint_in_cumulative)
}
inline bool SatParameters::_internal_use_disjunctive_constraint_in_cumulative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_disjunctive_constraint_in_cumulative_;
}
inline void SatParameters::_internal_set_use_disjunctive_constraint_in_cumulative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[3] |= 0x08000000u;
  _impl_.use_disjunctive_constraint_in_cumulative_ = value;
}

// optional bool use_timetabling_in_no_overlap_2d = 200 [default = false];
inline bool SatParameters::has_use_timetabling_in_no_overlap_2d() const {
  bool value = (_impl_._has_bits_[2] & 0x00000001u) != 0;
  return value;
}
inline void SatParameters::clear_use_timetabling_in_no_overlap_2d() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_timetabling_in_no_overlap_2d_ = false;
  _impl_._has_bits_[2] &= ~0x00000001u;
}
inline bool SatParameters::use_timetabling_in_no_overlap_2d() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_timetabling_in_no_overlap_2d)
  return _internal_use_timetabling_in_no_overlap_2d();
}
inline void SatParameters::set_use_timetabling_in_no_overlap_2d(bool value) {
  _internal_set_use_timetabling_in_no_overlap_2d(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_timetabling_in_no_overlap_2d)
}
inline bool SatParameters::_internal_use_timetabling_in_no_overlap_2d() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_timetabling_in_no_overlap_2d_;
}
inline void SatParameters::_internal_set_use_timetabling_in_no_overlap_2d(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000001u;
  _impl_.use_timetabling_in_no_overlap_2d_ = value;
}

// optional bool use_energetic_reasoning_in_no_overlap_2d = 213 [default = false];
inline bool SatParameters::has_use_energetic_reasoning_in_no_overlap_2d() const {
  bool value = (_impl_._has_bits_[2] & 0x00000002u) != 0;
  return value;
}
inline void SatParameters::clear_use_energetic_reasoning_in_no_overlap_2d() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_energetic_reasoning_in_no_overlap_2d_ = false;
  _impl_._has_bits_[2] &= ~0x00000002u;
}
inline bool SatParameters::use_energetic_reasoning_in_no_overlap_2d() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_energetic_reasoning_in_no_overlap_2d)
  return _internal_use_energetic_reasoning_in_no_overlap_2d();
}
inline void SatParameters::set_use_energetic_reasoning_in_no_overlap_2d(bool value) {
  _internal_set_use_energetic_reasoning_in_no_overlap_2d(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_energetic_reasoning_in_no_overlap_2d)
}
inline bool SatParameters::_internal_use_energetic_reasoning_in_no_overlap_2d() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_energetic_reasoning_in_no_overlap_2d_;
}
inline void SatParameters::_internal_set_use_energetic_reasoning_in_no_overlap_2d(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000002u;
  _impl_.use_energetic_reasoning_in_no_overlap_2d_ = value;
}

// optional bool use_pairwise_reasoning_in_no_overlap_2d = 251 [default = false];
inline bool SatParameters::has_use_pairwise_reasoning_in_no_overlap_2d() const {
  bool value = (_impl_._has_bits_[2] & 0x00000004u) != 0;
  return value;
}
inline void SatParameters::clear_use_pairwise_reasoning_in_no_overlap_2d() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_pairwise_reasoning_in_no_overlap_2d_ = false;
  _impl_._has_bits_[2] &= ~0x00000004u;
}
inline bool SatParameters::use_pairwise_reasoning_in_no_overlap_2d() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_pairwise_reasoning_in_no_overlap_2d)
  return _internal_use_pairwise_reasoning_in_no_overlap_2d();
}
inline void SatParameters::set_use_pairwise_reasoning_in_no_overlap_2d(bool value) {
  _internal_set_use_pairwise_reasoning_in_no_overlap_2d(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_pairwise_reasoning_in_no_overlap_2d)
}
inline bool SatParameters::_internal_use_pairwise_reasoning_in_no_overlap_2d() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_pairwise_reasoning_in_no_overlap_2d_;
}
inline void SatParameters::_internal_set_use_pairwise_reasoning_in_no_overlap_2d(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000004u;
  _impl_.use_pairwise_reasoning_in_no_overlap_2d_ = value;
}

// optional bool use_dual_scheduling_heuristics = 214 [default = true];
inline bool SatParameters::has_use_dual_scheduling_heuristics() const {
  bool value = (_impl_._has_bits_[5] & 0x00001000u) != 0;
  return value;
}
inline void SatParameters::clear_use_dual_scheduling_heuristics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_dual_scheduling_heuristics_ = true;
  _impl_._has_bits_[5] &= ~0x00001000u;
}
inline bool SatParameters::use_dual_scheduling_heuristics() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_dual_scheduling_heuristics)
  return _internal_use_dual_scheduling_heuristics();
}
inline void SatParameters::set_use_dual_scheduling_heuristics(bool value) {
  _internal_set_use_dual_scheduling_heuristics(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_dual_scheduling_heuristics)
}
inline bool SatParameters::_internal_use_dual_scheduling_heuristics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_dual_scheduling_heuristics_;
}
inline void SatParameters::_internal_set_use_dual_scheduling_heuristics(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00001000u;
  _impl_.use_dual_scheduling_heuristics_ = value;
}

// optional int32 linearization_level = 90 [default = 1];
inline bool SatParameters::has_linearization_level() const {
  bool value = (_impl_._has_bits_[4] & 0x00000010u) != 0;
  return value;
}
inline void SatParameters::clear_linearization_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linearization_level_ = 1;
  _impl_._has_bits_[4] &= ~0x00000010u;
}
inline ::int32_t SatParameters::linearization_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.linearization_level)
  return _internal_linearization_level();
}
inline void SatParameters::set_linearization_level(::int32_t value) {
  _internal_set_linearization_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.linearization_level)
}
inline ::int32_t SatParameters::_internal_linearization_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linearization_level_;
}
inline void SatParameters::_internal_set_linearization_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000010u;
  _impl_.linearization_level_ = value;
}

// optional int32 boolean_encoding_level = 107 [default = 1];
inline bool SatParameters::has_boolean_encoding_level() const {
  bool value = (_impl_._has_bits_[4] & 0x00000200u) != 0;
  return value;
}
inline void SatParameters::clear_boolean_encoding_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.boolean_encoding_level_ = 1;
  _impl_._has_bits_[4] &= ~0x00000200u;
}
inline ::int32_t SatParameters::boolean_encoding_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.boolean_encoding_level)
  return _internal_boolean_encoding_level();
}
inline void SatParameters::set_boolean_encoding_level(::int32_t value) {
  _internal_set_boolean_encoding_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.boolean_encoding_level)
}
inline ::int32_t SatParameters::_internal_boolean_encoding_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.boolean_encoding_level_;
}
inline void SatParameters::_internal_set_boolean_encoding_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000200u;
  _impl_.boolean_encoding_level_ = value;
}

// optional int32 max_domain_size_when_encoding_eq_neq_constraints = 191 [default = 16];
inline bool SatParameters::has_max_domain_size_when_encoding_eq_neq_constraints() const {
  bool value = (_impl_._has_bits_[5] & 0x80000000u) != 0;
  return value;
}
inline void SatParameters::clear_max_domain_size_when_encoding_eq_neq_constraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_domain_size_when_encoding_eq_neq_constraints_ = 16;
  _impl_._has_bits_[5] &= ~0x80000000u;
}
inline ::int32_t SatParameters::max_domain_size_when_encoding_eq_neq_constraints() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_domain_size_when_encoding_eq_neq_constraints)
  return _internal_max_domain_size_when_encoding_eq_neq_constraints();
}
inline void SatParameters::set_max_domain_size_when_encoding_eq_neq_constraints(::int32_t value) {
  _internal_set_max_domain_size_when_encoding_eq_neq_constraints(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_domain_size_when_encoding_eq_neq_constraints)
}
inline ::int32_t SatParameters::_internal_max_domain_size_when_encoding_eq_neq_constraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_domain_size_when_encoding_eq_neq_constraints_;
}
inline void SatParameters::_internal_set_max_domain_size_when_encoding_eq_neq_constraints(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x80000000u;
  _impl_.max_domain_size_when_encoding_eq_neq_constraints_ = value;
}

// optional int32 max_num_cuts = 91 [default = 10000];
inline bool SatParameters::has_max_num_cuts() const {
  bool value = (_impl_._has_bits_[4] & 0x00000020u) != 0;
  return value;
}
inline void SatParameters::clear_max_num_cuts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_num_cuts_ = 10000;
  _impl_._has_bits_[4] &= ~0x00000020u;
}
inline ::int32_t SatParameters::max_num_cuts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_num_cuts)
  return _internal_max_num_cuts();
}
inline void SatParameters::set_max_num_cuts(::int32_t value) {
  _internal_set_max_num_cuts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_num_cuts)
}
inline ::int32_t SatParameters::_internal_max_num_cuts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_num_cuts_;
}
inline void SatParameters::_internal_set_max_num_cuts(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000020u;
  _impl_.max_num_cuts_ = value;
}

// optional int32 cut_level = 196 [default = 1];
inline bool SatParameters::has_cut_level() const {
  bool value = (_impl_._has_bits_[6] & 0x00000008u) != 0;
  return value;
}
inline void SatParameters::clear_cut_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cut_level_ = 1;
  _impl_._has_bits_[6] &= ~0x00000008u;
}
inline ::int32_t SatParameters::cut_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.cut_level)
  return _internal_cut_level();
}
inline void SatParameters::set_cut_level(::int32_t value) {
  _internal_set_cut_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.cut_level)
}
inline ::int32_t SatParameters::_internal_cut_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cut_level_;
}
inline void SatParameters::_internal_set_cut_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000008u;
  _impl_.cut_level_ = value;
}

// optional bool only_add_cuts_at_level_zero = 92 [default = false];
inline bool SatParameters::has_only_add_cuts_at_level_zero() const {
  bool value = (_impl_._has_bits_[2] & 0x00000008u) != 0;
  return value;
}
inline void SatParameters::clear_only_add_cuts_at_level_zero() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.only_add_cuts_at_level_zero_ = false;
  _impl_._has_bits_[2] &= ~0x00000008u;
}
inline bool SatParameters::only_add_cuts_at_level_zero() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.only_add_cuts_at_level_zero)
  return _internal_only_add_cuts_at_level_zero();
}
inline void SatParameters::set_only_add_cuts_at_level_zero(bool value) {
  _internal_set_only_add_cuts_at_level_zero(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.only_add_cuts_at_level_zero)
}
inline bool SatParameters::_internal_only_add_cuts_at_level_zero() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.only_add_cuts_at_level_zero_;
}
inline void SatParameters::_internal_set_only_add_cuts_at_level_zero(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00000008u;
  _impl_.only_add_cuts_at_level_zero_ = value;
}

// optional bool add_objective_cut = 197 [default = false];
inline bool SatParameters::has_add_objective_cut() const {
  bool value = (_impl_._has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline void SatParameters::clear_add_objective_cut() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_objective_cut_ = false;
  _impl_._has_bits_[1] &= ~0x01000000u;
}
inline bool SatParameters::add_objective_cut() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.add_objective_cut)
  return _internal_add_objective_cut();
}
inline void SatParameters::set_add_objective_cut(bool value) {
  _internal_set_add_objective_cut(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.add_objective_cut)
}
inline bool SatParameters::_internal_add_objective_cut() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_objective_cut_;
}
inline void SatParameters::_internal_set_add_objective_cut(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x01000000u;
  _impl_.add_objective_cut_ = value;
}

// optional bool add_cg_cuts = 117 [default = true];
inline bool SatParameters::has_add_cg_cuts() const {
  bool value = (_impl_._has_bits_[5] & 0x00002000u) != 0;
  return value;
}
inline void SatParameters::clear_add_cg_cuts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_cg_cuts_ = true;
  _impl_._has_bits_[5] &= ~0x00002000u;
}
inline bool SatParameters::add_cg_cuts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.add_cg_cuts)
  return _internal_add_cg_cuts();
}
inline void SatParameters::set_add_cg_cuts(bool value) {
  _internal_set_add_cg_cuts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.add_cg_cuts)
}
inline bool SatParameters::_internal_add_cg_cuts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_cg_cuts_;
}
inline void SatParameters::_internal_set_add_cg_cuts(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00002000u;
  _impl_.add_cg_cuts_ = value;
}

// optional bool add_mir_cuts = 120 [default = true];
inline bool SatParameters::has_add_mir_cuts() const {
  bool value = (_impl_._has_bits_[5] & 0x00004000u) != 0;
  return value;
}
inline void SatParameters::clear_add_mir_cuts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_mir_cuts_ = true;
  _impl_._has_bits_[5] &= ~0x00004000u;
}
inline bool SatParameters::add_mir_cuts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.add_mir_cuts)
  return _internal_add_mir_cuts();
}
inline void SatParameters::set_add_mir_cuts(bool value) {
  _internal_set_add_mir_cuts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.add_mir_cuts)
}
inline bool SatParameters::_internal_add_mir_cuts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_mir_cuts_;
}
inline void SatParameters::_internal_set_add_mir_cuts(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00004000u;
  _impl_.add_mir_cuts_ = value;
}

// optional bool add_zero_half_cuts = 169 [default = true];
inline bool SatParameters::has_add_zero_half_cuts() const {
  bool value = (_impl_._has_bits_[5] & 0x00008000u) != 0;
  return value;
}
inline void SatParameters::clear_add_zero_half_cuts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_zero_half_cuts_ = true;
  _impl_._has_bits_[5] &= ~0x00008000u;
}
inline bool SatParameters::add_zero_half_cuts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.add_zero_half_cuts)
  return _internal_add_zero_half_cuts();
}
inline void SatParameters::set_add_zero_half_cuts(bool value) {
  _internal_set_add_zero_half_cuts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.add_zero_half_cuts)
}
inline bool SatParameters::_internal_add_zero_half_cuts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_zero_half_cuts_;
}
inline void SatParameters::_internal_set_add_zero_half_cuts(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00008000u;
  _impl_.add_zero_half_cuts_ = value;
}

// optional bool add_clique_cuts = 172 [default = true];
inline bool SatParameters::has_add_clique_cuts() const {
  bool value = (_impl_._has_bits_[4] & 0x02000000u) != 0;
  return value;
}
inline void SatParameters::clear_add_clique_cuts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_clique_cuts_ = true;
  _impl_._has_bits_[4] &= ~0x02000000u;
}
inline bool SatParameters::add_clique_cuts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.add_clique_cuts)
  return _internal_add_clique_cuts();
}
inline void SatParameters::set_add_clique_cuts(bool value) {
  _internal_set_add_clique_cuts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.add_clique_cuts)
}
inline bool SatParameters::_internal_add_clique_cuts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_clique_cuts_;
}
inline void SatParameters::_internal_set_add_clique_cuts(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x02000000u;
  _impl_.add_clique_cuts_ = value;
}

// optional int32 max_all_diff_cut_size = 148 [default = 64];
inline bool SatParameters::has_max_all_diff_cut_size() const {
  bool value = (_impl_._has_bits_[5] & 0x00000200u) != 0;
  return value;
}
inline void SatParameters::clear_max_all_diff_cut_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_all_diff_cut_size_ = 64;
  _impl_._has_bits_[5] &= ~0x00000200u;
}
inline ::int32_t SatParameters::max_all_diff_cut_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_all_diff_cut_size)
  return _internal_max_all_diff_cut_size();
}
inline void SatParameters::set_max_all_diff_cut_size(::int32_t value) {
  _internal_set_max_all_diff_cut_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_all_diff_cut_size)
}
inline ::int32_t SatParameters::_internal_max_all_diff_cut_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_all_diff_cut_size_;
}
inline void SatParameters::_internal_set_max_all_diff_cut_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000200u;
  _impl_.max_all_diff_cut_size_ = value;
}

// optional bool add_lin_max_cuts = 152 [default = true];
inline bool SatParameters::has_add_lin_max_cuts() const {
  bool value = (_impl_._has_bits_[4] & 0x04000000u) != 0;
  return value;
}
inline void SatParameters::clear_add_lin_max_cuts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_lin_max_cuts_ = true;
  _impl_._has_bits_[4] &= ~0x04000000u;
}
inline bool SatParameters::add_lin_max_cuts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.add_lin_max_cuts)
  return _internal_add_lin_max_cuts();
}
inline void SatParameters::set_add_lin_max_cuts(bool value) {
  _internal_set_add_lin_max_cuts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.add_lin_max_cuts)
}
inline bool SatParameters::_internal_add_lin_max_cuts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_lin_max_cuts_;
}
inline void SatParameters::_internal_set_add_lin_max_cuts(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x04000000u;
  _impl_.add_lin_max_cuts_ = value;
}

// optional int32 max_integer_rounding_scaling = 119 [default = 600];
inline bool SatParameters::has_max_integer_rounding_scaling() const {
  bool value = (_impl_._has_bits_[4] & 0x00010000u) != 0;
  return value;
}
inline void SatParameters::clear_max_integer_rounding_scaling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_integer_rounding_scaling_ = 600;
  _impl_._has_bits_[4] &= ~0x00010000u;
}
inline ::int32_t SatParameters::max_integer_rounding_scaling() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_integer_rounding_scaling)
  return _internal_max_integer_rounding_scaling();
}
inline void SatParameters::set_max_integer_rounding_scaling(::int32_t value) {
  _internal_set_max_integer_rounding_scaling(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_integer_rounding_scaling)
}
inline ::int32_t SatParameters::_internal_max_integer_rounding_scaling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_integer_rounding_scaling_;
}
inline void SatParameters::_internal_set_max_integer_rounding_scaling(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00010000u;
  _impl_.max_integer_rounding_scaling_ = value;
}

// optional bool add_lp_constraints_lazily = 112 [default = true];
inline bool SatParameters::has_add_lp_constraints_lazily() const {
  bool value = (_impl_._has_bits_[4] & 0x08000000u) != 0;
  return value;
}
inline void SatParameters::clear_add_lp_constraints_lazily() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.add_lp_constraints_lazily_ = true;
  _impl_._has_bits_[4] &= ~0x08000000u;
}
inline bool SatParameters::add_lp_constraints_lazily() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.add_lp_constraints_lazily)
  return _internal_add_lp_constraints_lazily();
}
inline void SatParameters::set_add_lp_constraints_lazily(bool value) {
  _internal_set_add_lp_constraints_lazily(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.add_lp_constraints_lazily)
}
inline bool SatParameters::_internal_add_lp_constraints_lazily() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.add_lp_constraints_lazily_;
}
inline void SatParameters::_internal_set_add_lp_constraints_lazily(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x08000000u;
  _impl_.add_lp_constraints_lazily_ = value;
}

// optional int32 root_lp_iterations = 227 [default = 2000];
inline bool SatParameters::has_root_lp_iterations() const {
  bool value = (_impl_._has_bits_[6] & 0x00002000u) != 0;
  return value;
}
inline void SatParameters::clear_root_lp_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.root_lp_iterations_ = 2000;
  _impl_._has_bits_[6] &= ~0x00002000u;
}
inline ::int32_t SatParameters::root_lp_iterations() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.root_lp_iterations)
  return _internal_root_lp_iterations();
}
inline void SatParameters::set_root_lp_iterations(::int32_t value) {
  _internal_set_root_lp_iterations(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.root_lp_iterations)
}
inline ::int32_t SatParameters::_internal_root_lp_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.root_lp_iterations_;
}
inline void SatParameters::_internal_set_root_lp_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00002000u;
  _impl_.root_lp_iterations_ = value;
}

// optional double min_orthogonality_for_lp_constraints = 115 [default = 0.05];
inline bool SatParameters::has_min_orthogonality_for_lp_constraints() const {
  bool value = (_impl_._has_bits_[4] & 0x00000800u) != 0;
  return value;
}
inline void SatParameters::clear_min_orthogonality_for_lp_constraints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_orthogonality_for_lp_constraints_ = 0.05;
  _impl_._has_bits_[4] &= ~0x00000800u;
}
inline double SatParameters::min_orthogonality_for_lp_constraints() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.min_orthogonality_for_lp_constraints)
  return _internal_min_orthogonality_for_lp_constraints();
}
inline void SatParameters::set_min_orthogonality_for_lp_constraints(double value) {
  _internal_set_min_orthogonality_for_lp_constraints(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.min_orthogonality_for_lp_constraints)
}
inline double SatParameters::_internal_min_orthogonality_for_lp_constraints() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_orthogonality_for_lp_constraints_;
}
inline void SatParameters::_internal_set_min_orthogonality_for_lp_constraints(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000800u;
  _impl_.min_orthogonality_for_lp_constraints_ = value;
}

// optional int32 max_cut_rounds_at_level_zero = 154 [default = 1];
inline bool SatParameters::has_max_cut_rounds_at_level_zero() const {
  bool value = (_impl_._has_bits_[5] & 0x00000800u) != 0;
  return value;
}
inline void SatParameters::clear_max_cut_rounds_at_level_zero() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_cut_rounds_at_level_zero_ = 1;
  _impl_._has_bits_[5] &= ~0x00000800u;
}
inline ::int32_t SatParameters::max_cut_rounds_at_level_zero() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_cut_rounds_at_level_zero)
  return _internal_max_cut_rounds_at_level_zero();
}
inline void SatParameters::set_max_cut_rounds_at_level_zero(::int32_t value) {
  _internal_set_max_cut_rounds_at_level_zero(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_cut_rounds_at_level_zero)
}
inline ::int32_t SatParameters::_internal_max_cut_rounds_at_level_zero() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_cut_rounds_at_level_zero_;
}
inline void SatParameters::_internal_set_max_cut_rounds_at_level_zero(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000800u;
  _impl_.max_cut_rounds_at_level_zero_ = value;
}

// optional int32 max_consecutive_inactive_count = 121 [default = 100];
inline bool SatParameters::has_max_consecutive_inactive_count() const {
  bool value = (_impl_._has_bits_[4] & 0x00020000u) != 0;
  return value;
}
inline void SatParameters::clear_max_consecutive_inactive_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_consecutive_inactive_count_ = 100;
  _impl_._has_bits_[4] &= ~0x00020000u;
}
inline ::int32_t SatParameters::max_consecutive_inactive_count() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.max_consecutive_inactive_count)
  return _internal_max_consecutive_inactive_count();
}
inline void SatParameters::set_max_consecutive_inactive_count(::int32_t value) {
  _internal_set_max_consecutive_inactive_count(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.max_consecutive_inactive_count)
}
inline ::int32_t SatParameters::_internal_max_consecutive_inactive_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_consecutive_inactive_count_;
}
inline void SatParameters::_internal_set_max_consecutive_inactive_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00020000u;
  _impl_.max_consecutive_inactive_count_ = value;
}

// optional double cut_max_active_count_value = 155 [default = 10000000000];
inline bool SatParameters::has_cut_max_active_count_value() const {
  bool value = (_impl_._has_bits_[5] & 0x00010000u) != 0;
  return value;
}
inline void SatParameters::clear_cut_max_active_count_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cut_max_active_count_value_ = 10000000000;
  _impl_._has_bits_[5] &= ~0x00010000u;
}
inline double SatParameters::cut_max_active_count_value() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.cut_max_active_count_value)
  return _internal_cut_max_active_count_value();
}
inline void SatParameters::set_cut_max_active_count_value(double value) {
  _internal_set_cut_max_active_count_value(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.cut_max_active_count_value)
}
inline double SatParameters::_internal_cut_max_active_count_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cut_max_active_count_value_;
}
inline void SatParameters::_internal_set_cut_max_active_count_value(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00010000u;
  _impl_.cut_max_active_count_value_ = value;
}

// optional double cut_active_count_decay = 156 [default = 0.8];
inline bool SatParameters::has_cut_active_count_decay() const {
  bool value = (_impl_._has_bits_[5] & 0x00020000u) != 0;
  return value;
}
inline void SatParameters::clear_cut_active_count_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cut_active_count_decay_ = 0.8;
  _impl_._has_bits_[5] &= ~0x00020000u;
}
inline double SatParameters::cut_active_count_decay() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.cut_active_count_decay)
  return _internal_cut_active_count_decay();
}
inline void SatParameters::set_cut_active_count_decay(double value) {
  _internal_set_cut_active_count_decay(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.cut_active_count_decay)
}
inline double SatParameters::_internal_cut_active_count_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cut_active_count_decay_;
}
inline void SatParameters::_internal_set_cut_active_count_decay(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00020000u;
  _impl_.cut_active_count_decay_ = value;
}

// optional int32 cut_cleanup_target = 157 [default = 1000];
inline bool SatParameters::has_cut_cleanup_target() const {
  bool value = (_impl_._has_bits_[5] & 0x00080000u) != 0;
  return value;
}
inline void SatParameters::clear_cut_cleanup_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cut_cleanup_target_ = 1000;
  _impl_._has_bits_[5] &= ~0x00080000u;
}
inline ::int32_t SatParameters::cut_cleanup_target() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.cut_cleanup_target)
  return _internal_cut_cleanup_target();
}
inline void SatParameters::set_cut_cleanup_target(::int32_t value) {
  _internal_set_cut_cleanup_target(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.cut_cleanup_target)
}
inline ::int32_t SatParameters::_internal_cut_cleanup_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cut_cleanup_target_;
}
inline void SatParameters::_internal_set_cut_cleanup_target(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00080000u;
  _impl_.cut_cleanup_target_ = value;
}

// optional int32 new_constraints_batch_size = 122 [default = 50];
inline bool SatParameters::has_new_constraints_batch_size() const {
  bool value = (_impl_._has_bits_[4] & 0x00040000u) != 0;
  return value;
}
inline void SatParameters::clear_new_constraints_batch_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_constraints_batch_size_ = 50;
  _impl_._has_bits_[4] &= ~0x00040000u;
}
inline ::int32_t SatParameters::new_constraints_batch_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.new_constraints_batch_size)
  return _internal_new_constraints_batch_size();
}
inline void SatParameters::set_new_constraints_batch_size(::int32_t value) {
  _internal_set_new_constraints_batch_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.new_constraints_batch_size)
}
inline ::int32_t SatParameters::_internal_new_constraints_batch_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_constraints_batch_size_;
}
inline void SatParameters::_internal_set_new_constraints_batch_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00040000u;
  _impl_.new_constraints_batch_size_ = value;
}

// optional .operations_research.sat.SatParameters.SearchBranching search_branching = 82 [default = AUTOMATIC_SEARCH];
inline bool SatParameters::has_search_branching() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void SatParameters::clear_search_branching() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_branching_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::operations_research::sat::SatParameters_SearchBranching SatParameters::search_branching() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.search_branching)
  return _internal_search_branching();
}
inline void SatParameters::set_search_branching(::operations_research::sat::SatParameters_SearchBranching value) {
  _internal_set_search_branching(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.search_branching)
}
inline ::operations_research::sat::SatParameters_SearchBranching SatParameters::_internal_search_branching() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_SearchBranching>(_impl_.search_branching_);
}
inline void SatParameters::_internal_set_search_branching(::operations_research::sat::SatParameters_SearchBranching value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_SearchBranching_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.search_branching_ = value;
}

// optional int32 hint_conflict_limit = 153 [default = 10];
inline bool SatParameters::has_hint_conflict_limit() const {
  bool value = (_impl_._has_bits_[5] & 0x00000400u) != 0;
  return value;
}
inline void SatParameters::clear_hint_conflict_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hint_conflict_limit_ = 10;
  _impl_._has_bits_[5] &= ~0x00000400u;
}
inline ::int32_t SatParameters::hint_conflict_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.hint_conflict_limit)
  return _internal_hint_conflict_limit();
}
inline void SatParameters::set_hint_conflict_limit(::int32_t value) {
  _internal_set_hint_conflict_limit(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.hint_conflict_limit)
}
inline ::int32_t SatParameters::_internal_hint_conflict_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hint_conflict_limit_;
}
inline void SatParameters::_internal_set_hint_conflict_limit(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000400u;
  _impl_.hint_conflict_limit_ = value;
}

// optional bool repair_hint = 167 [default = false];
inline bool SatParameters::has_repair_hint() const {
  bool value = (_impl_._has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline void SatParameters::clear_repair_hint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.repair_hint_ = false;
  _impl_._has_bits_[1] &= ~0x02000000u;
}
inline bool SatParameters::repair_hint() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.repair_hint)
  return _internal_repair_hint();
}
inline void SatParameters::set_repair_hint(bool value) {
  _internal_set_repair_hint(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.repair_hint)
}
inline bool SatParameters::_internal_repair_hint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repair_hint_;
}
inline void SatParameters::_internal_set_repair_hint(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x02000000u;
  _impl_.repair_hint_ = value;
}

// optional bool fix_variables_to_their_hinted_value = 192 [default = false];
inline bool SatParameters::has_fix_variables_to_their_hinted_value() const {
  bool value = (_impl_._has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline void SatParameters::clear_fix_variables_to_their_hinted_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fix_variables_to_their_hinted_value_ = false;
  _impl_._has_bits_[1] &= ~0x04000000u;
}
inline bool SatParameters::fix_variables_to_their_hinted_value() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.fix_variables_to_their_hinted_value)
  return _internal_fix_variables_to_their_hinted_value();
}
inline void SatParameters::set_fix_variables_to_their_hinted_value(bool value) {
  _internal_set_fix_variables_to_their_hinted_value(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.fix_variables_to_their_hinted_value)
}
inline bool SatParameters::_internal_fix_variables_to_their_hinted_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fix_variables_to_their_hinted_value_;
}
inline void SatParameters::_internal_set_fix_variables_to_their_hinted_value(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x04000000u;
  _impl_.fix_variables_to_their_hinted_value_ = value;
}

// optional bool exploit_integer_lp_solution = 94 [default = true];
inline bool SatParameters::has_exploit_integer_lp_solution() const {
  bool value = (_impl_._has_bits_[4] & 0x10000000u) != 0;
  return value;
}
inline void SatParameters::clear_exploit_integer_lp_solution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exploit_integer_lp_solution_ = true;
  _impl_._has_bits_[4] &= ~0x10000000u;
}
inline bool SatParameters::exploit_integer_lp_solution() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.exploit_integer_lp_solution)
  return _internal_exploit_integer_lp_solution();
}
inline void SatParameters::set_exploit_integer_lp_solution(bool value) {
  _internal_set_exploit_integer_lp_solution(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.exploit_integer_lp_solution)
}
inline bool SatParameters::_internal_exploit_integer_lp_solution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exploit_integer_lp_solution_;
}
inline void SatParameters::_internal_set_exploit_integer_lp_solution(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x10000000u;
  _impl_.exploit_integer_lp_solution_ = value;
}

// optional bool exploit_all_lp_solution = 116 [default = true];
inline bool SatParameters::has_exploit_all_lp_solution() const {
  bool value = (_impl_._has_bits_[5] & 0x00400000u) != 0;
  return value;
}
inline void SatParameters::clear_exploit_all_lp_solution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exploit_all_lp_solution_ = true;
  _impl_._has_bits_[5] &= ~0x00400000u;
}
inline bool SatParameters::exploit_all_lp_solution() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.exploit_all_lp_solution)
  return _internal_exploit_all_lp_solution();
}
inline void SatParameters::set_exploit_all_lp_solution(bool value) {
  _internal_set_exploit_all_lp_solution(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.exploit_all_lp_solution)
}
inline bool SatParameters::_internal_exploit_all_lp_solution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exploit_all_lp_solution_;
}
inline void SatParameters::_internal_set_exploit_all_lp_solution(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00400000u;
  _impl_.exploit_all_lp_solution_ = value;
}

// optional bool exploit_best_solution = 130 [default = false];
inline bool SatParameters::has_exploit_best_solution() const {
  bool value = (_impl_._has_bits_[1] & 0x08000000u) != 0;
  return value;
}
inline void SatParameters::clear_exploit_best_solution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exploit_best_solution_ = false;
  _impl_._has_bits_[1] &= ~0x08000000u;
}
inline bool SatParameters::exploit_best_solution() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.exploit_best_solution)
  return _internal_exploit_best_solution();
}
inline void SatParameters::set_exploit_best_solution(bool value) {
  _internal_set_exploit_best_solution(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.exploit_best_solution)
}
inline bool SatParameters::_internal_exploit_best_solution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exploit_best_solution_;
}
inline void SatParameters::_internal_set_exploit_best_solution(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x08000000u;
  _impl_.exploit_best_solution_ = value;
}

// optional bool exploit_relaxation_solution = 161 [default = false];
inline bool SatParameters::has_exploit_relaxation_solution() const {
  bool value = (_impl_._has_bits_[2] & 0x00001000u) != 0;
  return value;
}
inline void SatParameters::clear_exploit_relaxation_solution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exploit_relaxation_solution_ = false;
  _impl_._has_bits_[2] &= ~0x00001000u;
}
inline bool SatParameters::exploit_relaxation_solution() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.exploit_relaxation_solution)
  return _internal_exploit_relaxation_solution();
}
inline void SatParameters::set_exploit_relaxation_solution(bool value) {
  _internal_set_exploit_relaxation_solution(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.exploit_relaxation_solution)
}
inline bool SatParameters::_internal_exploit_relaxation_solution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exploit_relaxation_solution_;
}
inline void SatParameters::_internal_set_exploit_relaxation_solution(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00001000u;
  _impl_.exploit_relaxation_solution_ = value;
}

// optional bool exploit_objective = 131 [default = true];
inline bool SatParameters::has_exploit_objective() const {
  bool value = (_impl_._has_bits_[5] & 0x00800000u) != 0;
  return value;
}
inline void SatParameters::clear_exploit_objective() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exploit_objective_ = true;
  _impl_._has_bits_[5] &= ~0x00800000u;
}
inline bool SatParameters::exploit_objective() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.exploit_objective)
  return _internal_exploit_objective();
}
inline void SatParameters::set_exploit_objective(bool value) {
  _internal_set_exploit_objective(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.exploit_objective)
}
inline bool SatParameters::_internal_exploit_objective() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exploit_objective_;
}
inline void SatParameters::_internal_set_exploit_objective(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00800000u;
  _impl_.exploit_objective_ = value;
}

// optional int64 probing_period_at_root = 142 [default = 0];
inline bool SatParameters::has_probing_period_at_root() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void SatParameters::clear_probing_period_at_root() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.probing_period_at_root_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::int64_t SatParameters::probing_period_at_root() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.probing_period_at_root)
  return _internal_probing_period_at_root();
}
inline void SatParameters::set_probing_period_at_root(::int64_t value) {
  _internal_set_probing_period_at_root(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.probing_period_at_root)
}
inline ::int64_t SatParameters::_internal_probing_period_at_root() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.probing_period_at_root_;
}
inline void SatParameters::_internal_set_probing_period_at_root(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.probing_period_at_root_ = value;
}

// optional bool use_probing_search = 176 [default = false];
inline bool SatParameters::has_use_probing_search() const {
  bool value = (_impl_._has_bits_[2] & 0x00002000u) != 0;
  return value;
}
inline void SatParameters::clear_use_probing_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_probing_search_ = false;
  _impl_._has_bits_[2] &= ~0x00002000u;
}
inline bool SatParameters::use_probing_search() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_probing_search)
  return _internal_use_probing_search();
}
inline void SatParameters::set_use_probing_search(bool value) {
  _internal_set_use_probing_search(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_probing_search)
}
inline bool SatParameters::_internal_use_probing_search() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_probing_search_;
}
inline void SatParameters::_internal_set_use_probing_search(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00002000u;
  _impl_.use_probing_search_ = value;
}

// optional bool use_shaving_in_probing_search = 204 [default = true];
inline bool SatParameters::has_use_shaving_in_probing_search() const {
  bool value = (_impl_._has_bits_[5] & 0x01000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_shaving_in_probing_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_shaving_in_probing_search_ = true;
  _impl_._has_bits_[5] &= ~0x01000000u;
}
inline bool SatParameters::use_shaving_in_probing_search() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_shaving_in_probing_search)
  return _internal_use_shaving_in_probing_search();
}
inline void SatParameters::set_use_shaving_in_probing_search(bool value) {
  _internal_set_use_shaving_in_probing_search(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_shaving_in_probing_search)
}
inline bool SatParameters::_internal_use_shaving_in_probing_search() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_shaving_in_probing_search_;
}
inline void SatParameters::_internal_set_use_shaving_in_probing_search(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x01000000u;
  _impl_.use_shaving_in_probing_search_ = value;
}

// optional double shaving_search_deterministic_time = 205 [default = 0.001];
inline bool SatParameters::has_shaving_search_deterministic_time() const {
  bool value = (_impl_._has_bits_[6] & 0x00000020u) != 0;
  return value;
}
inline void SatParameters::clear_shaving_search_deterministic_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shaving_search_deterministic_time_ = 0.001;
  _impl_._has_bits_[6] &= ~0x00000020u;
}
inline double SatParameters::shaving_search_deterministic_time() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.shaving_search_deterministic_time)
  return _internal_shaving_search_deterministic_time();
}
inline void SatParameters::set_shaving_search_deterministic_time(double value) {
  _internal_set_shaving_search_deterministic_time(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.shaving_search_deterministic_time)
}
inline double SatParameters::_internal_shaving_search_deterministic_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shaving_search_deterministic_time_;
}
inline void SatParameters::_internal_set_shaving_search_deterministic_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000020u;
  _impl_.shaving_search_deterministic_time_ = value;
}

// optional bool use_objective_lb_search = 228 [default = false];
inline bool SatParameters::has_use_objective_lb_search() const {
  bool value = (_impl_._has_bits_[2] & 0x00004000u) != 0;
  return value;
}
inline void SatParameters::clear_use_objective_lb_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_objective_lb_search_ = false;
  _impl_._has_bits_[2] &= ~0x00004000u;
}
inline bool SatParameters::use_objective_lb_search() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_objective_lb_search)
  return _internal_use_objective_lb_search();
}
inline void SatParameters::set_use_objective_lb_search(bool value) {
  _internal_set_use_objective_lb_search(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_objective_lb_search)
}
inline bool SatParameters::_internal_use_objective_lb_search() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_objective_lb_search_;
}
inline void SatParameters::_internal_set_use_objective_lb_search(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00004000u;
  _impl_.use_objective_lb_search_ = value;
}

// optional bool use_objective_shaving_search = 253 [default = false];
inline bool SatParameters::has_use_objective_shaving_search() const {
  bool value = (_impl_._has_bits_[2] & 0x00008000u) != 0;
  return value;
}
inline void SatParameters::clear_use_objective_shaving_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_objective_shaving_search_ = false;
  _impl_._has_bits_[2] &= ~0x00008000u;
}
inline bool SatParameters::use_objective_shaving_search() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_objective_shaving_search)
  return _internal_use_objective_shaving_search();
}
inline void SatParameters::set_use_objective_shaving_search(bool value) {
  _internal_set_use_objective_shaving_search(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_objective_shaving_search)
}
inline bool SatParameters::_internal_use_objective_shaving_search() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_objective_shaving_search_;
}
inline void SatParameters::_internal_set_use_objective_shaving_search(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00008000u;
  _impl_.use_objective_shaving_search_ = value;
}

// optional int64 pseudo_cost_reliability_threshold = 123 [default = 100];
inline bool SatParameters::has_pseudo_cost_reliability_threshold() const {
  bool value = (_impl_._has_bits_[4] & 0x00080000u) != 0;
  return value;
}
inline void SatParameters::clear_pseudo_cost_reliability_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pseudo_cost_reliability_threshold_ = ::int64_t{100};
  _impl_._has_bits_[4] &= ~0x00080000u;
}
inline ::int64_t SatParameters::pseudo_cost_reliability_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.pseudo_cost_reliability_threshold)
  return _internal_pseudo_cost_reliability_threshold();
}
inline void SatParameters::set_pseudo_cost_reliability_threshold(::int64_t value) {
  _internal_set_pseudo_cost_reliability_threshold(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.pseudo_cost_reliability_threshold)
}
inline ::int64_t SatParameters::_internal_pseudo_cost_reliability_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pseudo_cost_reliability_threshold_;
}
inline void SatParameters::_internal_set_pseudo_cost_reliability_threshold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00080000u;
  _impl_.pseudo_cost_reliability_threshold_ = value;
}

// optional bool optimize_with_core = 83 [default = false];
inline bool SatParameters::has_optimize_with_core() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline void SatParameters::clear_optimize_with_core() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.optimize_with_core_ = false;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline bool SatParameters::optimize_with_core() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.optimize_with_core)
  return _internal_optimize_with_core();
}
inline void SatParameters::set_optimize_with_core(bool value) {
  _internal_set_optimize_with_core(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.optimize_with_core)
}
inline bool SatParameters::_internal_optimize_with_core() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.optimize_with_core_;
}
inline void SatParameters::_internal_set_optimize_with_core(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.optimize_with_core_ = value;
}

// optional bool optimize_with_lb_tree_search = 188 [default = false];
inline bool SatParameters::has_optimize_with_lb_tree_search() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline void SatParameters::clear_optimize_with_lb_tree_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.optimize_with_lb_tree_search_ = false;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline bool SatParameters::optimize_with_lb_tree_search() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.optimize_with_lb_tree_search)
  return _internal_optimize_with_lb_tree_search();
}
inline void SatParameters::set_optimize_with_lb_tree_search(bool value) {
  _internal_set_optimize_with_lb_tree_search(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.optimize_with_lb_tree_search)
}
inline bool SatParameters::_internal_optimize_with_lb_tree_search() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.optimize_with_lb_tree_search_;
}
inline void SatParameters::_internal_set_optimize_with_lb_tree_search(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.optimize_with_lb_tree_search_ = value;
}

// optional int32 binary_search_num_conflicts = 99 [default = -1];
inline bool SatParameters::has_binary_search_num_conflicts() const {
  bool value = (_impl_._has_bits_[4] & 0x00000100u) != 0;
  return value;
}
inline void SatParameters::clear_binary_search_num_conflicts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binary_search_num_conflicts_ = -1;
  _impl_._has_bits_[4] &= ~0x00000100u;
}
inline ::int32_t SatParameters::binary_search_num_conflicts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.binary_search_num_conflicts)
  return _internal_binary_search_num_conflicts();
}
inline void SatParameters::set_binary_search_num_conflicts(::int32_t value) {
  _internal_set_binary_search_num_conflicts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.binary_search_num_conflicts)
}
inline ::int32_t SatParameters::_internal_binary_search_num_conflicts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.binary_search_num_conflicts_;
}
inline void SatParameters::_internal_set_binary_search_num_conflicts(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00000100u;
  _impl_.binary_search_num_conflicts_ = value;
}

// optional bool optimize_with_max_hs = 85 [default = false];
inline bool SatParameters::has_optimize_with_max_hs() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline void SatParameters::clear_optimize_with_max_hs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.optimize_with_max_hs_ = false;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline bool SatParameters::optimize_with_max_hs() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.optimize_with_max_hs)
  return _internal_optimize_with_max_hs();
}
inline void SatParameters::set_optimize_with_max_hs(bool value) {
  _internal_set_optimize_with_max_hs(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.optimize_with_max_hs)
}
inline bool SatParameters::_internal_optimize_with_max_hs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.optimize_with_max_hs_;
}
inline void SatParameters::_internal_set_optimize_with_max_hs(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.optimize_with_max_hs_ = value;
}

// optional bool use_feasibility_jump = 265 [default = true];
inline bool SatParameters::has_use_feasibility_jump() const {
  bool value = (_impl_._has_bits_[5] & 0x02000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_feasibility_jump() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_feasibility_jump_ = true;
  _impl_._has_bits_[5] &= ~0x02000000u;
}
inline bool SatParameters::use_feasibility_jump() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_feasibility_jump)
  return _internal_use_feasibility_jump();
}
inline void SatParameters::set_use_feasibility_jump(bool value) {
  _internal_set_use_feasibility_jump(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_feasibility_jump)
}
inline bool SatParameters::_internal_use_feasibility_jump() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_feasibility_jump_;
}
inline void SatParameters::_internal_set_use_feasibility_jump(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x02000000u;
  _impl_.use_feasibility_jump_ = value;
}

// optional bool test_feasibility_jump = 240 [default = false];
inline bool SatParameters::has_test_feasibility_jump() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline void SatParameters::clear_test_feasibility_jump() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.test_feasibility_jump_ = false;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline bool SatParameters::test_feasibility_jump() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.test_feasibility_jump)
  return _internal_test_feasibility_jump();
}
inline void SatParameters::set_test_feasibility_jump(bool value) {
  _internal_set_test_feasibility_jump(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.test_feasibility_jump)
}
inline bool SatParameters::_internal_test_feasibility_jump() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.test_feasibility_jump_;
}
inline void SatParameters::_internal_set_test_feasibility_jump(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.test_feasibility_jump_ = value;
}

// optional double feasibility_jump_decay = 242 [default = 0.95];
inline bool SatParameters::has_feasibility_jump_decay() const {
  bool value = (_impl_._has_bits_[6] & 0x00020000u) != 0;
  return value;
}
inline void SatParameters::clear_feasibility_jump_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feasibility_jump_decay_ = 0.95;
  _impl_._has_bits_[6] &= ~0x00020000u;
}
inline double SatParameters::feasibility_jump_decay() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.feasibility_jump_decay)
  return _internal_feasibility_jump_decay();
}
inline void SatParameters::set_feasibility_jump_decay(double value) {
  _internal_set_feasibility_jump_decay(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.feasibility_jump_decay)
}
inline double SatParameters::_internal_feasibility_jump_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feasibility_jump_decay_;
}
inline void SatParameters::_internal_set_feasibility_jump_decay(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00020000u;
  _impl_.feasibility_jump_decay_ = value;
}

// optional int32 feasibility_jump_linearization_level = 257 [default = 2];
inline bool SatParameters::has_feasibility_jump_linearization_level() const {
  bool value = (_impl_._has_bits_[6] & 0x00400000u) != 0;
  return value;
}
inline void SatParameters::clear_feasibility_jump_linearization_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feasibility_jump_linearization_level_ = 2;
  _impl_._has_bits_[6] &= ~0x00400000u;
}
inline ::int32_t SatParameters::feasibility_jump_linearization_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.feasibility_jump_linearization_level)
  return _internal_feasibility_jump_linearization_level();
}
inline void SatParameters::set_feasibility_jump_linearization_level(::int32_t value) {
  _internal_set_feasibility_jump_linearization_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.feasibility_jump_linearization_level)
}
inline ::int32_t SatParameters::_internal_feasibility_jump_linearization_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feasibility_jump_linearization_level_;
}
inline void SatParameters::_internal_set_feasibility_jump_linearization_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00400000u;
  _impl_.feasibility_jump_linearization_level_ = value;
}

// optional int32 feasibility_jump_restart_factor = 258 [default = 1];
inline bool SatParameters::has_feasibility_jump_restart_factor() const {
  bool value = (_impl_._has_bits_[6] & 0x01000000u) != 0;
  return value;
}
inline void SatParameters::clear_feasibility_jump_restart_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feasibility_jump_restart_factor_ = 1;
  _impl_._has_bits_[6] &= ~0x01000000u;
}
inline ::int32_t SatParameters::feasibility_jump_restart_factor() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.feasibility_jump_restart_factor)
  return _internal_feasibility_jump_restart_factor();
}
inline void SatParameters::set_feasibility_jump_restart_factor(::int32_t value) {
  _internal_set_feasibility_jump_restart_factor(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.feasibility_jump_restart_factor)
}
inline ::int32_t SatParameters::_internal_feasibility_jump_restart_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feasibility_jump_restart_factor_;
}
inline void SatParameters::_internal_set_feasibility_jump_restart_factor(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x01000000u;
  _impl_.feasibility_jump_restart_factor_ = value;
}

// optional double feasibility_jump_var_randomization_probability = 247 [default = 0];
inline bool SatParameters::has_feasibility_jump_var_randomization_probability() const {
  bool value = (_impl_._has_bits_[2] & 0x01000000u) != 0;
  return value;
}
inline void SatParameters::clear_feasibility_jump_var_randomization_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feasibility_jump_var_randomization_probability_ = 0;
  _impl_._has_bits_[2] &= ~0x01000000u;
}
inline double SatParameters::feasibility_jump_var_randomization_probability() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.feasibility_jump_var_randomization_probability)
  return _internal_feasibility_jump_var_randomization_probability();
}
inline void SatParameters::set_feasibility_jump_var_randomization_probability(double value) {
  _internal_set_feasibility_jump_var_randomization_probability(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.feasibility_jump_var_randomization_probability)
}
inline double SatParameters::_internal_feasibility_jump_var_randomization_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feasibility_jump_var_randomization_probability_;
}
inline void SatParameters::_internal_set_feasibility_jump_var_randomization_probability(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x01000000u;
  _impl_.feasibility_jump_var_randomization_probability_ = value;
}

// optional double feasibility_jump_var_perburbation_range_ratio = 248 [default = 0.2];
inline bool SatParameters::has_feasibility_jump_var_perburbation_range_ratio() const {
  bool value = (_impl_._has_bits_[6] & 0x00100000u) != 0;
  return value;
}
inline void SatParameters::clear_feasibility_jump_var_perburbation_range_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feasibility_jump_var_perburbation_range_ratio_ = 0.2;
  _impl_._has_bits_[6] &= ~0x00100000u;
}
inline double SatParameters::feasibility_jump_var_perburbation_range_ratio() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.feasibility_jump_var_perburbation_range_ratio)
  return _internal_feasibility_jump_var_perburbation_range_ratio();
}
inline void SatParameters::set_feasibility_jump_var_perburbation_range_ratio(double value) {
  _internal_set_feasibility_jump_var_perburbation_range_ratio(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.feasibility_jump_var_perburbation_range_ratio)
}
inline double SatParameters::_internal_feasibility_jump_var_perburbation_range_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feasibility_jump_var_perburbation_range_ratio_;
}
inline void SatParameters::_internal_set_feasibility_jump_var_perburbation_range_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00100000u;
  _impl_.feasibility_jump_var_perburbation_range_ratio_ = value;
}

// optional bool feasibility_jump_enable_restarts = 250 [default = true];
inline bool SatParameters::has_feasibility_jump_enable_restarts() const {
  bool value = (_impl_._has_bits_[5] & 0x00000008u) != 0;
  return value;
}
inline void SatParameters::clear_feasibility_jump_enable_restarts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feasibility_jump_enable_restarts_ = true;
  _impl_._has_bits_[5] &= ~0x00000008u;
}
inline bool SatParameters::feasibility_jump_enable_restarts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.feasibility_jump_enable_restarts)
  return _internal_feasibility_jump_enable_restarts();
}
inline void SatParameters::set_feasibility_jump_enable_restarts(bool value) {
  _internal_set_feasibility_jump_enable_restarts(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.feasibility_jump_enable_restarts)
}
inline bool SatParameters::_internal_feasibility_jump_enable_restarts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feasibility_jump_enable_restarts_;
}
inline void SatParameters::_internal_set_feasibility_jump_enable_restarts(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000008u;
  _impl_.feasibility_jump_enable_restarts_ = value;
}

// optional int32 feasibility_jump_max_expanded_constraint_size = 264 [default = 100];
inline bool SatParameters::has_feasibility_jump_max_expanded_constraint_size() const {
  bool value = (_impl_._has_bits_[6] & 0x08000000u) != 0;
  return value;
}
inline void SatParameters::clear_feasibility_jump_max_expanded_constraint_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.feasibility_jump_max_expanded_constraint_size_ = 100;
  _impl_._has_bits_[6] &= ~0x08000000u;
}
inline ::int32_t SatParameters::feasibility_jump_max_expanded_constraint_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.feasibility_jump_max_expanded_constraint_size)
  return _internal_feasibility_jump_max_expanded_constraint_size();
}
inline void SatParameters::set_feasibility_jump_max_expanded_constraint_size(::int32_t value) {
  _internal_set_feasibility_jump_max_expanded_constraint_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.feasibility_jump_max_expanded_constraint_size)
}
inline ::int32_t SatParameters::_internal_feasibility_jump_max_expanded_constraint_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.feasibility_jump_max_expanded_constraint_size_;
}
inline void SatParameters::_internal_set_feasibility_jump_max_expanded_constraint_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x08000000u;
  _impl_.feasibility_jump_max_expanded_constraint_size_ = value;
}

// optional int32 num_violation_ls = 244 [default = 0];
inline bool SatParameters::has_num_violation_ls() const {
  bool value = (_impl_._has_bits_[2] & 0x00800000u) != 0;
  return value;
}
inline void SatParameters::clear_num_violation_ls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_violation_ls_ = 0;
  _impl_._has_bits_[2] &= ~0x00800000u;
}
inline ::int32_t SatParameters::num_violation_ls() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.num_violation_ls)
  return _internal_num_violation_ls();
}
inline void SatParameters::set_num_violation_ls(::int32_t value) {
  _internal_set_num_violation_ls(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.num_violation_ls)
}
inline ::int32_t SatParameters::_internal_num_violation_ls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_violation_ls_;
}
inline void SatParameters::_internal_set_num_violation_ls(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00800000u;
  _impl_.num_violation_ls_ = value;
}

// optional int32 violation_ls_perturbation_period = 249 [default = 100];
inline bool SatParameters::has_violation_ls_perturbation_period() const {
  bool value = (_impl_._has_bits_[6] & 0x00080000u) != 0;
  return value;
}
inline void SatParameters::clear_violation_ls_perturbation_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.violation_ls_perturbation_period_ = 100;
  _impl_._has_bits_[6] &= ~0x00080000u;
}
inline ::int32_t SatParameters::violation_ls_perturbation_period() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.violation_ls_perturbation_period)
  return _internal_violation_ls_perturbation_period();
}
inline void SatParameters::set_violation_ls_perturbation_period(::int32_t value) {
  _internal_set_violation_ls_perturbation_period(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.violation_ls_perturbation_period)
}
inline ::int32_t SatParameters::_internal_violation_ls_perturbation_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.violation_ls_perturbation_period_;
}
inline void SatParameters::_internal_set_violation_ls_perturbation_period(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00080000u;
  _impl_.violation_ls_perturbation_period_ = value;
}

// optional double violation_ls_compound_move_probability = 259 [default = 0.5];
inline bool SatParameters::has_violation_ls_compound_move_probability() const {
  bool value = (_impl_._has_bits_[6] & 0x00800000u) != 0;
  return value;
}
inline void SatParameters::clear_violation_ls_compound_move_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.violation_ls_compound_move_probability_ = 0.5;
  _impl_._has_bits_[6] &= ~0x00800000u;
}
inline double SatParameters::violation_ls_compound_move_probability() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.violation_ls_compound_move_probability)
  return _internal_violation_ls_compound_move_probability();
}
inline void SatParameters::set_violation_ls_compound_move_probability(double value) {
  _internal_set_violation_ls_compound_move_probability(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.violation_ls_compound_move_probability)
}
inline double SatParameters::_internal_violation_ls_compound_move_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.violation_ls_compound_move_probability_;
}
inline void SatParameters::_internal_set_violation_ls_compound_move_probability(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00800000u;
  _impl_.violation_ls_compound_move_probability_ = value;
}

// optional int32 shared_tree_num_workers = 235 [default = 0];
inline bool SatParameters::has_shared_tree_num_workers() const {
  bool value = (_impl_._has_bits_[2] & 0x00200000u) != 0;
  return value;
}
inline void SatParameters::clear_shared_tree_num_workers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shared_tree_num_workers_ = 0;
  _impl_._has_bits_[2] &= ~0x00200000u;
}
inline ::int32_t SatParameters::shared_tree_num_workers() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.shared_tree_num_workers)
  return _internal_shared_tree_num_workers();
}
inline void SatParameters::set_shared_tree_num_workers(::int32_t value) {
  _internal_set_shared_tree_num_workers(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.shared_tree_num_workers)
}
inline ::int32_t SatParameters::_internal_shared_tree_num_workers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shared_tree_num_workers_;
}
inline void SatParameters::_internal_set_shared_tree_num_workers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00200000u;
  _impl_.shared_tree_num_workers_ = value;
}

// optional bool use_shared_tree_search = 236 [default = false];
inline bool SatParameters::has_use_shared_tree_search() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline void SatParameters::clear_use_shared_tree_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_shared_tree_search_ = false;
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline bool SatParameters::use_shared_tree_search() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_shared_tree_search)
  return _internal_use_shared_tree_search();
}
inline void SatParameters::set_use_shared_tree_search(bool value) {
  _internal_set_use_shared_tree_search(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_shared_tree_search)
}
inline bool SatParameters::_internal_use_shared_tree_search() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_shared_tree_search_;
}
inline void SatParameters::_internal_set_use_shared_tree_search(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.use_shared_tree_search_ = value;
}

// optional double shared_tree_worker_objective_split_probability = 237 [default = 0.5];
inline bool SatParameters::has_shared_tree_worker_objective_split_probability() const {
  bool value = (_impl_._has_bits_[6] & 0x00010000u) != 0;
  return value;
}
inline void SatParameters::clear_shared_tree_worker_objective_split_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shared_tree_worker_objective_split_probability_ = 0.5;
  _impl_._has_bits_[6] &= ~0x00010000u;
}
inline double SatParameters::shared_tree_worker_objective_split_probability() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.shared_tree_worker_objective_split_probability)
  return _internal_shared_tree_worker_objective_split_probability();
}
inline void SatParameters::set_shared_tree_worker_objective_split_probability(double value) {
  _internal_set_shared_tree_worker_objective_split_probability(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.shared_tree_worker_objective_split_probability)
}
inline double SatParameters::_internal_shared_tree_worker_objective_split_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shared_tree_worker_objective_split_probability_;
}
inline void SatParameters::_internal_set_shared_tree_worker_objective_split_probability(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00010000u;
  _impl_.shared_tree_worker_objective_split_probability_ = value;
}

// optional int32 shared_tree_max_nodes_per_worker = 238 [default = 128];
inline bool SatParameters::has_shared_tree_max_nodes_per_worker() const {
  bool value = (_impl_._has_bits_[6] & 0x00040000u) != 0;
  return value;
}
inline void SatParameters::clear_shared_tree_max_nodes_per_worker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shared_tree_max_nodes_per_worker_ = 128;
  _impl_._has_bits_[6] &= ~0x00040000u;
}
inline ::int32_t SatParameters::shared_tree_max_nodes_per_worker() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.shared_tree_max_nodes_per_worker)
  return _internal_shared_tree_max_nodes_per_worker();
}
inline void SatParameters::set_shared_tree_max_nodes_per_worker(::int32_t value) {
  _internal_set_shared_tree_max_nodes_per_worker(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.shared_tree_max_nodes_per_worker)
}
inline ::int32_t SatParameters::_internal_shared_tree_max_nodes_per_worker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shared_tree_max_nodes_per_worker_;
}
inline void SatParameters::_internal_set_shared_tree_max_nodes_per_worker(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00040000u;
  _impl_.shared_tree_max_nodes_per_worker_ = value;
}

// optional .operations_research.sat.SatParameters.SharedTreeSplitStrategy shared_tree_split_strategy = 239 [default = SPLIT_STRATEGY_AUTO];
inline bool SatParameters::has_shared_tree_split_strategy() const {
  bool value = (_impl_._has_bits_[2] & 0x00400000u) != 0;
  return value;
}
inline void SatParameters::clear_shared_tree_split_strategy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shared_tree_split_strategy_ = 0;
  _impl_._has_bits_[2] &= ~0x00400000u;
}
inline ::operations_research::sat::SatParameters_SharedTreeSplitStrategy SatParameters::shared_tree_split_strategy() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.shared_tree_split_strategy)
  return _internal_shared_tree_split_strategy();
}
inline void SatParameters::set_shared_tree_split_strategy(::operations_research::sat::SatParameters_SharedTreeSplitStrategy value) {
  _internal_set_shared_tree_split_strategy(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.shared_tree_split_strategy)
}
inline ::operations_research::sat::SatParameters_SharedTreeSplitStrategy SatParameters::_internal_shared_tree_split_strategy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_SharedTreeSplitStrategy>(_impl_.shared_tree_split_strategy_);
}
inline void SatParameters::_internal_set_shared_tree_split_strategy(::operations_research::sat::SatParameters_SharedTreeSplitStrategy value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_SharedTreeSplitStrategy_IsValid(value));
  _impl_._has_bits_[2] |= 0x00400000u;
  _impl_.shared_tree_split_strategy_ = value;
}

// optional bool enumerate_all_solutions = 87 [default = false];
inline bool SatParameters::has_enumerate_all_solutions() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline void SatParameters::clear_enumerate_all_solutions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enumerate_all_solutions_ = false;
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline bool SatParameters::enumerate_all_solutions() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.enumerate_all_solutions)
  return _internal_enumerate_all_solutions();
}
inline void SatParameters::set_enumerate_all_solutions(bool value) {
  _internal_set_enumerate_all_solutions(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.enumerate_all_solutions)
}
inline bool SatParameters::_internal_enumerate_all_solutions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enumerate_all_solutions_;
}
inline void SatParameters::_internal_set_enumerate_all_solutions(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.enumerate_all_solutions_ = value;
}

// optional bool keep_all_feasible_solutions_in_presolve = 173 [default = false];
inline bool SatParameters::has_keep_all_feasible_solutions_in_presolve() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline void SatParameters::clear_keep_all_feasible_solutions_in_presolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keep_all_feasible_solutions_in_presolve_ = false;
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline bool SatParameters::keep_all_feasible_solutions_in_presolve() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.keep_all_feasible_solutions_in_presolve)
  return _internal_keep_all_feasible_solutions_in_presolve();
}
inline void SatParameters::set_keep_all_feasible_solutions_in_presolve(bool value) {
  _internal_set_keep_all_feasible_solutions_in_presolve(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.keep_all_feasible_solutions_in_presolve)
}
inline bool SatParameters::_internal_keep_all_feasible_solutions_in_presolve() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keep_all_feasible_solutions_in_presolve_;
}
inline void SatParameters::_internal_set_keep_all_feasible_solutions_in_presolve(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00002000u;
  _impl_.keep_all_feasible_solutions_in_presolve_ = value;
}

// optional bool fill_tightened_domains_in_response = 132 [default = false];
inline bool SatParameters::has_fill_tightened_domains_in_response() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline void SatParameters::clear_fill_tightened_domains_in_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fill_tightened_domains_in_response_ = false;
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline bool SatParameters::fill_tightened_domains_in_response() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.fill_tightened_domains_in_response)
  return _internal_fill_tightened_domains_in_response();
}
inline void SatParameters::set_fill_tightened_domains_in_response(bool value) {
  _internal_set_fill_tightened_domains_in_response(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.fill_tightened_domains_in_response)
}
inline bool SatParameters::_internal_fill_tightened_domains_in_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fill_tightened_domains_in_response_;
}
inline void SatParameters::_internal_set_fill_tightened_domains_in_response(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00004000u;
  _impl_.fill_tightened_domains_in_response_ = value;
}

// optional bool fill_additional_solutions_in_response = 194 [default = false];
inline bool SatParameters::has_fill_additional_solutions_in_response() const {
  bool value = (_impl_._has_bits_[1] & 0x10000000u) != 0;
  return value;
}
inline void SatParameters::clear_fill_additional_solutions_in_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fill_additional_solutions_in_response_ = false;
  _impl_._has_bits_[1] &= ~0x10000000u;
}
inline bool SatParameters::fill_additional_solutions_in_response() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.fill_additional_solutions_in_response)
  return _internal_fill_additional_solutions_in_response();
}
inline void SatParameters::set_fill_additional_solutions_in_response(bool value) {
  _internal_set_fill_additional_solutions_in_response(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.fill_additional_solutions_in_response)
}
inline bool SatParameters::_internal_fill_additional_solutions_in_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fill_additional_solutions_in_response_;
}
inline void SatParameters::_internal_set_fill_additional_solutions_in_response(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x10000000u;
  _impl_.fill_additional_solutions_in_response_ = value;
}

// optional bool instantiate_all_variables = 106 [default = true];
inline bool SatParameters::has_instantiate_all_variables() const {
  bool value = (_impl_._has_bits_[5] & 0x00000010u) != 0;
  return value;
}
inline void SatParameters::clear_instantiate_all_variables() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.instantiate_all_variables_ = true;
  _impl_._has_bits_[5] &= ~0x00000010u;
}
inline bool SatParameters::instantiate_all_variables() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.instantiate_all_variables)
  return _internal_instantiate_all_variables();
}
inline void SatParameters::set_instantiate_all_variables(bool value) {
  _internal_set_instantiate_all_variables(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.instantiate_all_variables)
}
inline bool SatParameters::_internal_instantiate_all_variables() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.instantiate_all_variables_;
}
inline void SatParameters::_internal_set_instantiate_all_variables(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000010u;
  _impl_.instantiate_all_variables_ = value;
}

// optional bool auto_detect_greater_than_at_least_one_of = 95 [default = true];
inline bool SatParameters::has_auto_detect_greater_than_at_least_one_of() const {
  bool value = (_impl_._has_bits_[5] & 0x00000020u) != 0;
  return value;
}
inline void SatParameters::clear_auto_detect_greater_than_at_least_one_of() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.auto_detect_greater_than_at_least_one_of_ = true;
  _impl_._has_bits_[5] &= ~0x00000020u;
}
inline bool SatParameters::auto_detect_greater_than_at_least_one_of() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.auto_detect_greater_than_at_least_one_of)
  return _internal_auto_detect_greater_than_at_least_one_of();
}
inline void SatParameters::set_auto_detect_greater_than_at_least_one_of(bool value) {
  _internal_set_auto_detect_greater_than_at_least_one_of(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.auto_detect_greater_than_at_least_one_of)
}
inline bool SatParameters::_internal_auto_detect_greater_than_at_least_one_of() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.auto_detect_greater_than_at_least_one_of_;
}
inline void SatParameters::_internal_set_auto_detect_greater_than_at_least_one_of(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000020u;
  _impl_.auto_detect_greater_than_at_least_one_of_ = value;
}

// optional bool stop_after_first_solution = 98 [default = false];
inline bool SatParameters::has_stop_after_first_solution() const {
  bool value = (_impl_._has_bits_[1] & 0x20000000u) != 0;
  return value;
}
inline void SatParameters::clear_stop_after_first_solution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stop_after_first_solution_ = false;
  _impl_._has_bits_[1] &= ~0x20000000u;
}
inline bool SatParameters::stop_after_first_solution() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.stop_after_first_solution)
  return _internal_stop_after_first_solution();
}
inline void SatParameters::set_stop_after_first_solution(bool value) {
  _internal_set_stop_after_first_solution(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.stop_after_first_solution)
}
inline bool SatParameters::_internal_stop_after_first_solution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stop_after_first_solution_;
}
inline void SatParameters::_internal_set_stop_after_first_solution(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x20000000u;
  _impl_.stop_after_first_solution_ = value;
}

// optional bool stop_after_presolve = 149 [default = false];
inline bool SatParameters::has_stop_after_presolve() const {
  bool value = (_impl_._has_bits_[1] & 0x40000000u) != 0;
  return value;
}
inline void SatParameters::clear_stop_after_presolve() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stop_after_presolve_ = false;
  _impl_._has_bits_[1] &= ~0x40000000u;
}
inline bool SatParameters::stop_after_presolve() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.stop_after_presolve)
  return _internal_stop_after_presolve();
}
inline void SatParameters::set_stop_after_presolve(bool value) {
  _internal_set_stop_after_presolve(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.stop_after_presolve)
}
inline bool SatParameters::_internal_stop_after_presolve() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stop_after_presolve_;
}
inline void SatParameters::_internal_set_stop_after_presolve(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x40000000u;
  _impl_.stop_after_presolve_ = value;
}

// optional bool stop_after_root_propagation = 252 [default = false];
inline bool SatParameters::has_stop_after_root_propagation() const {
  bool value = (_impl_._has_bits_[1] & 0x80000000u) != 0;
  return value;
}
inline void SatParameters::clear_stop_after_root_propagation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stop_after_root_propagation_ = false;
  _impl_._has_bits_[1] &= ~0x80000000u;
}
inline bool SatParameters::stop_after_root_propagation() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.stop_after_root_propagation)
  return _internal_stop_after_root_propagation();
}
inline void SatParameters::set_stop_after_root_propagation(bool value) {
  _internal_set_stop_after_root_propagation(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.stop_after_root_propagation)
}
inline bool SatParameters::_internal_stop_after_root_propagation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stop_after_root_propagation_;
}
inline void SatParameters::_internal_set_stop_after_root_propagation(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x80000000u;
  _impl_.stop_after_root_propagation_ = value;
}

// optional bool use_lns_only = 101 [default = false];
inline bool SatParameters::has_use_lns_only() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline void SatParameters::clear_use_lns_only() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_lns_only_ = false;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline bool SatParameters::use_lns_only() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_lns_only)
  return _internal_use_lns_only();
}
inline void SatParameters::set_use_lns_only(bool value) {
  _internal_set_use_lns_only(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_lns_only)
}
inline bool SatParameters::_internal_use_lns_only() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_lns_only_;
}
inline void SatParameters::_internal_set_use_lns_only(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.use_lns_only_ = value;
}

// optional int32 solution_pool_size = 193 [default = 3];
inline bool SatParameters::has_solution_pool_size() const {
  bool value = (_impl_._has_bits_[6] & 0x00000001u) != 0;
  return value;
}
inline void SatParameters::clear_solution_pool_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.solution_pool_size_ = 3;
  _impl_._has_bits_[6] &= ~0x00000001u;
}
inline ::int32_t SatParameters::solution_pool_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.solution_pool_size)
  return _internal_solution_pool_size();
}
inline void SatParameters::set_solution_pool_size(::int32_t value) {
  _internal_set_solution_pool_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.solution_pool_size)
}
inline ::int32_t SatParameters::_internal_solution_pool_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.solution_pool_size_;
}
inline void SatParameters::_internal_set_solution_pool_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000001u;
  _impl_.solution_pool_size_ = value;
}

// optional bool use_rins_lns = 129 [default = true];
inline bool SatParameters::has_use_rins_lns() const {
  bool value = (_impl_._has_bits_[5] & 0x00000040u) != 0;
  return value;
}
inline void SatParameters::clear_use_rins_lns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_rins_lns_ = true;
  _impl_._has_bits_[5] &= ~0x00000040u;
}
inline bool SatParameters::use_rins_lns() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_rins_lns)
  return _internal_use_rins_lns();
}
inline void SatParameters::set_use_rins_lns(bool value) {
  _internal_set_use_rins_lns(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_rins_lns)
}
inline bool SatParameters::_internal_use_rins_lns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_rins_lns_;
}
inline void SatParameters::_internal_set_use_rins_lns(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000040u;
  _impl_.use_rins_lns_ = value;
}

// optional bool use_feasibility_pump = 164 [default = true];
inline bool SatParameters::has_use_feasibility_pump() const {
  bool value = (_impl_._has_bits_[4] & 0x40000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_feasibility_pump() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_feasibility_pump_ = true;
  _impl_._has_bits_[4] &= ~0x40000000u;
}
inline bool SatParameters::use_feasibility_pump() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_feasibility_pump)
  return _internal_use_feasibility_pump();
}
inline void SatParameters::set_use_feasibility_pump(bool value) {
  _internal_set_use_feasibility_pump(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_feasibility_pump)
}
inline bool SatParameters::_internal_use_feasibility_pump() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_feasibility_pump_;
}
inline void SatParameters::_internal_set_use_feasibility_pump(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x40000000u;
  _impl_.use_feasibility_pump_ = value;
}

// optional bool use_lb_relax_lns = 255 [default = false];
inline bool SatParameters::has_use_lb_relax_lns() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline void SatParameters::clear_use_lb_relax_lns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_lb_relax_lns_ = false;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline bool SatParameters::use_lb_relax_lns() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_lb_relax_lns)
  return _internal_use_lb_relax_lns();
}
inline void SatParameters::set_use_lb_relax_lns(bool value) {
  _internal_set_use_lb_relax_lns(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_lb_relax_lns)
}
inline bool SatParameters::_internal_use_lb_relax_lns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_lb_relax_lns_;
}
inline void SatParameters::_internal_set_use_lb_relax_lns(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.use_lb_relax_lns_ = value;
}

// optional .operations_research.sat.SatParameters.FPRoundingMethod fp_rounding = 165 [default = PROPAGATION_ASSISTED];
inline bool SatParameters::has_fp_rounding() const {
  bool value = (_impl_._has_bits_[5] & 0x00100000u) != 0;
  return value;
}
inline void SatParameters::clear_fp_rounding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fp_rounding_ = 2;
  _impl_._has_bits_[5] &= ~0x00100000u;
}
inline ::operations_research::sat::SatParameters_FPRoundingMethod SatParameters::fp_rounding() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.fp_rounding)
  return _internal_fp_rounding();
}
inline void SatParameters::set_fp_rounding(::operations_research::sat::SatParameters_FPRoundingMethod value) {
  _internal_set_fp_rounding(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.fp_rounding)
}
inline ::operations_research::sat::SatParameters_FPRoundingMethod SatParameters::_internal_fp_rounding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::operations_research::sat::SatParameters_FPRoundingMethod>(_impl_.fp_rounding_);
}
inline void SatParameters::_internal_set_fp_rounding(::operations_research::sat::SatParameters_FPRoundingMethod value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::operations_research::sat::SatParameters_FPRoundingMethod_IsValid(value));
  _impl_._has_bits_[5] |= 0x00100000u;
  _impl_.fp_rounding_ = value;
}

// optional bool diversify_lns_params = 137 [default = false];
inline bool SatParameters::has_diversify_lns_params() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline void SatParameters::clear_diversify_lns_params() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.diversify_lns_params_ = false;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline bool SatParameters::diversify_lns_params() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.diversify_lns_params)
  return _internal_diversify_lns_params();
}
inline void SatParameters::set_diversify_lns_params(bool value) {
  _internal_set_diversify_lns_params(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.diversify_lns_params)
}
inline bool SatParameters::_internal_diversify_lns_params() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.diversify_lns_params_;
}
inline void SatParameters::_internal_set_diversify_lns_params(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.diversify_lns_params_ = value;
}

// optional bool randomize_search = 103 [default = false];
inline bool SatParameters::has_randomize_search() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline void SatParameters::clear_randomize_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.randomize_search_ = false;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline bool SatParameters::randomize_search() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.randomize_search)
  return _internal_randomize_search();
}
inline void SatParameters::set_randomize_search(bool value) {
  _internal_set_randomize_search(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.randomize_search)
}
inline bool SatParameters::_internal_randomize_search() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.randomize_search_;
}
inline void SatParameters::_internal_set_randomize_search(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.randomize_search_ = value;
}

// optional int64 search_random_variable_pool_size = 104 [default = 0];
inline bool SatParameters::has_search_random_variable_pool_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void SatParameters::clear_search_random_variable_pool_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_random_variable_pool_size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::int64_t SatParameters::search_random_variable_pool_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.search_random_variable_pool_size)
  return _internal_search_random_variable_pool_size();
}
inline void SatParameters::set_search_random_variable_pool_size(::int64_t value) {
  _internal_set_search_random_variable_pool_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.search_random_variable_pool_size)
}
inline ::int64_t SatParameters::_internal_search_random_variable_pool_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_random_variable_pool_size_;
}
inline void SatParameters::_internal_set_search_random_variable_pool_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.search_random_variable_pool_size_ = value;
}

// optional bool push_all_tasks_toward_start = 262 [default = false];
inline bool SatParameters::has_push_all_tasks_toward_start() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline void SatParameters::clear_push_all_tasks_toward_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.push_all_tasks_toward_start_ = false;
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline bool SatParameters::push_all_tasks_toward_start() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.push_all_tasks_toward_start)
  return _internal_push_all_tasks_toward_start();
}
inline void SatParameters::set_push_all_tasks_toward_start(bool value) {
  _internal_set_push_all_tasks_toward_start(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.push_all_tasks_toward_start)
}
inline bool SatParameters::_internal_push_all_tasks_toward_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.push_all_tasks_toward_start_;
}
inline void SatParameters::_internal_set_push_all_tasks_toward_start(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00008000u;
  _impl_.push_all_tasks_toward_start_ = value;
}

// optional bool use_optional_variables = 108 [default = false];
inline bool SatParameters::has_use_optional_variables() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline void SatParameters::clear_use_optional_variables() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_optional_variables_ = false;
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline bool SatParameters::use_optional_variables() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_optional_variables)
  return _internal_use_optional_variables();
}
inline void SatParameters::set_use_optional_variables(bool value) {
  _internal_set_use_optional_variables(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_optional_variables)
}
inline bool SatParameters::_internal_use_optional_variables() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_optional_variables_;
}
inline void SatParameters::_internal_set_use_optional_variables(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00010000u;
  _impl_.use_optional_variables_ = value;
}

// optional bool use_exact_lp_reason = 109 [default = true];
inline bool SatParameters::has_use_exact_lp_reason() const {
  bool value = (_impl_._has_bits_[4] & 0x80000000u) != 0;
  return value;
}
inline void SatParameters::clear_use_exact_lp_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_exact_lp_reason_ = true;
  _impl_._has_bits_[4] &= ~0x80000000u;
}
inline bool SatParameters::use_exact_lp_reason() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_exact_lp_reason)
  return _internal_use_exact_lp_reason();
}
inline void SatParameters::set_use_exact_lp_reason(bool value) {
  _internal_set_use_exact_lp_reason(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_exact_lp_reason)
}
inline bool SatParameters::_internal_use_exact_lp_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_exact_lp_reason_;
}
inline void SatParameters::_internal_set_use_exact_lp_reason(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x80000000u;
  _impl_.use_exact_lp_reason_ = value;
}

// optional bool use_branching_in_lp = 139 [default = false];
inline bool SatParameters::has_use_branching_in_lp() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline void SatParameters::clear_use_branching_in_lp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_branching_in_lp_ = false;
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline bool SatParameters::use_branching_in_lp() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_branching_in_lp)
  return _internal_use_branching_in_lp();
}
inline void SatParameters::set_use_branching_in_lp(bool value) {
  _internal_set_use_branching_in_lp(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_branching_in_lp)
}
inline bool SatParameters::_internal_use_branching_in_lp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_branching_in_lp_;
}
inline void SatParameters::_internal_set_use_branching_in_lp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00020000u;
  _impl_.use_branching_in_lp_ = value;
}

// optional bool use_combined_no_overlap = 133 [default = false];
inline bool SatParameters::has_use_combined_no_overlap() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline void SatParameters::clear_use_combined_no_overlap() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_combined_no_overlap_ = false;
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline bool SatParameters::use_combined_no_overlap() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_combined_no_overlap)
  return _internal_use_combined_no_overlap();
}
inline void SatParameters::set_use_combined_no_overlap(bool value) {
  _internal_set_use_combined_no_overlap(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_combined_no_overlap)
}
inline bool SatParameters::_internal_use_combined_no_overlap() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_combined_no_overlap_;
}
inline void SatParameters::_internal_set_use_combined_no_overlap(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00040000u;
  _impl_.use_combined_no_overlap_ = value;
}

// optional bool catch_sigint_signal = 135 [default = true];
inline bool SatParameters::has_catch_sigint_signal() const {
  bool value = (_impl_._has_bits_[5] & 0x00000001u) != 0;
  return value;
}
inline void SatParameters::clear_catch_sigint_signal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catch_sigint_signal_ = true;
  _impl_._has_bits_[5] &= ~0x00000001u;
}
inline bool SatParameters::catch_sigint_signal() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.catch_sigint_signal)
  return _internal_catch_sigint_signal();
}
inline void SatParameters::set_catch_sigint_signal(bool value) {
  _internal_set_catch_sigint_signal(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.catch_sigint_signal)
}
inline bool SatParameters::_internal_catch_sigint_signal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catch_sigint_signal_;
}
inline void SatParameters::_internal_set_catch_sigint_signal(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000001u;
  _impl_.catch_sigint_signal_ = value;
}

// optional bool use_implied_bounds = 144 [default = true];
inline bool SatParameters::has_use_implied_bounds() const {
  bool value = (_impl_._has_bits_[5] & 0x00000002u) != 0;
  return value;
}
inline void SatParameters::clear_use_implied_bounds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_implied_bounds_ = true;
  _impl_._has_bits_[5] &= ~0x00000002u;
}
inline bool SatParameters::use_implied_bounds() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.use_implied_bounds)
  return _internal_use_implied_bounds();
}
inline void SatParameters::set_use_implied_bounds(bool value) {
  _internal_set_use_implied_bounds(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.use_implied_bounds)
}
inline bool SatParameters::_internal_use_implied_bounds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_implied_bounds_;
}
inline void SatParameters::_internal_set_use_implied_bounds(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x00000002u;
  _impl_.use_implied_bounds_ = value;
}

// optional bool polish_lp_solution = 175 [default = false];
inline bool SatParameters::has_polish_lp_solution() const {
  bool value = (_impl_._has_bits_[2] & 0x00020000u) != 0;
  return value;
}
inline void SatParameters::clear_polish_lp_solution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.polish_lp_solution_ = false;
  _impl_._has_bits_[2] &= ~0x00020000u;
}
inline bool SatParameters::polish_lp_solution() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.polish_lp_solution)
  return _internal_polish_lp_solution();
}
inline void SatParameters::set_polish_lp_solution(bool value) {
  _internal_set_polish_lp_solution(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.polish_lp_solution)
}
inline bool SatParameters::_internal_polish_lp_solution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.polish_lp_solution_;
}
inline void SatParameters::_internal_set_polish_lp_solution(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00020000u;
  _impl_.polish_lp_solution_ = value;
}

// optional double lp_primal_tolerance = 266 [default = 1e-07];
inline bool SatParameters::has_lp_primal_tolerance() const {
  bool value = (_impl_._has_bits_[6] & 0x10000000u) != 0;
  return value;
}
inline void SatParameters::clear_lp_primal_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lp_primal_tolerance_ = 1e-07;
  _impl_._has_bits_[6] &= ~0x10000000u;
}
inline double SatParameters::lp_primal_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.lp_primal_tolerance)
  return _internal_lp_primal_tolerance();
}
inline void SatParameters::set_lp_primal_tolerance(double value) {
  _internal_set_lp_primal_tolerance(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.lp_primal_tolerance)
}
inline double SatParameters::_internal_lp_primal_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lp_primal_tolerance_;
}
inline void SatParameters::_internal_set_lp_primal_tolerance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x10000000u;
  _impl_.lp_primal_tolerance_ = value;
}

// optional double lp_dual_tolerance = 267 [default = 1e-07];
inline bool SatParameters::has_lp_dual_tolerance() const {
  bool value = (_impl_._has_bits_[6] & 0x20000000u) != 0;
  return value;
}
inline void SatParameters::clear_lp_dual_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lp_dual_tolerance_ = 1e-07;
  _impl_._has_bits_[6] &= ~0x20000000u;
}
inline double SatParameters::lp_dual_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.lp_dual_tolerance)
  return _internal_lp_dual_tolerance();
}
inline void SatParameters::set_lp_dual_tolerance(double value) {
  _internal_set_lp_dual_tolerance(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.lp_dual_tolerance)
}
inline double SatParameters::_internal_lp_dual_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lp_dual_tolerance_;
}
inline void SatParameters::_internal_set_lp_dual_tolerance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x20000000u;
  _impl_.lp_dual_tolerance_ = value;
}

// optional bool convert_intervals = 177 [default = true];
inline bool SatParameters::has_convert_intervals() const {
  bool value = (_impl_._has_bits_[5] & 0x04000000u) != 0;
  return value;
}
inline void SatParameters::clear_convert_intervals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.convert_intervals_ = true;
  _impl_._has_bits_[5] &= ~0x04000000u;
}
inline bool SatParameters::convert_intervals() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.convert_intervals)
  return _internal_convert_intervals();
}
inline void SatParameters::set_convert_intervals(bool value) {
  _internal_set_convert_intervals(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.convert_intervals)
}
inline bool SatParameters::_internal_convert_intervals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.convert_intervals_;
}
inline void SatParameters::_internal_set_convert_intervals(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x04000000u;
  _impl_.convert_intervals_ = value;
}

// optional int32 symmetry_level = 183 [default = 2];
inline bool SatParameters::has_symmetry_level() const {
  bool value = (_impl_._has_bits_[5] & 0x20000000u) != 0;
  return value;
}
inline void SatParameters::clear_symmetry_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.symmetry_level_ = 2;
  _impl_._has_bits_[5] &= ~0x20000000u;
}
inline ::int32_t SatParameters::symmetry_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.symmetry_level)
  return _internal_symmetry_level();
}
inline void SatParameters::set_symmetry_level(::int32_t value) {
  _internal_set_symmetry_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.symmetry_level)
}
inline ::int32_t SatParameters::_internal_symmetry_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.symmetry_level_;
}
inline void SatParameters::_internal_set_symmetry_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x20000000u;
  _impl_.symmetry_level_ = value;
}

// optional bool new_linear_propagation = 224 [default = false];
inline bool SatParameters::has_new_linear_propagation() const {
  bool value = (_impl_._has_bits_[2] & 0x00040000u) != 0;
  return value;
}
inline void SatParameters::clear_new_linear_propagation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_linear_propagation_ = false;
  _impl_._has_bits_[2] &= ~0x00040000u;
}
inline bool SatParameters::new_linear_propagation() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.new_linear_propagation)
  return _internal_new_linear_propagation();
}
inline void SatParameters::set_new_linear_propagation(bool value) {
  _internal_set_new_linear_propagation(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.new_linear_propagation)
}
inline bool SatParameters::_internal_new_linear_propagation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_linear_propagation_;
}
inline void SatParameters::_internal_set_new_linear_propagation(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00040000u;
  _impl_.new_linear_propagation_ = value;
}

// optional int32 linear_split_size = 256 [default = 100];
inline bool SatParameters::has_linear_split_size() const {
  bool value = (_impl_._has_bits_[6] & 0x00200000u) != 0;
  return value;
}
inline void SatParameters::clear_linear_split_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.linear_split_size_ = 100;
  _impl_._has_bits_[6] &= ~0x00200000u;
}
inline ::int32_t SatParameters::linear_split_size() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.linear_split_size)
  return _internal_linear_split_size();
}
inline void SatParameters::set_linear_split_size(::int32_t value) {
  _internal_set_linear_split_size(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.linear_split_size)
}
inline ::int32_t SatParameters::_internal_linear_split_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.linear_split_size_;
}
inline void SatParameters::_internal_set_linear_split_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00200000u;
  _impl_.linear_split_size_ = value;
}

// optional double mip_max_bound = 124 [default = 10000000];
inline bool SatParameters::has_mip_max_bound() const {
  bool value = (_impl_._has_bits_[4] & 0x00100000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_max_bound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_max_bound_ = 10000000;
  _impl_._has_bits_[4] &= ~0x00100000u;
}
inline double SatParameters::mip_max_bound() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_max_bound)
  return _internal_mip_max_bound();
}
inline void SatParameters::set_mip_max_bound(double value) {
  _internal_set_mip_max_bound(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_max_bound)
}
inline double SatParameters::_internal_mip_max_bound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_max_bound_;
}
inline void SatParameters::_internal_set_mip_max_bound(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00100000u;
  _impl_.mip_max_bound_ = value;
}

// optional double mip_var_scaling = 125 [default = 1];
inline bool SatParameters::has_mip_var_scaling() const {
  bool value = (_impl_._has_bits_[4] & 0x00200000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_var_scaling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_var_scaling_ = 1;
  _impl_._has_bits_[4] &= ~0x00200000u;
}
inline double SatParameters::mip_var_scaling() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_var_scaling)
  return _internal_mip_var_scaling();
}
inline void SatParameters::set_mip_var_scaling(double value) {
  _internal_set_mip_var_scaling(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_var_scaling)
}
inline double SatParameters::_internal_mip_var_scaling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_var_scaling_;
}
inline void SatParameters::_internal_set_mip_var_scaling(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00200000u;
  _impl_.mip_var_scaling_ = value;
}

// optional bool mip_scale_large_domain = 225 [default = false];
inline bool SatParameters::has_mip_scale_large_domain() const {
  bool value = (_impl_._has_bits_[2] & 0x00080000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_scale_large_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_scale_large_domain_ = false;
  _impl_._has_bits_[2] &= ~0x00080000u;
}
inline bool SatParameters::mip_scale_large_domain() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_scale_large_domain)
  return _internal_mip_scale_large_domain();
}
inline void SatParameters::set_mip_scale_large_domain(bool value) {
  _internal_set_mip_scale_large_domain(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_scale_large_domain)
}
inline bool SatParameters::_internal_mip_scale_large_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_scale_large_domain_;
}
inline void SatParameters::_internal_set_mip_scale_large_domain(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00080000u;
  _impl_.mip_scale_large_domain_ = value;
}

// optional bool mip_automatically_scale_variables = 166 [default = true];
inline bool SatParameters::has_mip_automatically_scale_variables() const {
  bool value = (_impl_._has_bits_[5] & 0x08000000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_automatically_scale_variables() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_automatically_scale_variables_ = true;
  _impl_._has_bits_[5] &= ~0x08000000u;
}
inline bool SatParameters::mip_automatically_scale_variables() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_automatically_scale_variables)
  return _internal_mip_automatically_scale_variables();
}
inline void SatParameters::set_mip_automatically_scale_variables(bool value) {
  _internal_set_mip_automatically_scale_variables(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_automatically_scale_variables)
}
inline bool SatParameters::_internal_mip_automatically_scale_variables() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_automatically_scale_variables_;
}
inline void SatParameters::_internal_set_mip_automatically_scale_variables(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x08000000u;
  _impl_.mip_automatically_scale_variables_ = value;
}

// optional bool only_solve_ip = 222 [default = false];
inline bool SatParameters::has_only_solve_ip() const {
  bool value = (_impl_._has_bits_[2] & 0x00100000u) != 0;
  return value;
}
inline void SatParameters::clear_only_solve_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.only_solve_ip_ = false;
  _impl_._has_bits_[2] &= ~0x00100000u;
}
inline bool SatParameters::only_solve_ip() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.only_solve_ip)
  return _internal_only_solve_ip();
}
inline void SatParameters::set_only_solve_ip(bool value) {
  _internal_set_only_solve_ip(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.only_solve_ip)
}
inline bool SatParameters::_internal_only_solve_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.only_solve_ip_;
}
inline void SatParameters::_internal_set_only_solve_ip(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[2] |= 0x00100000u;
  _impl_.only_solve_ip_ = value;
}

// optional double mip_wanted_precision = 126 [default = 1e-06];
inline bool SatParameters::has_mip_wanted_precision() const {
  bool value = (_impl_._has_bits_[4] & 0x00400000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_wanted_precision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_wanted_precision_ = 1e-06;
  _impl_._has_bits_[4] &= ~0x00400000u;
}
inline double SatParameters::mip_wanted_precision() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_wanted_precision)
  return _internal_mip_wanted_precision();
}
inline void SatParameters::set_mip_wanted_precision(double value) {
  _internal_set_mip_wanted_precision(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_wanted_precision)
}
inline double SatParameters::_internal_mip_wanted_precision() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_wanted_precision_;
}
inline void SatParameters::_internal_set_mip_wanted_precision(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00400000u;
  _impl_.mip_wanted_precision_ = value;
}

// optional int32 mip_max_activity_exponent = 127 [default = 53];
inline bool SatParameters::has_mip_max_activity_exponent() const {
  bool value = (_impl_._has_bits_[4] & 0x01000000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_max_activity_exponent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_max_activity_exponent_ = 53;
  _impl_._has_bits_[4] &= ~0x01000000u;
}
inline ::int32_t SatParameters::mip_max_activity_exponent() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_max_activity_exponent)
  return _internal_mip_max_activity_exponent();
}
inline void SatParameters::set_mip_max_activity_exponent(::int32_t value) {
  _internal_set_mip_max_activity_exponent(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_max_activity_exponent)
}
inline ::int32_t SatParameters::_internal_mip_max_activity_exponent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_max_activity_exponent_;
}
inline void SatParameters::_internal_set_mip_max_activity_exponent(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x01000000u;
  _impl_.mip_max_activity_exponent_ = value;
}

// optional double mip_check_precision = 128 [default = 0.0001];
inline bool SatParameters::has_mip_check_precision() const {
  bool value = (_impl_._has_bits_[4] & 0x00800000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_check_precision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_check_precision_ = 0.0001;
  _impl_._has_bits_[4] &= ~0x00800000u;
}
inline double SatParameters::mip_check_precision() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_check_precision)
  return _internal_mip_check_precision();
}
inline void SatParameters::set_mip_check_precision(double value) {
  _internal_set_mip_check_precision(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_check_precision)
}
inline double SatParameters::_internal_mip_check_precision() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_check_precision_;
}
inline void SatParameters::_internal_set_mip_check_precision(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[4] |= 0x00800000u;
  _impl_.mip_check_precision_ = value;
}

// optional bool mip_compute_true_objective_bound = 198 [default = true];
inline bool SatParameters::has_mip_compute_true_objective_bound() const {
  bool value = (_impl_._has_bits_[5] & 0x10000000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_compute_true_objective_bound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_compute_true_objective_bound_ = true;
  _impl_._has_bits_[5] &= ~0x10000000u;
}
inline bool SatParameters::mip_compute_true_objective_bound() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_compute_true_objective_bound)
  return _internal_mip_compute_true_objective_bound();
}
inline void SatParameters::set_mip_compute_true_objective_bound(bool value) {
  _internal_set_mip_compute_true_objective_bound(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_compute_true_objective_bound)
}
inline bool SatParameters::_internal_mip_compute_true_objective_bound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_compute_true_objective_bound_;
}
inline void SatParameters::_internal_set_mip_compute_true_objective_bound(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[5] |= 0x10000000u;
  _impl_.mip_compute_true_objective_bound_ = value;
}

// optional double mip_max_valid_magnitude = 199 [default = 1e+30];
inline bool SatParameters::has_mip_max_valid_magnitude() const {
  bool value = (_impl_._has_bits_[6] & 0x00000002u) != 0;
  return value;
}
inline void SatParameters::clear_mip_max_valid_magnitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_max_valid_magnitude_ = 1e+30;
  _impl_._has_bits_[6] &= ~0x00000002u;
}
inline double SatParameters::mip_max_valid_magnitude() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_max_valid_magnitude)
  return _internal_mip_max_valid_magnitude();
}
inline void SatParameters::set_mip_max_valid_magnitude(double value) {
  _internal_set_mip_max_valid_magnitude(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_max_valid_magnitude)
}
inline double SatParameters::_internal_mip_max_valid_magnitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_max_valid_magnitude_;
}
inline void SatParameters::_internal_set_mip_max_valid_magnitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00000002u;
  _impl_.mip_max_valid_magnitude_ = value;
}

// optional double mip_drop_tolerance = 232 [default = 1e-16];
inline bool SatParameters::has_mip_drop_tolerance() const {
  bool value = (_impl_._has_bits_[6] & 0x00008000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_drop_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_drop_tolerance_ = 1e-16;
  _impl_._has_bits_[6] &= ~0x00008000u;
}
inline double SatParameters::mip_drop_tolerance() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_drop_tolerance)
  return _internal_mip_drop_tolerance();
}
inline void SatParameters::set_mip_drop_tolerance(double value) {
  _internal_set_mip_drop_tolerance(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_drop_tolerance)
}
inline double SatParameters::_internal_mip_drop_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_drop_tolerance_;
}
inline void SatParameters::_internal_set_mip_drop_tolerance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x00008000u;
  _impl_.mip_drop_tolerance_ = value;
}

// optional int32 mip_presolve_level = 261 [default = 2];
inline bool SatParameters::has_mip_presolve_level() const {
  bool value = (_impl_._has_bits_[6] & 0x04000000u) != 0;
  return value;
}
inline void SatParameters::clear_mip_presolve_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mip_presolve_level_ = 2;
  _impl_._has_bits_[6] &= ~0x04000000u;
}
inline ::int32_t SatParameters::mip_presolve_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SatParameters.mip_presolve_level)
  return _internal_mip_presolve_level();
}
inline void SatParameters::set_mip_presolve_level(::int32_t value) {
  _internal_set_mip_presolve_level(value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SatParameters.mip_presolve_level)
}
inline ::int32_t SatParameters::_internal_mip_presolve_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mip_presolve_level_;
}
inline void SatParameters::_internal_set_mip_presolve_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[6] |= 0x04000000u;
  _impl_.mip_presolve_level_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace sat
}  // namespace operations_research


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::operations_research::sat::SatParameters_VariableOrder> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_VariableOrder>() {
  return ::operations_research::sat::SatParameters_VariableOrder_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_Polarity> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_Polarity>() {
  return ::operations_research::sat::SatParameters_Polarity_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm>() {
  return ::operations_research::sat::SatParameters_ConflictMinimizationAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_BinaryMinizationAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_BinaryMinizationAlgorithm>() {
  return ::operations_research::sat::SatParameters_BinaryMinizationAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_ClauseProtection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_ClauseProtection>() {
  return ::operations_research::sat::SatParameters_ClauseProtection_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_ClauseOrdering> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_ClauseOrdering>() {
  return ::operations_research::sat::SatParameters_ClauseOrdering_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_RestartAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_RestartAlgorithm>() {
  return ::operations_research::sat::SatParameters_RestartAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_MaxSatAssumptionOrder> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_MaxSatAssumptionOrder>() {
  return ::operations_research::sat::SatParameters_MaxSatAssumptionOrder_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm>() {
  return ::operations_research::sat::SatParameters_MaxSatStratificationAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_SearchBranching> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_SearchBranching>() {
  return ::operations_research::sat::SatParameters_SearchBranching_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_SharedTreeSplitStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_SharedTreeSplitStrategy>() {
  return ::operations_research::sat::SatParameters_SharedTreeSplitStrategy_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::SatParameters_FPRoundingMethod> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::operations_research::sat::SatParameters_FPRoundingMethod>() {
  return ::operations_research::sat::SatParameters_FPRoundingMethod_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ortools_2fsat_2fsat_5fparameters_2eproto_2epb_2eh
